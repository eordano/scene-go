(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../../../tmp/0.7762286444876978.WebWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../tmp/0.7762286444876978.WebWorker.js":
/*!********************************************!*\
  !*** /tmp/0.7762286444876978.WebWorker.js ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _usr_src_app_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/decentraland-rpc/lib/common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\");\n\n\nconst imported = __webpack_require__(/*! ./scene.tsx */ \"./scene.tsx\")\n\nif (imported && imported.__esModule && imported['default']) {\n  new imported['default'](Object(_usr_src_app_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__[\"WebWorkerTransport\"])(self))\n}\n\n\n//# sourceURL=webpack:////tmp/0.7762286444876978.WebWorker.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/MessageBus.js":
/*!*********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/MessageBus.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventDispatcher_1 = __webpack_require__(/*! decentraland-rpc/lib/common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n/**\n * MessageBusClient provides an easy way to send and reveive peer to peer\n * messages thru the communications interface of Decentraland.\n *\n * The usage is simple, it implements a pub-sub pattern that shares messages\n * using the connection that already exists between peers.\n *\n * @example inside your ScriptableScene\n * ```ts\n *   let messageBusClient = await MessageBusClient.acquireEstateChannel(this)\n *   messageBusClient.on('a message name', (message) => {...})\n *   messageBusClient.emit('a message name', message)\n * ```\n */\nclass MessageBusClient extends EventDispatcher_1.EventDispatcher {\n    constructor(api, id, busClientId) {\n        super();\n        this.api = api;\n        this.id = id;\n        this.busClientId = busClientId;\n        api[`on${this.id}`]((message) => {\n            if (this.busClientId !== message.sender) {\n                super.emit(message.event, ...message.args);\n            }\n        });\n    }\n    static async acquireEstateChannel(system) {\n        const busId = Math.random().toString(36);\n        const { MessageBus } = await system.loadAPIs(['MessageBus']);\n        const bus = await MessageBus.getEstateChannel();\n        return new MessageBusClient(MessageBus, bus.id, busId);\n    }\n    emit(event, ...args) {\n        this.api[this.id]({\n            event,\n            args,\n            sender: this.busClientId\n        });\n        super.emit(event, ...args);\n    }\n}\nexports.MessageBusClient = MessageBusClient;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUJ1cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9NZXNzYWdlQnVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsc0ZBQWtGO0FBU2xGOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFhLGdCQUEwQixTQUFRLGlDQUFrQjtJQUMvRCxZQUE4QixHQUFRLEVBQVksRUFBVSxFQUFZLFdBQW1CO1FBQ3pGLEtBQUssRUFBRSxDQUFBO1FBRHFCLFFBQUcsR0FBSCxHQUFHLENBQUs7UUFBWSxPQUFFLEdBQUYsRUFBRSxDQUFRO1FBQVksZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFFekYsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFpQixFQUFFLEVBQUU7WUFDeEMsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUMzQztRQUNILENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsTUFBdUI7UUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUN4QyxNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQTtRQUU1RCxNQUFNLEdBQUcsR0FBRyxNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1FBRS9DLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUN4RCxDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQWEsRUFBRSxHQUFHLElBQVc7UUFDaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDaEIsS0FBSztZQUNMLElBQUk7WUFDSixNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVc7U0FDYixDQUFDLENBQUE7UUFDZCxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFBO0lBQzVCLENBQUM7Q0FDRjtBQTNCRCw0Q0EyQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5pbXBvcnQgeyBTY3JpcHRhYmxlU2NlbmUgfSBmcm9tICcuJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgZXZlbnQ6IHN0cmluZ1xuICBhcmdzOiBhbnlbXVxuICBzZW5kZXI6IHN0cmluZ1xufVxuXG4vKipcbiAqIE1lc3NhZ2VCdXNDbGllbnQgcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gc2VuZCBhbmQgcmV2ZWl2ZSBwZWVyIHRvIHBlZXJcbiAqIG1lc3NhZ2VzIHRocnUgdGhlIGNvbW11bmljYXRpb25zIGludGVyZmFjZSBvZiBEZWNlbnRyYWxhbmQuXG4gKlxuICogVGhlIHVzYWdlIGlzIHNpbXBsZSwgaXQgaW1wbGVtZW50cyBhIHB1Yi1zdWIgcGF0dGVybiB0aGF0IHNoYXJlcyBtZXNzYWdlc1xuICogdXNpbmcgdGhlIGNvbm5lY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyBiZXR3ZWVuIHBlZXJzLlxuICpcbiAqIEBleGFtcGxlIGluc2lkZSB5b3VyIFNjcmlwdGFibGVTY2VuZVxuICogYGBgdHNcbiAqICAgbGV0IG1lc3NhZ2VCdXNDbGllbnQgPSBhd2FpdCBNZXNzYWdlQnVzQ2xpZW50LmFjcXVpcmVFc3RhdGVDaGFubmVsKHRoaXMpXG4gKiAgIG1lc3NhZ2VCdXNDbGllbnQub24oJ2EgbWVzc2FnZSBuYW1lJywgKG1lc3NhZ2UpID0+IHsuLi59KVxuICogICBtZXNzYWdlQnVzQ2xpZW50LmVtaXQoJ2EgbWVzc2FnZSBuYW1lJywgbWVzc2FnZSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZUJ1c0NsaWVudDxUID0gYW55PiBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjxUPiB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvdGVjdGVkIGFwaTogYW55LCBwcm90ZWN0ZWQgaWQ6IHN0cmluZywgcHJvdGVjdGVkIGJ1c0NsaWVudElkOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgYXBpW2BvbiR7dGhpcy5pZH1gXSgobWVzc2FnZTogSU1lc3NhZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLmJ1c0NsaWVudElkICE9PSBtZXNzYWdlLnNlbmRlcikge1xuICAgICAgICBzdXBlci5lbWl0KG1lc3NhZ2UuZXZlbnQsIC4uLm1lc3NhZ2UuYXJncylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGFjcXVpcmVFc3RhdGVDaGFubmVsKHN5c3RlbTogU2NyaXB0YWJsZVNjZW5lKSB7XG4gICAgY29uc3QgYnVzSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVxuICAgIGNvbnN0IHsgTWVzc2FnZUJ1cyB9ID0gYXdhaXQgc3lzdGVtLmxvYWRBUElzKFsnTWVzc2FnZUJ1cyddKVxuXG4gICAgY29uc3QgYnVzID0gYXdhaXQgTWVzc2FnZUJ1cy5nZXRFc3RhdGVDaGFubmVsKClcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUJ1c0NsaWVudChNZXNzYWdlQnVzLCBidXMuaWQsIGJ1c0lkKVxuICB9XG5cbiAgZW1pdChldmVudDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMuYXBpW3RoaXMuaWRdKHtcbiAgICAgIGV2ZW50LFxuICAgICAgYXJncyxcbiAgICAgIHNlbmRlcjogdGhpcy5idXNDbGllbnRJZFxuICAgIH0gYXMgSU1lc3NhZ2UpXG4gICAgc3VwZXIuZW1pdChldmVudCwgLi4uYXJncylcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/MessageBus.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/ScriptableScene.js":
/*!**************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/ScriptableScene.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst decentraland_rpc_1 = __webpack_require__(/*! decentraland-rpc */ \"./node_modules/decentraland-rpc/lib/client/index.js\");\nconst future_1 = __webpack_require__(/*! ./utils/future */ \"./node_modules/decentraland-api/lib/utils/future.js\");\nconst handlers_1 = __webpack_require__(/*! ./handlers */ \"./node_modules/decentraland-api/lib/handlers.js\");\nconst interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./node_modules/decentraland-api/lib/interfaces.js\");\nconst vdom_1 = __webpack_require__(/*! ./internal/vdom */ \"./node_modules/decentraland-api/lib/internal/vdom.js\");\nconst ReplaceWholeTreeException_1 = __webpack_require__(/*! ./internal/ReplaceWholeTreeException */ \"./node_modules/decentraland-api/lib/internal/ReplaceWholeTreeException.js\");\nexports.defer = Promise.resolve().then.bind(Promise.resolve());\n/** Managed queue of dirty components to be re-rendered */\nlet items = [];\nfunction enqueueRender(scene) {\n    if (!scene._dirty) {\n        scene._dirty = true;\n        if (items.push(scene) === 1) {\n            exports.defer(rerender);\n        }\n    }\n}\nfunction rerender() {\n    let p;\n    const list = items;\n    items = [];\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((p = list.pop())) {\n        if (p._dirty)\n            renderScriptableScene(p);\n    }\n}\nfunction filterNonFalsy($) {\n    return !!$;\n}\nlet currentFunctionMap;\nconst attrRegularExpression = /^on[A-Z]/;\n/**\n * This function finds recursively all the /on[A-Z]./ attributes that are also a\n * function, then it replaces the function by a UUID. It stores the reference in\n * the currentFunctionMap\n */\nfunction fixCallbacks(scene, component) {\n    currentFunctionMap = scene._functionMap;\n    if (!currentFunctionMap) {\n        currentFunctionMap = scene._functionMap = new Map();\n    }\n    else {\n        currentFunctionMap.clear();\n    }\n    if (component) {\n        fixAttributes(component);\n    }\n}\nfunction fixAttributes(node) {\n    if (node.attrs) {\n        for (let i in node.attrs) {\n            if (attrRegularExpression.test(i)) {\n                if (typeof node.attrs[i] === 'function') {\n                    const fn = node.attrs[i];\n                    const id = handlers_1.putHandler(fn);\n                    currentFunctionMap.set(id, fn);\n                    node.attrs[i] = id;\n                }\n            }\n        }\n    }\n    if (node.children) {\n        for (let i = 0; i < node.children.length; i++) {\n            fixAttributes(node.children[i]);\n        }\n    }\n}\nfunction recursiveRender(tree) {\n    if (typeof tree === 'string') {\n        // tslint:disable-next-line:no-console\n        console.error('Warning, you are trying to render a text');\n        return null;\n    }\n    if (typeof tree.tag === 'function') {\n        const hoc = tree.tag;\n        if (hoc.prototype && hoc.prototype.render) {\n            throw new Error('Only function components are allowed');\n        }\n        return hoc(Object.assign({}, tree.attrs, { children: tree.children }));\n    }\n    if (!tree || !tree.tag)\n        return null;\n    return {\n        tag: tree.tag,\n        attrs: tree.attrs,\n        children: tree.children.map(recursiveRender).filter(filterNonFalsy)\n    };\n}\nexports.recursiveRender = recursiveRender;\nconst fallback = new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n/**\n * Render a ScriptableScene, triggering necessary lifecycle events and taking High-Order ScriptableScenes into account.\n * @param {ScriptableScene} scene\n * @internal\n */\nfunction renderScriptableScene(scene, force) {\n    let props = scene.props;\n    let state = scene.state;\n    let previousProps = scene.prevProps || props;\n    let previousState = scene.prevState || state;\n    let skip = false;\n    const isUpdate = !!scene._component;\n    // if updating\n    if (isUpdate) {\n        scene.props = previousProps;\n        scene.state = previousState;\n        if (!force && scene.shouldSceneUpdate && scene.shouldSceneUpdate(props, state) === false) {\n            skip = true;\n        }\n        scene.props = props;\n        scene.state = state;\n    }\n    scene.prevProps = scene.prevState = null;\n    scene._dirty = false;\n    if (!skip) {\n        let rendererResult = scene.render(props, state);\n        if (!('then' in rendererResult && 'catch' in rendererResult)) {\n            rendererResult = Promise.resolve(rendererResult);\n        }\n        rendererResult\n            .then(recursiveRender)\n            .then(async (rendered) => {\n            if (!rendered) {\n                throw new Error('the async render() method yielded an empty result');\n            }\n            const originalDom = scene._component;\n            scene._component = rendered;\n            // replace functions by uuids\n            fixCallbacks(scene, scene._component);\n            if (scene.sceneDidUpdate) {\n                await scene.sceneDidUpdate(previousProps, previousState);\n            }\n            await scene.connectionFuture;\n            try {\n                if (originalDom) {\n                    try {\n                        const diff = scene.differ.diff(originalDom, scene._component);\n                        const msg = {\n                            diff,\n                            protocol: 1\n                        };\n                        await scene.entityController.render(msg);\n                    }\n                    catch (e) {\n                        debugger;\n                        throw fallback;\n                    }\n                }\n                else {\n                    throw fallback;\n                }\n            }\n            catch (e) {\n                if (e.message === interfaces_1.Constants.ReplaceWholeTreeException) {\n                    await scene.entityController.render(scene._component);\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .catch(err => {\n            // tslint:disable-next-line:no-console\n            console.error(err);\n        });\n    }\n}\nexports.renderScriptableScene = renderScriptableScene;\n/**\n * Base Scene class.\n * Provides `setState()` and `forceUpdate()`, which trigger rendering.\n * @public\n *\n * @example\n * class MyFoo extends ScriptableScene {\n *   async render() {\n *     return <sphere />;\n *   }\n * }\n */\nclass ScriptableScene extends decentraland_rpc_1.Script {\n    constructor() {\n        super(...arguments);\n        // @internal\n        this._dirty = true;\n        // @internal\n        this._functionMap = new Map();\n        // @internal\n        this.prevProps = null;\n        // @internal\n        this.prevState = null;\n        // @internal\n        this._component = null;\n        // @internal\n        this.differ = new vdom_1.DiffDOM();\n        this.state = {};\n        // @internal\n        this.connectionFuture = future_1.future();\n        this.receiveUuidEvent = (event) => {\n            const map = this._functionMap;\n            if (map) {\n                const fn = map.get(event.data.uuid);\n                if (fn) {\n                    fn(event.data.payload);\n                }\n            }\n        };\n    }\n    /**\n     * Update scene state by copying properties from `state` to `this.state`.\n     * @param {object} state A hash of state properties to update with new values\n     */\n    setState(state) {\n        let s = this.state;\n        if (!this.prevState)\n            this.prevState = Object.assign({}, s);\n        Object.assign(s, typeof state === 'function' ? state(s, this.props) : state);\n        enqueueRender(this);\n    }\n    /**\n     * Immediately perform a synchronous re-render of the component.\n     */\n    forceUpdate() {\n        renderScriptableScene(this, true);\n    }\n    /**\n     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire\n     * protocol.\n     *\n     * @param event name of the remote event to listen\n     * @param handler an async\n     */\n    subscribeTo(event, handler) {\n        // tslint:disable-next-line:no-floating-promises\n        this.connectionFuture.then(() => {\n            this.eventSubscriber.on(event, x => {\n                const ret = handler(x.data);\n                if (ret && 'catch' in ret && typeof ret.catch === 'function') {\n                    ret.catch(err => this.emit('error', err));\n                }\n            });\n        });\n    }\n    /**\n     * Get a standard ethereum provider\n     * Please notice this is highly experimental and might change in the future.\n     *\n     * method whitelist = [\n     *   'eth_sendTransaction',\n     *   'eth_getTransactionReceipt',\n     *   'eth_estimateGas',\n     *   'eth_call',\n     *   'eth_getBalance',\n     *   'eth_getStorageAt',\n     *   'eth_blockNumber',\n     *   'eth_getBlockByNumber',\n     *   'eth_gasPrice',\n     *   'eth_protocolVersion',\n     *   'net_version',\n     *   'web3_sha3',\n     *   'web3_clientVersion',\n     *   'eth_getTransactionCount'\n     * ]\n     */\n    async getEthereumProvider() {\n        const { EthereumController } = await this.loadAPIs(['EthereumController']);\n        return {\n            // @internal\n            send(message, callback) {\n                if (message && callback && callback instanceof Function) {\n                    EthereumController.sendAsync(message)\n                        .then((x) => callback(null, x))\n                        .catch(callback);\n                }\n                else {\n                    throw new Error('Decentraland provider only allows async calls');\n                }\n            },\n            sendAsync(message, callback) {\n                EthereumController.sendAsync(message)\n                    .then((x) => callback(null, x))\n                    .catch(callback);\n            }\n        };\n    }\n    // @internal\n    async systemDidEnable() {\n        this.props = (await this.entityController.getOwnAttributes());\n        // we create an event subscriber\n        this.eventSubscriber = new decentraland_rpc_1.EventSubscriber(this.entityController);\n        this.on('SIGKILL', () => {\n            if (this.sceneWillUnmount) {\n                this.sceneWillUnmount();\n            }\n        });\n        this.subscribeTo('setAttributes', newProps => {\n            this.prevProps = this.props;\n            this.props = newProps;\n            enqueueRender(this);\n        });\n        this.connectionFuture.resolve(this);\n        renderScriptableScene(this, true);\n        this.eventSubscriber.on('uuidEvent', this.receiveUuidEvent);\n        if (this.sceneDidMount) {\n            await this.sceneDidMount();\n        }\n    }\n}\n__decorate([\n    decentraland_rpc_1.inject('EntityController'),\n    __metadata(\"design:type\", Object)\n], ScriptableScene.prototype, \"entityController\", void 0);\nexports.ScriptableScene = ScriptableScene;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0YWJsZVNjZW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjcmlwdGFibGVTY2VuZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHVEQUFrRTtBQUNsRSwyQ0FBdUM7QUFDdkMseUNBQXVDO0FBQ3ZDLDZDQUF5RDtBQUl6RCwwQ0FBeUM7QUFFekMsb0ZBQWdGO0FBRW5FLFFBQUEsS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFBO0FBRW5FLDBEQUEwRDtBQUUxRCxJQUFJLEtBQUssR0FBZ0MsRUFBRSxDQUFBO0FBRTNDLFNBQVMsYUFBYSxDQUFPLEtBQTRCO0lBQ3ZELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFBO1FBQ25CLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDM0IsYUFBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1NBQ2hCO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsU0FBUyxRQUFRO0lBQ2YsSUFBSSxDQUE4QixDQUFBO0lBQ2xDLE1BQU0sSUFBSSxHQUFzQixLQUFLLENBQUE7SUFDckMsS0FBSyxHQUFHLEVBQUUsQ0FBQTtJQUNWLHFEQUFxRDtJQUNyRCxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDLE1BQU07WUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUN2QztBQUNILENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxDQUFNO0lBQzVCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNaLENBQUM7QUFFRCxJQUFJLGtCQUF5QyxDQUFBO0FBQzdDLE1BQU0scUJBQXFCLEdB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RUFBRSxRQUFRLENBQUMsRUFBRTtZQUMzQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUE7WUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFpQixDQUFBO1lBQzlCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUNyQixDQUFDLENBQUMsQ0FBQTtRQUVGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUE7UUFFbkMscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO1FBRWpDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUUzRCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsTUFBTSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUE7U0FDM0I7SUFDSCxDQUFDO0NBV0Y7QUExSkM7SUFEQyx5QkFBTSxDQUFDLGtCQUFrQixDQUFDOzt5REFDUTtBQUZyQywwQ0E0SkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHQsIGluamVjdCwgRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSAnZGVjZW50cmFsYW5kLXJwYydcbmltcG9ydCB7IGZ1dHVyZSB9IGZyb20gJy4vdXRpbHMvZnV0dXJlJ1xuaW1wb3J0IHsgcHV0SGFuZGxlciB9IGZyb20gJy4vaGFuZGxlcnMnXG5pbXBvcnQgeyBJU2ltcGxpZmllZE5vZGUsIENvbnN0YW50cyB9IGZyb20gJy4vaW50ZXJmYWNlcydcbmltcG9ydCB7IEVudGl0eUNvbnRyb2xsZXIsIFJQQ1NlbmRhYmxlTWVzc2FnZSB9IGZyb20gJy4vYXBpcydcbmltcG9ydCB7IElFdmVudE5hbWVzLCBJRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMnXG5cbmltcG9ydCB7IERpZmZET00gfSBmcm9tICcuL2ludGVybmFsL3Zkb20nXG5pbXBvcnQgeyBEaWZmUGFja2V0IH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcydcbmltcG9ydCB7IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gfSBmcm9tICcuL2ludGVybmFsL1JlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24nXG5cbmV4cG9ydCBjb25zdCBkZWZlciA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG5sZXQgaXRlbXM6IFNjcmlwdGFibGVTY2VuZTxhbnksIGFueT5bXSA9IFtdXG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXI8RCwgVD4oc2NlbmU6IFNjcmlwdGFibGVTY2VuZTxELCBUPikge1xuICBpZiAoIXNjZW5lLl9kaXJ0eSkge1xuICAgIHNjZW5lLl9kaXJ0eSA9IHRydWVcbiAgICBpZiAoaXRlbXMucHVzaChzY2VuZSkgPT09IDEpIHtcbiAgICAgIGRlZmVyKHJlcmVuZGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgbGV0IHA6IFNjcmlwdGFibGVTY2VuZSB8IHVuZGVmaW5lZFxuICBjb25zdCBsaXN0OiBTY3JpcHRhYmxlU2NlbmVbXSA9IGl0ZW1zXG4gIGl0ZW1zID0gW11cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgd2hpbGUgKChwID0gbGlzdC5wb3AoKSkpIHtcbiAgICBpZiAocC5fZGlydHkpIHJlbmRlclNjcmlwdGFibGVTY2VuZShwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5vbkZhbHN5KCQ6IGFueSk6ICQgaXMgdHJ1ZSB7XG4gIHJldHVybiAhISRcbn1cblxubGV0IGN1cnJlbnRGdW5jdGlvbk1hcDogTWFwPHN0cmluZywgRnVuY3Rpb24+XG5jb25zdCBhdHRyUmVndWxhckV4cHJlc3Npb24gPSAvXm9uW0EtWl0vXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyByZWN1cnNpdmVseSBhbGwgdGhlIC9vbltBLVpdLi8gYXR0cmlidXRlcyB0aGF0IGFyZSBhbHNvIGFcbiAqIGZ1bmN0aW9uLCB0aGVuIGl0IHJlcGxhY2VzIHRoZSBmdW5jdGlvbiBieSBhIFVVSUQuIEl0IHN0b3JlcyB0aGUgcmVmZXJlbmNlIGluXG4gKiB0aGUgY3VycmVudEZ1bmN0aW9uTWFwXG4gKi9cbmZ1bmN0aW9uIGZpeENhbGxiYWNrcyhzY2VuZTogU2NyaXB0YWJsZVNjZW5lPGFueSwgYW55PiwgY29tcG9uZW50OiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgY3VycmVudEZ1bmN0aW9uTWFwID0gc2NlbmUuX2Z1bmN0aW9uTWFwXG5cbiAgaWYgKCFjdXJyZW50RnVuY3Rpb25NYXApIHtcbiAgICBjdXJyZW50RnVuY3Rpb25NYXAgPSBzY2VuZS5fZnVuY3Rpb25NYXAgPSBuZXcgTWFwKClcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50RnVuY3Rpb25NYXAuY2xlYXIoKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGZpeEF0dHJpYnV0ZXMoY29tcG9uZW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpeEF0dHJpYnV0ZXMobm9kZTogSVNpbXBsaWZpZWROb2RlKSB7XG4gIGlmIChub2RlLmF0dHJzKSB7XG4gICAgZm9yIChsZXQgaSBpbiBub2RlLmF0dHJzKSB7XG4gICAgICBpZiAoYXR0clJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoaSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLmF0dHJzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgZm46IGFueSA9IG5vZGUuYXR0cnNbaV1cbiAgICAgICAgICBjb25zdCBpZCA9IHB1dEhhbmRsZXIoZm4pXG4gICAgICAgICAgY3VycmVudEZ1bmN0aW9uTWFwLnNldChpZCwgZm4pXG4gICAgICAgICAgbm9kZS5hdHRyc1tpXSA9IGlkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZml4QXR0cmlidXRlcyhub2RlLmNoaWxkcmVuW2ldKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaXZlUmVuZGVyKHRyZWU6IElTaW1wbGlmaWVkTm9kZSk6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwge1xuICBpZiAodHlwZW9mIHRyZWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmVycm9yKCdXYXJuaW5nLCB5b3UgYXJlIHRyeWluZyB0byByZW5kZXIgYSB0ZXh0JylcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHR5cGVvZiAodHJlZS50YWcgYXMgYW55KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhvYyA9ICh0cmVlLnRhZyBhcyBhbnkpIGFzIEZ1bmN0aW9uXG4gICAgaWYgKGhvYy5wcm90b3R5cGUgJiYgaG9jLnByb3RvdHlwZS5yZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBmdW5jdGlvbiBjb21wb25lbnRzIGFyZSBhbGxvd2VkJylcbiAgICB9XG4gICAgcmV0dXJuIGhvYyh7IC4uLnRyZWUuYXR0cnMsIGNoaWxkcmVuOiB0cmVlLmNoaWxkcmVuIH0pXG4gIH1cblxuICBpZiAoIXRyZWUgfHwgIXRyZWUudGFnKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgdGFnOiB0cmVlLnRhZyxcbiAgICBhdHRyczogdHJlZS5hdHRycyxcbiAgICBjaGlsZHJlbjogKHRyZWUuY2hpbGRyZW4ubWFwKHJlY3Vyc2l2ZVJlbmRlcikuZmlsdGVyKGZpbHRlck5vbkZhbHN5KSBhcyBhbnkpIGFzIElTaW1wbGlmaWVkTm9kZVtdXG4gIH1cbn1cblxuY29uc3QgZmFsbGJhY2sgPSBuZXcgUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbigpXG5cbi8qKlxuICogUmVuZGVyIGEgU2NyaXB0YWJsZVNjZW5lLCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBTY3JpcHRhYmxlU2NlbmVzIGludG8gYWNjb3VudC5cbiAqIEBwYXJhbSB7U2NyaXB0YWJsZVNjZW5lfSBzY2VuZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPihzY2VuZTogU2NyaXB0YWJsZVNjZW5lPFByb3BzLCBTdGF0ZT4sIGZvcmNlPzogYm9vbGVhbikge1xuICBsZXQgcHJvcHMgPSBzY2VuZS5wcm9wc1xuICBsZXQgc3RhdGUgPSBzY2VuZS5zdGF0ZVxuICBsZXQgcHJldmlvdXNQcm9wcyA9IHNjZW5lLnByZXZQcm9wcyB8fCBwcm9wc1xuICBsZXQgcHJldmlvdXNTdGF0ZSA9IHNjZW5lLnByZXZTdGF0ZSB8fCBzdGF0ZVxuICBsZXQgc2tpcCA9IGZhbHNlXG4gIGNvbnN0IGlzVXBkYXRlID0gISFzY2VuZS5fY29tcG9uZW50XG5cbiAgLy8gaWYgdXBkYXRpbmdcbiAgaWYgKGlzVXBkYXRlKSB7XG4gICAgc2NlbmUucHJvcHMgPSBwcmV2aW91c1Byb3BzXG4gICAgc2NlbmUuc3RhdGUgPSBwcmV2aW91c1N0YXRlXG4gICAgaWYgKCFmb3JjZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZShwcm9wcywgc3RhdGUpID09PSBmYWxzZSkge1xuICAgICAgc2tpcCA9IHRydWVcbiAgICB9XG4gICAgc2NlbmUucHJvcHMgPSBwcm9wc1xuICAgIHNjZW5lLnN0YXRlID0gc3RhdGVcbiAgfVxuXG4gIHNjZW5lLnByZXZQcm9wcyA9IHNjZW5lLnByZXZTdGF0ZSA9IG51bGxcbiAgc2NlbmUuX2RpcnR5ID0gZmFsc2VcblxuICBpZiAoIXNraXApIHtcbiAgICBsZXQgcmVuZGVyZXJSZXN1bHQgPSBzY2VuZS5yZW5kZXIocHJvcHMsIHN0YXRlKVxuXG4gICAgaWYgKCEoJ3RoZW4nIGluIHJlbmRlcmVyUmVzdWx0ICYmICdjYXRjaCcgaW4gcmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICByZW5kZXJlclJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdClcbiAgICB9XG5cbiAgICByZW5kZXJlclJlc3VsdFxuICAgICAgLnRoZW4ocmVjdXJzaXZlUmVuZGVyKVxuICAgICAgLnRoZW4oYXN5bmMgcmVuZGVyZWQgPT4ge1xuICAgICAgICBpZiAoIXJlbmRlcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXN5bmMgcmVuZGVyKCkgbWV0aG9kIHlpZWxkZWQgYW4gZW1wdHkgcmVzdWx0JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRG9tID0gc2NlbmUuX2NvbXBvbmVudFxuXG4gICAgICAgIHNjZW5lLl9jb21wb25lbnQgPSByZW5kZXJlZFxuXG4gICAgICAgIC8vIHJlcGxhY2UgZnVuY3Rpb25zIGJ5IHV1aWRzXG4gICAgICAgIGZpeENhbGxiYWNrcyhzY2VuZSwgc2NlbmUuX2NvbXBvbmVudClcblxuICAgICAgICBpZiAoc2NlbmUuc2NlbmVEaWRVcGRhdGUpIHtcbiAgICAgICAgICBhd2FpdCBzY2VuZS5zY2VuZURpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2NlbmUuY29ubmVjdGlvbkZ1dHVyZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsRG9tKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBkaWZmID0gc2NlbmUuZGlmZmVyLmRpZmYob3JpZ2luYWxEb20sIHNjZW5lLl9jb21wb25lbnQpXG5cbiAgICAgICAgICAgICAgY29uc3QgbXNnOiBEaWZmUGFja2V0ID0ge1xuICAgICAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IDFcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKG1zZylcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBDb25zdGFudHMuUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbikge1xuICAgICAgICAgICAgYXdhaXQgc2NlbmUuZW50aXR5Q29udHJvbGxlci5yZW5kZXIoc2NlbmUuX2NvbXBvbmVudClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPiB7XG4gIHByb3BzOiBQcm9wc1xuICBzdGF0ZTogU3RhdGVcblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjaGFuZ2UgaW4gcHJvcHMgYW5kIHN0YXRlIHNob3VsZCB0cmlnZ2VyIGEgcmUtcmVuZGVyLlxuICAgKlxuICAgKiBJZiBmYWxzZSBpcyByZXR1cm5lZCwgYFNjcmlwdGFibGVTY2VuZSNyZW5kZXJgLCBhbmQgYHNjZW5lRGlkVXBkYXRlYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAqL1xuICBzaG91bGRTY2VuZVVwZGF0ZT8obmV4dFByb3BzOiBQcm9wcywgbmV4dFN0YXRlOiBTdGF0ZSk6IFByb21pc2U8Ym9vbGVhbj4gfCBib29sZWFuXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBzY2VuZSBpcyBkZXN0cm95ZWQuIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGluIHRoaXMgbWV0aG9kLCBzdWNoIGFzXG4gICAqIGNhbmNlbGxlZCBuZXR3b3JrIHJlcXVlc3RzLCBvciBjbGVhbmluZyB1cCBhbnkgZWxlbWVudHMgY3JlYXRlZCBpbiBgc2NlbmVEaWRNb3VudGAuXG4gICAqL1xuICBzY2VuZVdpbGxVbm1vdW50PygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBjb21wb21lbnQgaXMgbW91bnRlZC4gU2V0dGluZyBzdGF0ZSBoZXJlIHdpbGwgdHJpZ2dlciByZS1yZW5kZXJpbmcuXG4gICAqL1xuICBzY2VuZURpZE1vdW50PygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdXBkYXRpbmcgb2NjdXJzLiBOb3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAqL1xuICBzY2VuZURpZFVwZGF0ZT8ocHJldlByb3BzOiBSZWFkb25seTxQcm9wcz4sIHByZXZTdGF0ZTogUmVhZG9ubHk8U3RhdGU+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWRcbn1cblxuLyoqXG4gKiBCYXNlIFNjZW5lIGNsYXNzLlxuICogUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoIHRyaWdnZXIgcmVuZGVyaW5nLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBjbGFzcyBNeUZvbyBleHRlbmRzIFNjcmlwdGFibGVTY2VuZSB7XG4gKiAgIGFzeW5jIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gPHNwaGVyZSAvPjtcbiAqICAgfVxuICogfVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2NyaXB0YWJsZVNjZW5lPFByb3BzID0ge30sIFN0YXRlID0ge30+IGV4dGVuZHMgU2NyaXB0IHtcbiAgQGluamVjdCgnRW50aXR5Q29udHJvbGxlcicpXG4gIGVudGl0eUNvbnRyb2xsZXIhOiBFbnRpdHlDb250cm9sbGVyXG5cbiAgZXZlbnRTdWJzY3JpYmVyITogRXZlbnRTdWJzY3JpYmVyXG5cbiAgLy8gQGludGVybmFsXG4gIF9kaXJ0eSA9IHRydWVcbiAgLy8gQGludGVybmFsXG4gIF9mdW5jdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBGdW5jdGlvbj4oKVxuICAvLyBAaW50ZXJuYWxcbiAgcHJldlByb3BzOiBQcm9wcyB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBwcmV2U3RhdGU6IFN0YXRlIHwgbnVsbCA9IG51bGxcbiAgLy8gQGludGVybmFsXG4gIF9jb21wb25lbnQ6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBkaWZmZXIgPSBuZXcgRGlmZkRPTSgpXG5cbiAgc3RhdGU6IFN0YXRlID0ge30gYXMgU3RhdGVcblxuICAvLyBAaW50ZXJuYWxcbiAgY29ubmVjdGlvbkZ1dHVyZSA9IGZ1dHVyZTxTY3JpcHQ+KClcblxuICBwcm9wcyE6IFByb3BzXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY2VuZSBzdGF0ZSBieSBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBgc3RhdGVgIHRvIGB0aGlzLnN0YXRlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIEEgaGFzaCBvZiBzdGF0ZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlOiBQYXJ0aWFsPFN0YXRlPiB8ICgoc3RhdGU6IFN0YXRlLCBwcm9wczogUHJvcHMpID0+IFBhcnRpYWw8U3RhdGU+KSk6IHZvaWQge1xuICAgIGxldCBzID0gdGhpcy5zdGF0ZVxuICAgIGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcylcbiAgICBPYmplY3QuYXNzaWduKHMsIHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpXG4gICAgZW5xdWV1ZVJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGZvcmNlVXBkYXRlKCkge1xuICAgIHJlbmRlclNjcmlwdGFibGVTY2VuZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAgICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgICAgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnQgZWxlbWVudC9jb21wb25lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlICAgIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBhYnN0cmFjdCBhc3luYyByZW5kZXIocHJvcHM6IFByb3BzLCBzdGF0ZTogU3RhdGUpOiBQcm9taXNlPElTaW1wbGlmaWVkTm9kZT5cblxuICAvKipcbiAgICogSXQgbWFrZXMgYSBzdWJzY3JpcHRpb24gdG8gcmVtb3RlIGV2ZW50cywgdGhvc2UgZXZlbnRzIG9jY3VyIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnYW1lIGFuZCBhcmUgc2VudCB0aHJ1IHRoZSB3aXJlXG4gICAqIHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgbmFtZSBvZiB0aGUgcmVtb3RlIGV2ZW50IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gaGFuZGxlciBhbiBhc3luY1xuICAgKi9cbiAgc3Vic2NyaWJlVG88VCBleHRlbmRzIElFdmVudE5hbWVzPihldmVudDogVCwgaGFuZGxlcjogKGRhdGE6IElFdmVudHNbVF0pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy5jb25uZWN0aW9uRnV0dXJlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudFN1YnNjcmliZXIub24oZXZlbnQsIHggPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBoYW5kbGVyKHguZGF0YSlcbiAgICAgICAgaWYgKHJldCAmJiAnY2F0Y2gnIGluIHJldCAmJiB0eXBlb2YgcmV0LmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YW5kYXJkIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAqIFBsZWFzZSBub3RpY2UgdGhpcyBpcyBoaWdobHkgZXhwZXJpbWVudGFsIGFuZCBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogbWV0aG9kIHdoaXRlbGlzdCA9IFtcbiAgICogICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAqICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgKiAgICdldGhfZXN0aW1hdGVHYXMnLFxuICAgKiAgICdldGhfY2FsbCcsXG4gICAqICAgJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICogICAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAqICAgJ2V0aF9ibG9ja051bWJlcicsXG4gICAqICAgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICogICAnZXRoX2dhc1ByaWNlJyxcbiAgICogICAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAqICAgJ25ldF92ZXJzaW9uJyxcbiAgICogICAnd2ViM19zaGEzJyxcbiAgICogICAnd2ViM19jbGllbnRWZXJzaW9uJyxcbiAgICogICAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnXG4gICAqIF1cbiAgICovXG4gIGFzeW5jIGdldEV0aGVyZXVtUHJvdmlkZXIoKSB7XG4gICAgY29uc3QgeyBFdGhlcmV1bUNvbnRyb2xsZXIgfSA9IGF3YWl0IHRoaXMubG9hZEFQSXMoWydFdGhlcmV1bUNvbnRyb2xsZXInXSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBAaW50ZXJuYWxcbiAgICAgIHNlbmQobWVzc2FnZTogUlBDU2VuZGFibGVNZXNzYWdlLCBjYWxsYmFjaz86IChlcnJvcjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAgIC50aGVuKCh4OiBhbnkpID0+IGNhbGxiYWNrKG51bGwsIHgpKVxuICAgICAgICAgICAgLmNhdGNoKGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjZW50cmFsYW5kIHByb3ZpZGVyIG9ubHkgYWxsb3dzIGFzeW5jIGNhbGxzJylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbmRBc3luYyhtZXNzYWdlOiBSUENTZW5kYWJsZU1lc3NhZ2UsIGNhbGxiYWNrOiAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAudGhlbigoeDogYW55KSA9PiBjYWxsYmFjayhudWxsLCB4KSlcbiAgICAgICAgICAuY2F0Y2goY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBhcyB7XG4gICAgICBzZW5kOiBGdW5jdGlvblxuICAgICAgc2VuZEFzeW5jOiBGdW5jdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBhc3luYyBzeXN0ZW1EaWRFbmFibGUoKSB7XG4gICAgdGhpcy5wcm9wcyA9IChhd2FpdCB0aGlzLmVudGl0eUNvbnRyb2xsZXIuZ2V0T3duQXR0cmlidXRlcygpKSBhcyBQcm9wc1xuXG4gICAgLy8gd2UgY3JlYXRlIGFuIGV2ZW50IHN1YnNjcmliZXJcbiAgICB0aGlzLmV2ZW50U3Vic2NyaWJlciA9IG5ldyBFdmVudFN1YnNjcmliZXIodGhpcy5lbnRpdHlDb250cm9sbGVyKVxuXG4gICAgdGhpcy5vbignU0lHS0lMTCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjZW5lV2lsbFVubW91bnQpIHtcbiAgICAgICAgdGhpcy5zY2VuZVdpbGxVbm1vdW50KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5zdWJzY3JpYmVUbygnc2V0QXR0cmlidXRlcycsIG5ld1Byb3BzID0+IHtcbiAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wc1xuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzIGFzIFByb3BzXG4gICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpXG4gICAgfSlcblxuICAgIHRoaXMuY29ubmVjdGlvbkZ1dHVyZS5yZXNvbHZlKHRoaXMpXG5cbiAgICByZW5kZXJTY3JpcHRhYmxlU2NlbmUodGhpcywgdHJ1ZSlcblxuICAgIHRoaXMuZXZlbnRTdWJzY3JpYmVyLm9uKCd1dWlkRXZlbnQnLCB0aGlzLnJlY2VpdmVVdWlkRXZlbnQpXG5cbiAgICBpZiAodGhpcy5zY2VuZURpZE1vdW50KSB7XG4gICAgICBhd2FpdCB0aGlzLnNjZW5lRGlkTW91bnQoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVjZWl2ZVV1aWRFdmVudCA9IChldmVudDogYW55KSA9PiB7XG4gICAgY29uc3QgbWFwOiBNYXA8c3RyaW5nLCBGdW5jdGlvbj4gPSB0aGlzLl9mdW5jdGlvbk1hcFxuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IGZuID0gbWFwLmdldChldmVudC5kYXRhLnV1aWQpXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZXZlbnQuZGF0YS5wYXlsb2FkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/ScriptableScene.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/decentraland-api/lib/events.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createEvent(event, data) {\n    return { event, data };\n}\nexports.createEvent = createEvent;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2V2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQWdJQSxTQUFnQixXQUFXLENBQXdCLEtBQVEsRUFBRSxJQUFnQjtJQUMzRSxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFBO0FBQ3hCLENBQUM7QUFGRCxrQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjNDb21wb25lbnQsIFF1YXRlcm5pb24gfSBmcm9tICcuL2ludGVyZmFjZXMnXG5cbmV4cG9ydCB0eXBlIFBvaW50ZXJFdmVudCA9IHtcbiAgLyoqIE9yaWdpbiBvZiB0aGUgcmF5ICovXG4gIGZyb206IFZlY3RvcjNDb21wb25lbnRcbiAgLyoqIERpcmVjdGlvbiB2ZWN0b3Igb2YgdGhlIHJheSAobm9ybWFsaXplZCkgKi9cbiAgZGlyZWN0aW9uOiBWZWN0b3IzQ29tcG9uZW50XG4gIC8qKiBMZW5ndGggb2YgdGhlIHJheSAqL1xuICBsZW5ndGg6IG51bWJlclxuICAvKiogSUQgb2YgdGhlIHBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50ICovXG4gIHBvaW50ZXJJZDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50cyB7XG4gIC8qKlxuICAgKiBgcG9zaXRpb25DaGFuZ2VkYCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAqIFRoaXMgZXZlbnQgaXMgdGhyb3R0bGVkIHRvIDEwIHRpbWVzIHBlciBzZWNvbmQuXG4gICAqL1xuICBwb3NpdGlvbkNoYW5nZWQ6IHtcbiAgICAvKiogUG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJhc2UgcGFyY2VsIG9mIHRoZSBzY2VuZSAqL1xuICAgIHBvc2l0aW9uOiBWZWN0b3IzQ29tcG9uZW50XG5cbiAgICAvKiogQ2FtZXJhIHBvc2l0aW9uLCB0aGlzIGlzIGEgYWJzb2x1dGUgd29ybGQgcG9zaXRpb24gKi9cbiAgICBjYW1lcmFQb3NpdGlvbjogVmVjdG9yM0NvbXBvbmVudFxuXG4gICAgLyoqIEV5ZSBoZWlnaHQsIGluIG1ldGVycy4gKi9cbiAgICBwbGF5ZXJIZWlnaHQ6IG51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIGByb3RhdGlvbkNoYW5nZWRgIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSByb3RhdGlvbiBvZiB0aGUgY2FtZXJhIGNoYW5nZXMuXG4gICAqIFRoaXMgZXZlbnQgaXMgdGhyb3R0bGVkIHRvIDEwIHRpbWVzIHBlciBzZWNvbmQuXG4gICAqL1xuICByb3RhdGlvbkNoYW5nZWQ6IHtcbiAgICAvKioge1gsWSxafSBEZWdyZWUgdmVjdG9yLiBTYW1lIGFzIGVudGl0aWVzICovXG4gICAgcm90YXRpb246IFZlY3RvcjNDb21wb25lbnRcbiAgICAvKiogUm90YXRpb24gcXVhdGVybmlvbiwgdXNlZnVsIGluIHNvbWUgc2NlbmFyaW9zLiAqL1xuICAgIHF1YXRlcm5pb246IFF1YXRlcm5pb25cbiAgfVxuXG4gIC8qKlxuICAgKiBgc2V0QXR0cmlidXRlc2AgaXMgdHJpZ2dlcmVkIGFmdGVyIHRoZSBzeXN0ZW0gcmVjZWl2ZXMgbmV3IHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXRBdHRyaWJ1dGVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG4gIH1cblxuICAvKipcbiAgICogYGNsaWNrYCBpcyB0cmlnZ2VyZWQgd2hlbiBhIHVzZXIgcG9pbnRzIGFuZCB0aGUgcmF5IChmcm9tIG1vdXNlIG9yIGNvbnRyb2xsZXIpIGhpdHMgdGhlIGVudGl0eS5cbiAgICogTm90aWNlOiBPbmx5IGVudGl0aWVzIHdpdGggSUQgd2lsbCBiZSBsaXN0ZW5pbmcgZm9yIGNsaWNrIGV2ZW50cy5cbiAgICovXG4gIGNsaWNrOiB7XG4gICAgLyoqIElEIG9mIHRoZSBlbnRpdGl5IG9mIHRoZSBldmVudCAqL1xuICAgIGVsZW1lbnRJZDogc3RyaW5nXG5cbiAgICAvKiogSUQgb2YgdGhlIHBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50ICovXG4gICAgcG9pbnRlcklkOiBudW1iZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBgcG9pbnRlclVwYCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhbiBpbnB1dCBwb2ludGVyLlxuICAgKiBJdCBjb3VsZCBiZSBhIFZSIGNvbnRyb2xsZXIsIGEgdG91Y2ggc2NyZWVuIG9yIHRoZSBtb3VzZS5cbiAgICovXG4gIHBvaW50ZXJVcDogUG9pbnRlckV2ZW50XG5cbiAgLyoqXG4gICAqIGBwb2ludGVyRG93bmAgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3MgYW4gaW5wdXQgcG9pbnRlci5cbiAgICogSXQgY291bGQgYmUgYSBWUiBjb250cm9sbGVyLCBhIHRvdWNoIHNjcmVlbiBvciB0aGUgbW91c2UuXG4gICAqL1xuICBwb2ludGVyRG93bjogUG9pbnRlckV2ZW50XG5cbiAgLyoqXG4gICAqIGBjaGFuZ2VkYCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBlbnRpdHkgY2hhbmdlcyBpdHMgb3duIGludGVybmFsIHN0YXRlLlxuICAgKiBEaXNwYXRjaGVkIGJ5IHRoZSBgaW5wdXQtdGV4dGAgZW50aXR5IHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqL1xuICBjaGFuZ2VkOiB7XG4gICAgZWxlbWVudElkOiBzdHJpbmdcbiAgICB2YWx1ZTogYW55XG4gIH1cblxuICAvKipcbiAgICogYG9uQ2hhbmdlZGAgaXMgdHJpZ2dlcmVkIHdoZW4gYW4gZW50aXR5IGNoYW5nZXMgaXRzIG93biBpbnRlcm5hbCBzdGF0ZS5cbiAgICogRGlzcGF0Y2hlZCBieSB0aGUgYHVpLSpgIGVudGl0aWVzIHdoZW4gdGhlaXIgdmFsdWUgaXMgY2hhbmdlZC4gSXQgdHJpZ2dlcnMgYSBjYWxsYmFjay5cbiAgICogTm90aWNlOiBPbmx5IGVudGl0aWVzIHdpdGggSUQgd2lsbCBiZSBsaXN0ZW5pbmcgZm9yIGNsaWNrIGV2ZW50cy5cbiAgICovXG4gIG9uQ2hhbmdlZDoge1xuICAgIC8qKiBJRCBvZiB0aGUgZW50aXRpeSBvZiB0aGUgZXZlbnQgKi9cbiAgICBlbGVtZW50SWQ6IHN0cmluZ1xuICAgIC8qKiBJRCBvZiB0aGUgcG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQgKi9cbiAgICBwb2ludGVySWQ6IG51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIGBvbkZvY3VzYCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBlbnRpdHkgZm9jdXMgaXMgYWN0aXZlLlxuICAgKiBEaXNwYXRjaGVkIGJ5IHRoZSBgdWktaW5wdXRgIGFuZCBgdWktcGFzc3dvcmRgIGVudGl0aWVzIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEl0IHRyaWdnZXJzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIE5vdGljZTogT25seSBlbnRpdGllcyB3aXRoIElEIHdpbGwgYmUgbGlzdGVuaW5nIGZvciBjbGljayBldmVudHMuXG4gICAqL1xuICBvbkZvY3VzOiB7XG4gICAgLyoqIElEIG9mIHRoZSBlbnRpdGl5IG9mIHRoZSBldmVudCAqL1xuICAgIGVsZW1lbnRJZDogc3RyaW5nXG4gICAgLyoqIElEIG9mIHRoZSBwb2ludGVyIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudCAqL1xuICAgIHBvaW50ZXJJZDogbnVtYmVyXG4gIH1cblxuICAvKipcbiAgICogYG9uQmx1cmAgaXMgdHJpZ2dlcmVkIHdoZW4gYW4gZW50aXR5IGxvc2VzIGl0cyBmb2N1cy5cbiAgICogRGlzcGF0Y2hlZCBieSB0aGUgYHVpLWlucHV0YCBhbmQgYHVpLXBhc3N3b3JkYCBlbnRpdGllcyB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKiAgSXQgdHJpZ2dlcnMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogTm90aWNlOiBPbmx5IGVudGl0aWVzIHdpdGggSUQgd2lsbCBiZSBsaXN0ZW5pbmcgZm9yIGNsaWNrIGV2ZW50cy5cbiAgICovXG4gIG9uQmx1cjoge1xuICAgIC8qKiBJRCBvZiB0aGUgZW50aXRpeSBvZiB0aGUgZXZlbnQgKi9cbiAgICBlbGVtZW50SWQ6IHN0cmluZ1xuICAgIC8qKiBJRCBvZiB0aGUgcG9pbnRlciB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQgKi9cbiAgICBwb2ludGVySWQ6IG51bWJlclxuICB9XG59XG5cbmV4cG9ydCB0eXBlIElFdmVudE5hbWVzID0ga2V5b2YgSUV2ZW50c1xuXG5leHBvcnQgdHlwZSBSUENFdmVudDxLIGV4dGVuZHMgSUV2ZW50TmFtZXMsIEQgPSBhbnk+ID0ge1xuICBldmVudDogS1xuICBkYXRhOiBEXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudDxUIGV4dGVuZHMgSUV2ZW50TmFtZXM+KGV2ZW50OiBULCBkYXRhOiBJRXZlbnRzW1RdKTogUlBDRXZlbnQ8VCwgSUV2ZW50c1tUXT4ge1xuICByZXR1cm4geyBldmVudCwgZGF0YSB9XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/events.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/handlers.js":
/*!*******************************************************!*\
  !*** ./node_modules/decentraland-api/lib/handlers.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createUUID() {\n    const s = [];\n    const hexDigits = '0123456789abcdef';\n    for (let i = 0; i < 36; i++) {\n        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n    }\n    s[14] = '4';\n    s[19] = hexDigits.substr((parseInt(s[19], 10) & 0x3) | 0x8, 1);\n    s[8] = s[13] = s[18] = s[23] = '-';\n    let uuid = s.join('');\n    return uuid;\n}\n// This symbol is used to store an ID in the function\nconst idSymbol = Symbol('id');\nfunction putHandler(fn) {\n    if (fn[idSymbol]) {\n        const id = fn[idSymbol];\n        if (id) {\n            return id;\n        }\n    }\n    const id = createUUID();\n    fn[idSymbol] = id;\n    return id;\n}\nexports.putHandler = putHandler;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaGFuZGxlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxTQUFTLFVBQVU7SUFDakIsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFBO0lBQ1osTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUE7SUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUM3RDtJQUNELENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUE7SUFDWCxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUE7SUFFbEMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQTtJQUNyQixPQUFPLElBQUksQ0FBQTtBQUNiLENBQUM7QUFFRCxxREFBcUQ7QUFDckQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBRTdCLFNBQWdCLFVBQVUsQ0FBQyxFQUFPO0lBQ2hDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ2hCLE1BQU0sRUFBRSxHQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUMvQixJQUFJLEVBQUUsRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFBO1NBQ1Y7S0FDRjtJQUVELE1BQU0sRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFBO0lBRXZCLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUE7SUFFakIsT0FBTyxFQUFFLENBQUE7QUFDWCxDQUFDO0FBYkQsZ0NBYUMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcmVhdGVVVUlEKCk6IHN0cmluZyB7XG4gIGNvbnN0IHMgPSBbXVxuICBjb25zdCBoZXhEaWdpdHMgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgc1tpXSA9IGhleERpZ2l0cy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMCksIDEpXG4gIH1cbiAgc1sxNF0gPSAnNCdcbiAgc1sxOV0gPSBoZXhEaWdpdHMuc3Vic3RyKChwYXJzZUludChzWzE5XSwgMTApICYgMHgzKSB8IDB4OCwgMSlcbiAgc1s4XSA9IHNbMTNdID0gc1sxOF0gPSBzWzIzXSA9ICctJ1xuXG4gIGxldCB1dWlkID0gcy5qb2luKCcnKVxuICByZXR1cm4gdXVpZFxufVxuXG4vLyBUaGlzIHN5bWJvbCBpcyB1c2VkIHRvIHN0b3JlIGFuIElEIGluIHRoZSBmdW5jdGlvblxuY29uc3QgaWRTeW1ib2wgPSBTeW1ib2woJ2lkJylcblxuZXhwb3J0IGZ1bmN0aW9uIHB1dEhhbmRsZXIoZm46IGFueSk6IHN0cmluZyB7XG4gIGlmIChmbltpZFN5bWJvbF0pIHtcbiAgICBjb25zdCBpZDogc3RyaW5nID0gZm5baWRTeW1ib2xdXG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gaWRcbiAgICB9XG4gIH1cblxuICBjb25zdCBpZCA9IGNyZWF0ZVVVSUQoKVxuXG4gIGZuW2lkU3ltYm9sXSA9IGlkXG5cbiAgcmV0dXJuIGlkXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/handlers.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decentraland-api/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! decentraland-rpc */ \"./node_modules/decentraland-rpc/lib/client/index.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/transports/WebSocket */ \"./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\"));\n__export(__webpack_require__(/*! ./interfaces */ \"./node_modules/decentraland-api/lib/interfaces.js\"));\n__export(__webpack_require__(/*! ./events */ \"./node_modules/decentraland-api/lib/events.js\"));\n__export(__webpack_require__(/*! ./MessageBus */ \"./node_modules/decentraland-api/lib/MessageBus.js\"));\nconst ScriptableScene_1 = __webpack_require__(/*! ./ScriptableScene */ \"./node_modules/decentraland-api/lib/ScriptableScene.js\");\nexports.ScriptableScene = ScriptableScene_1.ScriptableScene;\nconst createElement_1 = __webpack_require__(/*! ./internal/createElement */ \"./node_modules/decentraland-api/lib/internal/createElement.js\");\nexports.createElement = createElement_1.createElement;\nif (typeof global !== 'undefined') {\n    global['createElement'] = global['createElement'] || createElement_1.createElement;\n}\nelse if (typeof window !== 'undefined') {\n    // tslint:disable-next-line:semicolon\n    window['createElement'] = window['createElement'] || createElement_1.createElement;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQ0FBZ0M7QUFDaEMsc0VBQWdFO0FBQ2hFLHNFQUFnRTtBQUNoRSxzRUFBZ0U7QUFDaEUsa0NBQTRCO0FBQzVCLDhCQUF3QjtBQUd4QixrQ0FBNEI7QUFFNUIsdURBQW1EO0FBRzNCLDBCQUhmLGlDQUFlLENBR2U7QUFGdkMsNERBQXdEO0FBRS9DLHdCQUZBLDZCQUFhLENBRUE7QUFLdEIsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7SUFDakMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSw2QkFBYSxDQUFBO0NBQ25FO0tBQU0sSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7SUFDeEMscUNBQXFDO0lBQ3JDLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksNkJBQWEsQ0FBQTtDQUNuRSIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJ2RlY2VudHJhbGFuZC1ycGMnXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vdHJhbnNwb3J0cy9XZWJXb3JrZXInXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vdHJhbnNwb3J0cy9XZWJTb2NrZXQnXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZXMnXG5leHBvcnQgKiBmcm9tICcuL2V2ZW50cydcbmV4cG9ydCAqIGZyb20gJy4vSlNYJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGlzJ1xuZXhwb3J0ICogZnJvbSAnLi9NZXNzYWdlQnVzJ1xuXG5pbXBvcnQgeyBTY3JpcHRhYmxlU2NlbmUgfSBmcm9tICcuL1NjcmlwdGFibGVTY2VuZSdcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL2ludGVybmFsL2NyZWF0ZUVsZW1lbnQnXG5cbmV4cG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFNjcmlwdGFibGVTY2VuZSB9XG5cbmRlY2xhcmUgdmFyIGdsb2JhbDogYW55XG5kZWNsYXJlIHZhciB3aW5kb3c6IGFueVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsWydjcmVhdGVFbGVtZW50J10gPSBnbG9iYWxbJ2NyZWF0ZUVsZW1lbnQnXSB8fCBjcmVhdGVFbGVtZW50XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzZW1pY29sb25cbiAgd2luZG93WydjcmVhdGVFbGVtZW50J10gPSB3aW5kb3dbJ2NyZWF0ZUVsZW1lbnQnXSB8fCBjcmVhdGVFbGVtZW50XG59XG4iXX0=\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/interfaces.js":
/*!*********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/interfaces.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BillboardModes = {\n    BILLBOARDMODE_NONE: 0,\n    BILLBOARDMODE_X: 1,\n    BILLBOARDMODE_Y: 2,\n    BILLBOARDMODE_Z: 4,\n    BILLBOARDMODE_ALL: 7\n};\nexports.TextureSamplingMode = {\n    NEAREST: 1,\n    BILINEAR: 2,\n    TRILINEAR: 3\n};\nexports.TextureWrapping = {\n    CLAMP: 0,\n    WRAP: 1,\n    MIRROR: 2\n};\nexports.TransparencyModes = {\n    OPAQUE: 0,\n    ALPHATEST: 1,\n    ALPHABLEND: 2,\n    ALPHATESTANDBLEND: 3\n};\nvar Constants;\n(function (Constants) {\n    // DO NOT EVER CHANGE THESE VALUES\n    Constants.ReplaceWholeTreeException = 'ReplaceWholeTreeException';\n})(Constants = exports.Constants || (exports.Constants = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnRlcmZhY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBcUJhLFFBQUEsY0FBYyxHQUFHO0lBQzVCLGtCQUFrQixFQUFFLENBQUM7SUFDckIsZUFBZSxFQUFFLENBQUM7SUFDbEIsZUFBZSxFQUFFLENBQUM7SUFDbEIsZUFBZSxFQUFFLENBQUM7SUFDbEIsaUJBQWlCLEVBQUUsQ0FBQztDQUNyQixDQUFBO0FBRVksUUFBQSxtQkFBbUIsR0FBRztJQUNqQyxPQUFPLEVBQUUsQ0FBQztJQUNWLFFBQVEsRUFBRSxDQUFDO0lBQ1gsU0FBUyxFQUFFLENBQUM7Q0FDYixDQUFBO0FBRVksUUFBQSxlQUFlLEdBQUc7SUFDN0IsS0FBSyxFQUFFLENBQUM7SUFDUixJQUFJLEVBQUUsQ0FBQztJQUNQLE1BQU0sRUFBRSxDQUFDO0NBQ1YsQ0FBQTtBQUlZLFFBQUEsaUJBQWlCLEdBQUc7SUFDL0IsTUFBTSxFQUFFLENBQUM7SUFDVCxTQUFTLEVBQUUsQ0FBQztJQUNaLFVBQVUsRUFBRSxDQUFDO0lBQ2IsaUJBQWlCLEVBQUUsQ0FBQztDQUNyQixDQUFBO0FBbUpELElBQWlCLFNBQVMsQ0FJekI7QUFKRCxXQUFpQixTQUFTO0lBQ3hCLGtDQUFrQztJQUVyQixtQ0FBeUIsR0FBRywyQkFBMkIsQ0FBQTtBQUN0RSxDQUFDLEVBSmdCLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBSXpCIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSUVudGl0eSB9IGZyb20gJy4vaW50ZXJuYWwvYXBwbHlQYXRjaCdcblxuZXhwb3J0IGludGVyZmFjZSBJU2ltcGxpZmllZE5vZGUge1xuICB0YWc6IHN0cmluZ1xuICBjaGlsZHJlbjogSVNpbXBsaWZpZWROb2RlW11cbiAgYXR0cnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcltdIHwgb2JqZWN0IHwgYm9vbGVhbiB8IG51bWJlciB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbnRpdHkge1xuICBnZXRVc2VyUHVibGljS2V5KCk6IFByb21pc2U8c3RyaW5nPlxufVxuXG5leHBvcnQgdHlwZSBMYW5kRGF0YVZlcnNpb24wID0ge1xuICB2ZXJzaW9uOiAwXG4gIG5hbWU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGlwbnM6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBMYW5kRGF0YSA9IExhbmREYXRhVmVyc2lvbjBcblxuZXhwb3J0IGNvbnN0IEJpbGxib2FyZE1vZGVzID0ge1xuICBCSUxMQk9BUkRNT0RFX05PTkU6IDAsXG4gIEJJTExCT0FSRE1PREVfWDogMSxcbiAgQklMTEJPQVJETU9ERV9ZOiAyLFxuICBCSUxMQk9BUkRNT0RFX1o6IDQsXG4gIEJJTExCT0FSRE1PREVfQUxMOiA3XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0dXJlU2FtcGxpbmdNb2RlID0ge1xuICBORUFSRVNUOiAxLFxuICBCSUxJTkVBUjogMixcbiAgVFJJTElORUFSOiAzXG59XG5cbmV4cG9ydCBjb25zdCBUZXh0dXJlV3JhcHBpbmcgPSB7XG4gIENMQU1QOiAwLFxuICBXUkFQOiAxLFxuICBNSVJST1I6IDJcbn1cblxuZXhwb3J0IHR5cGUgSUJpbGxib2FyZE1vZGVzID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDdcblxuZXhwb3J0IGNvbnN0IFRyYW5zcGFyZW5jeU1vZGVzID0ge1xuICBPUEFRVUU6IDAsXG4gIEFMUEhBVEVTVDogMSxcbiAgQUxQSEFCTEVORDogMixcbiAgQUxQSEFURVNUQU5EQkxFTkQ6IDNcbn1cblxuZXhwb3J0IHR5cGUgSVRyYW5zcGFyZW5jeU1vZGVzID0gMCB8IDEgfCAyIHwgM1xuXG5leHBvcnQgaW50ZXJmYWNlIEFQSUxhbmQge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG4gIGRpc3RyaWN0X2lkPzogc3RyaW5nXG4gIG93bmVyOiBzdHJpbmdcbiAgZGF0YTogTGFuZERhdGFcbiAgaW5fZXN0YXRlPzogYm9vbGVhblxuICBsYXN0X3RyYW5zZmVycmVkX2F0Pzogc3RyaW5nXG59XG5cbi8vLyBodHRwczovL2dpdGh1Yi5jb20vZGVjZW50cmFsYW5kL3Byb3Bvc2Fscy9ibG9iL21hc3Rlci9kc3AvMDAyMC5tZWRpYXdpa2lcbmV4cG9ydCBpbnRlcmZhY2UgSVNjZW5lIHtcbiAgYXNzZXRzPzogUmVjb3JkPGFueSwgc3RyaW5nPlxuICBvd25lcjogc3RyaW5nXG4gIG1haW46IHN0cmluZ1xuICBzY2VuZToge1xuICAgIGJhc2U6IHN0cmluZ1xuICAgIHBhcmNlbHM6IHN0cmluZ1tdXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTGFuZCBleHRlbmRzIEFQSUxhbmQge1xuICBzY2VuZTogSVNjZW5lXG4gIGJhc2VVcmw6IHN0cmluZ1xuICAvLyBIVE1MIGlzIHVzZWQgYnkgdGhlIHByZXZpZXcgbG9hZGVyIHRvIHBhcnNlIHNjZW5lIGRhdGEgZGlyZWN0bHlcbiAgLy8gdG8gc3RhdGljUGFyY2VsLlxuICBodG1sPzogc3RyaW5nXG4gIHR5cGU/OiAncm9hZCcgfCAnbGFuZCcgfCAncGxhemEnXG59XG5cbi8qKlxuICogVGhpcyBkYXRhIHR5cGUgZGVmaW5lcyBhIHR3byBjb21wb25lbnQgdmVjdG9yLlxuICovXG5leHBvcnQgdHlwZSBWZWN0b3IyQ29tcG9uZW50ID0ge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG59XG5cbi8qKlxuICogVGhpcyBkYXRhIHR5cGUgZGVmaW5lcyBhIHRocmVlIGNvbXBvbmVudCB2ZWN0b3IuIEl0IGlzIHVzZWQgZm9yIHNjYWxpbmcsIHBvc2l0aW9uaW5nIGFuZCByb3RhdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgVmVjdG9yM0NvbXBvbmVudCA9IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB6OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUXVhdGVybmlvbiA9IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB6OiBudW1iZXJcbiAgdzogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFNvdW5kQ29tcG9uZW50ID0ge1xuICAvKiogRGlzdGFuY2UgZmFkaW5nIG1vZGVsLCBkZWZhdWx0OiAnbGluZWFyJyAqL1xuICBkaXN0YW5jZU1vZGVsPzogJ2xpbmVhcicgfCAnaW52ZXJzZScgfCAnZXhwb25lbnRpYWwnXG4gIC8qKiBEb2VzIHRoZSBzb3VuZCBsb29wPyBkZWZhdWx0OiBmYWxzZSAqL1xuICBsb29wPzogYm9vbGVhblxuICAvKiogVGhlIHNyYyBvZiB0aGUgc291bmQgdG8gYmUgcGxheWVkICovXG4gIHNyYzogc3RyaW5nXG4gIC8qKiBWb2x1bWUgb2YgdGhlIHNvdW5kLCB2YWx1ZXMgMCB0byAxLCBkZWZhdWx0OiAxICovXG4gIHZvbHVtZT86IG51bWJlclxuICAvKiogVXNlZCBpbiBpbnZlcnNlIGFuZCBleHBvbmVudGlhbCBkaXN0YW5jZSBtb2RlbHMsIGRlZmF1bHQ6IDEgKi9cbiAgcm9sbG9mZkZhY3Rvcj86IG51bWJlclxuICAvKiogSXMgdGhlIHNvdW5kIHBsYXlpbmc/LCBkZWZhdWx0OiB0cnVlICovXG4gIHBsYXlpbmc/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFRyYW5zaXRpb25WYWx1ZSA9IHtcbiAgZHVyYXRpb246IG51bWJlclxuICB0aW1pbmc/OiBUaW1pbmdGdW5jdGlvblxuICBkZWxheT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBUaW1pbmdGdW5jdGlvbiA9XG4gIHwgJ2xpbmVhcidcbiAgfCAnZWFzZS1pbidcbiAgfCAnZWFzZS1vdXQnXG4gIHwgJ2Vhc2UtaW4tb3V0J1xuICB8ICdxdWFkcmF0aWMtaW4nXG4gIHwgJ3F1YWRyYXRpYy1vdXQnXG4gIHwgJ3F1YWRyYXRpYy1pbm91dCdcbiAgfCAnY3ViaWMtaW4nXG4gIHwgJ2N1YmljLW91dCdcbiAgfCAnY3ViaWMtaW5vdXQnXG4gIHwgJ3F1YXJ0aWMtaW4nXG4gIHwgJ3F1YXJ0aWMtb3V0J1xuICB8ICdxdWFydGljLWlub3V0J1xuICB8ICdxdWludGljLWluJ1xuICB8ICdxdWludGljLW91dCdcbiAgfCAncXVpbnRpYy1pbm91dCdcbiAgfCAnc2luLWluJ1xuICB8ICdzaW4tb3V0J1xuICB8ICdzaW4taW5vdXQnXG4gIHwgJ2V4cG9uZW50aWFsLWluJ1xuICB8ICdleHBvbmVudGlhbC1vdXQnXG4gIHwgJ2V4cG9uZW50aWFsLWlub3V0J1xuICB8ICdib3VuY2UtaW4nXG4gIHwgJ2JvdW5jZS1vdXQnXG4gIHwgJ2JvdW5jZS1pbm91dCdcbiAgfCAnZWxhc3RpYy1pbidcbiAgfCAnZWxhc3RpYy1vdXQnXG4gIHwgJ2VsYXN0aWMtaW5vdXQnXG4gIHwgJ2NpcmN1bGFyLWluJ1xuICB8ICdjaXJjdWxhci1vdXQnXG4gIHwgJ2NpcmN1bGFyLWlub3V0J1xuICB8ICdiYWNrLWluJ1xuICB8ICdiYWNrLW91dCdcbiAgfCAnYmFjay1pbm91dCdcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbkNvbXBvbmVudCA9IHtcbiAgcG9zaXRpb24/OiBUcmFuc2l0aW9uVmFsdWVcbiAgcm90YXRpb24/OiBUcmFuc2l0aW9uVmFsdWVcbiAgc2NhbGU/OiBUcmFuc2l0aW9uVmFsdWVcbiAgY29sb3I/OiBUcmFuc2l0aW9uVmFsdWVcbiAgbG9va0F0PzogVHJhbnNpdGlvblZhbHVlXG59XG5cbmV4cG9ydCB0eXBlIFNrZWxldGFsQW5pbWF0aW9uVmFsdWUgPSB7XG4gIC8qKlxuICAgKiBOYW1lIG9yIGluZGV4IG9mIHRoZSBhbmltYXRpb24gaW4gdGhlIG1vZGVsXG4gICAqL1xuICBjbGlwOiBzdHJpbmcgfCBudW1iZXJcblxuICAvKipcbiAgICogRG9lcyB0aGUgYW5pbWF0aW9uIGxvb3A/LCBkZWZhdWx0OiB0cnVlXG4gICAqL1xuICBsb29wPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXZWlnaHQgb2YgdGhlIGFuaW1hdGlvbiwgdmFsdWVzIGZyb20gMCB0byAxLCB1c2VkIHRvIGJsZW5kIHNldmVyYWwgYW5pbWF0aW9ucy4gZGVmYXVsdDogMVxuICAgKi9cbiAgd2VpZ2h0PzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIElzIHRoZSBhbmltYXRpb24gcGxheWluZz8gZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgcGxheWluZz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU2tlbGV0YWxBbmltYXRpb25Db21wb25lbnQgPSBTa2VsZXRhbEFuaW1hdGlvblZhbHVlW11cblxuZXhwb3J0IG5hbWVzcGFjZSBDb25zdGFudHMge1xuICAvLyBETyBOT1QgRVZFUiBDSEFOR0UgVEhFU0UgVkFMVUVTXG5cbiAgZXhwb3J0IGNvbnN0IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gPSAnUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbidcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/interfaces.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/Diff.js":
/*!************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/Diff.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Diff {\n    toString() {\n        return JSON.stringify(this);\n    }\n    setValue(aKey, aValue) {\n        // tslint:disable-next-line:semicolon\n        ;\n        this[aKey] = aValue;\n        return this;\n    }\n}\nexports.Diff = Diff;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGlmZi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9EaWZmLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsTUFBYSxJQUFJO0lBQ2YsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUM3QixDQUFDO0lBRUQsUUFBUSxDQUFDLElBQXFCLEVBQUUsTUFBVztRQUN6QyxxQ0FBcUM7UUFDckMsQ0FBQztRQUFDLElBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUE7UUFDN0IsT0FBTyxJQUFJLENBQUE7SUFDYixDQUFDO0NBQ0Y7QUFWRCxvQkFVQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElEaWZmIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIERpZmYgaW1wbGVtZW50cyBJRGlmZiB7XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKVxuICB9XG5cbiAgc2V0VmFsdWUoYUtleTogc3RyaW5nIHwgbnVtYmVyLCBhVmFsdWU6IGFueSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzZW1pY29sb25cbiAgICA7KHRoaXMgYXMgYW55KVthS2V5XSA9IGFWYWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/Diff.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/ReplaceWholeTreeException.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/ReplaceWholeTreeException.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst __1 = __webpack_require__(/*! .. */ \"./node_modules/decentraland-api/lib/index.js\");\n/**\n * This exception gets fired when the client enters a desynchronization state.\n * It is also fired when it is not possible to derive a valid diff i.e. in the case of changing roots\n */\nclass ReplaceWholeTreeException extends Error {\n    constructor() {\n        super(__1.Constants.ReplaceWholeTreeException);\n    }\n}\nexports.ReplaceWholeTreeException = ReplaceWholeTreeException;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9SZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQThCO0FBRTlCOzs7R0FHRztBQUNILE1BQWEseUJBQTBCLFNBQVEsS0FBSztJQUNsRDtRQUNFLEtBQUssQ0FBQyxhQUFTLENBQUMseUJBQXlCLENBQUMsQ0FBQTtJQUM1QyxDQUFDO0NBQ0Y7QUFKRCw4REFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uJ1xuXG4vKipcbiAqIFRoaXMgZXhjZXB0aW9uIGdldHMgZmlyZWQgd2hlbiB0aGUgY2xpZW50IGVudGVycyBhIGRlc3luY2hyb25pemF0aW9uIHN0YXRlLlxuICogSXQgaXMgYWxzbyBmaXJlZCB3aGVuIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXJpdmUgYSB2YWxpZCBkaWZmIGkuZS4gaW4gdGhlIGNhc2Ugb2YgY2hhbmdpbmcgcm9vdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKENvbnN0YW50cy5SZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uKVxuICB9XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/ReplaceWholeTreeException.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/SubsetMapping.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/SubsetMapping.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SubsetMapping {\n    constructor(oldValue, newValue) {\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n        this.length = 0;\n        /* noop */\n    }\n    contains(subset) {\n        if (subset.length < this.length) {\n            return subset.newValue >= this.newValue && subset.newValue < this.newValue + this.length;\n        }\n        return false;\n    }\n    toString() {\n        return this.length + ' element subset, first mapping: old ' + this.oldValue + ' → new ' + this.newValue;\n    }\n}\nexports.SubsetMapping = SubsetMapping;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Vic2V0TWFwcGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9TdWJzZXRNYXBwaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBYSxhQUFhO0lBR3hCLFlBQW1CLFFBQWdCLEVBQVMsUUFBZ0I7UUFBekMsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUFTLGFBQVEsR0FBUixRQUFRLENBQVE7UUFGNUQsV0FBTSxHQUFXLENBQUMsQ0FBQTtRQUdoQixVQUFVO0lBQ1osQ0FBQztJQUVELFFBQVEsQ0FBQyxNQUFxQjtRQUM1QixJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMvQixPQUFPLE1BQU0sQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQTtTQUN6RjtRQUNELE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxNQUFNLEdBQUcsc0NBQXNDLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQTtJQUN6RyxDQUFDO0NBQ0Y7QUFqQkQsc0NBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFN1YnNldE1hcHBpbmcge1xuICBsZW5ndGg6IG51bWJlciA9IDBcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgb2xkVmFsdWU6IG51bWJlciwgcHVibGljIG5ld1ZhbHVlOiBudW1iZXIpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICBjb250YWlucyhzdWJzZXQ6IFN1YnNldE1hcHBpbmcpIHtcbiAgICBpZiAoc3Vic2V0Lmxlbmd0aCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3Vic2V0Lm5ld1ZhbHVlID49IHRoaXMubmV3VmFsdWUgJiYgc3Vic2V0Lm5ld1ZhbHVlIDwgdGhpcy5uZXdWYWx1ZSArIHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICsgJyBlbGVtZW50IHN1YnNldCwgZmlyc3QgbWFwcGluZzogb2xkICcgKyB0aGlzLm9sZFZhbHVlICsgJyDihpIgbmV3ICcgKyB0aGlzLm5ld1ZhbHVlXG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/SubsetMapping.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/createElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/createElement.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stack = [];\nfunction createElement(nodeName, attributes) {\n    let children = [];\n    let lastSimple = false;\n    let child;\n    let simple = false;\n    let i;\n    let nodeType;\n    // tslint:disable-next-line:space-within-parens\n    for (i = arguments.length; i-- > 2;) {\n        if (arguments[i] && typeof arguments[i] !== 'string')\n            stack.push(arguments[i]);\n    }\n    if (attributes) {\n        if (attributes.children != null) {\n            if (!stack.length)\n                stack.push(attributes.children);\n            delete attributes.children;\n        }\n    }\n    while (stack.length) {\n        // tslint:disable-next-line:no-conditional-assignment\n        if ((child = stack.pop()) && child.pop !== undefined) {\n            // tslint:disable-next-line:space-within-parens\n            for (i = child.length; i--;)\n                stack.push(child[i]);\n        }\n        else {\n            if (typeof child === 'boolean')\n                child = null;\n            nodeType = typeof nodeName;\n            // tslint:disable-next-line:no-conditional-assignment\n            if ((simple = nodeType !== 'function')) {\n                if (child == null)\n                    child = null;\n                else if (typeof child !== 'string')\n                    simple = false;\n            }\n            if (simple && lastSimple) {\n                children[children.length - 1] += child;\n            }\n            else if (child) {\n                children.push(child);\n            }\n            lastSimple = simple;\n        }\n    }\n    return {\n        tag: nodeName,\n        attrs: attributes || {},\n        children: children || []\n    };\n}\nexports.createElement = createElement;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlRWxlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9jcmVhdGVFbGVtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBR0EsTUFBTSxLQUFLLEdBQVUsRUFBRSxDQUFBO0FBMER2QixTQUFnQixhQUFhLENBQUMsUUFBMkIsRUFBRSxVQUFlO0lBQ3hFLElBQUksUUFBUSxHQUFzQixFQUFFLENBQUE7SUFDcEMsSUFBSSxVQUFVLEdBQVksS0FBSyxDQUFBO0lBQy9CLElBQUksS0FBSyxDQUFBO0lBQ1QsSUFBSSxNQUFNLEdBQVksS0FBSyxDQUFBO0lBQzNCLElBQUksQ0FBQyxDQUFBO0lBQ0wsSUFBSSxRQUFnQixDQUFBO0lBRXBCLCtDQUErQztJQUMvQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBSTtRQUNwQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRO1lBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUMvRTtJQUNELElBQUksVUFBVSxFQUFFO1FBQ2QsSUFBSSxVQUFVLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07Z0JBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7WUFDbEQsT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFBO1NBQzNCO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbkIscURBQXFEO1FBQ3JELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxTQUFTLEVBQUU7WUFDcEQsK0NBQStDO1lBQy9DLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO2dCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDbkQ7YUFBTTtZQUNMLElBQUksT0FBTyxLQUFLLEtBQUssU0FBUztnQkFBRSxLQUFLLEdBQUcsSUFBSSxDQUFBO1lBRTVDLFFBQVEsR0FBRyxPQUFPLFFBQVEsQ0FBQTtZQUUxQixxREFBcUQ7WUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLEtBQUssVUFBVSxDQUFDLEVBQUU7Z0JBQ3RDLElBQUksS0FBSyxJQUFJLElBQUk7b0JBQUUsS0FBSyxHQUFHLElBQUksQ0FBQTtxQkFDMUIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRO29CQUFFLE1BQU0sR0FBRyxLQUFLLENBQUE7YUFDbkQ7WUFFRCxJQUFJLE1BQU0sSUFBSSxVQUFVLEVBQUU7Z0JBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQTthQUN2QztpQkFBTSxJQUFJLEtBQUssRUFBRTtnQkFDaEIsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTthQUNyQjtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUE7U0FDcEI7S0FDRjtJQUVELE9BQU87UUFDTCxHQUFHLEVBQUUsUUFBUTtRQUNiLEtBQUssRUFBRSxVQUFVLElBQUksRUFBRTtRQUN2QixRQUFRLEVBQUUsUUFBUSxJQUFJLEVBQUU7S0FDekIsQ0FBQTtBQUNILENBQUM7QUFqREQsc0NBaURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NyaXB0YWJsZVNjZW5lIH0gZnJvbSAnLi4vU2NyaXB0YWJsZVNjZW5lJ1xuaW1wb3J0IHsgSVNpbXBsaWZpZWROb2RlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcydcblxuY29uc3Qgc3RhY2s6IGFueVtdID0gW11cblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q2hpbGQgPSBKU1guRWxlbWVudFxuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q2hpbGRyZW4gPSBDb21wb25lbnRDaGlsZFtdXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudEZhY3Rvcnk8UD4gPSBDb21wb25lbnRDb25zdHJ1Y3RvcjxQPiB8IEZ1bmN0aW9uYWxDb21wb25lbnQ8UD5cblxuZXhwb3J0IHR5cGUgUmVuZGVyYWJsZVByb3BzPFA+ID0gUmVhZG9ubHk8UD4gJiBSZWFkb25seTx7IGNoaWxkcmVuPzogQ29tcG9uZW50Q2hpbGRyZW4gfT5cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbmFsQ29tcG9uZW50PFByb3BzID0ge30+IHtcbiAgKHByb3BzOiBSZW5kZXJhYmxlUHJvcHM8UHJvcHM+LCBjb250ZXh0PzogYW55KTogSVNpbXBsaWZpZWROb2RlIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudENvbnN0cnVjdG9yPFByb3BzID0ge30sIFN0YXRlID0ge30+IHtcbiAgbmV3IChwcm9wczogUHJvcHMsIGNvbnRleHQ/OiBhbnkpOiBTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPlxufVxuXG4vKipcbiAqIEpTWC9oeXBlcnNjcmlwdCByZXZpdmVyLlxuICogQHNlZSBodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3hcbiAqXG4gKiBDcmVhdGVzIGEgSVNpbXBsaWZpZWROb2RlICh2aXJ0dWFsIGVudGl0eSkuIEEgdHJlZSBvZiBJU2ltcGxpZmllZE5vZGUgY2FuIGJlIHVzZWQgYXMgYSBsaWdodHdlaWdodCByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIHN0cnVjdHVyZSBvZiBhIGVudGl0eSB0cmVlLiBUaGlzIHN0cnVjdHVyZSBjYW4gYmUgcmVhbGl6ZWQgYnkgcmVjdXJzaXZlbHkgY29tcGFyaW5nIGl0IGFnYWluc3RcbiAqIHRoZSBjdXJyZW50IF9hY3R1YWxfIGVudGl0eSBzdHJ1Y3R1cmUsIGFuZCBhcHBseWluZyBvbmx5IHRoZSBkaWZmZXJlbmNlcy5cbiAqXG4gKiBgY3JlYXRlRWxlbWVudCgpYCBhY2NlcHRzIGFuIGVsZW1lbnQgbmFtZSwgYSBsaXN0IG9mIGF0dHJpYnV0ZXMvcHJvcHMsXG4gKiBhbmQgb3B0aW9uYWxseSBjaGlsZHJlbiB0byBhcHBlbmQgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGUgVGhlIGZvbGxvd2luZyBlbnRpdHkgdHJlZVxuICpcbiAqIGA8Ym94IHBvc2l0aW9uPXt7eDogMSwgeTogMiwgejogM319IC8+YFxuICpcbiAqIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyB0aGlzIGZ1bmN0aW9uIGFzOlxuICpcbiAqIGBjcmVhdGVFbGVtZW50KCdib3gnLCB7IHBvc2l0aW9uOiB7eDogMSwgeTogMiwgejogM30gfSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZVx0QW4gZW50aXR5IG5hbWUuIEV4OiBgc2NlbmVgLCBgYm94YCwgYGdsdGYtbW9kZWxgLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1x0QW55IGF0dHJpYnV0ZXMvcHJvcHMgdG8gc2V0IG9uIHRoZSBjcmVhdGVkIGVudGl0eS5cbiAqIEBwYXJhbSByZXN0IEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB0YWtlbiB0byBiZSBjaGlsZHJlbiB0byBhcHBlbmQuIENhbiBiZSBpbmZpbml0ZWx5IG5lc3RlZCBBcnJheXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50PFA+KFxuICBub2RlOiBDb21wb25lbnRGYWN0b3J5PFA+LFxuICBwYXJhbXM6IEpTWC5CYXNlRW50aXR5ICYgUCB8IG51bGwsXG4gIC4uLmNoaWxkcmVuOiAoQ29tcG9uZW50Q2hpbGQgfCBDb21wb25lbnRDaGlsZHJlbilbXVxuKTogSVNpbXBsaWZpZWROb2RlXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudDxLIGV4dGVuZHMga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzPihcbiAgbm9kZTogSyxcbiAgcGFyYW1zOiBKU1guSW50cmluc2ljRWxlbWVudHNbS10sXG4gIC4uLmNoaWxkcmVuOiAoQ29tcG9uZW50Q2hpbGQgfCBDb21wb25lbnRDaGlsZHJlbilbXVxuKTogSVNpbXBsaWZpZWROb2RlXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChcbiAgbm9kZTogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsLFxuICAuLi5jaGlsZHJlbjogKENvbXBvbmVudENoaWxkIHwgQ29tcG9uZW50Q2hpbGRyZW4pW11cbik6IElTaW1wbGlmaWVkTm9kZVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobm9kZU5hbWU6IHN0cmluZyB8IEZ1bmN0aW9uLCBhdHRyaWJ1dGVzOiBhbnkpIHtcbiAgbGV0IGNoaWxkcmVuOiBJU2ltcGxpZmllZE5vZGVbXSA9IFtdXG4gIGxldCBsYXN0U2ltcGxlOiBib29sZWFuID0gZmFsc2VcbiAgbGV0IGNoaWxkXG4gIGxldCBzaW1wbGU6IGJvb2xlYW4gPSBmYWxzZVxuICBsZXQgaVxuICBsZXQgbm9kZVR5cGU6IHN0cmluZ1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS13aXRoaW4tcGFyZW5zXG4gIGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7ICkge1xuICAgIGlmIChhcmd1bWVudHNbaV0gJiYgdHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gJ3N0cmluZycpIHN0YWNrLnB1c2goYXJndW1lbnRzW2ldKVxuICB9XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHN0YWNrLnB1c2goYXR0cmlidXRlcy5jaGlsZHJlbilcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuXG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgIGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgY2hpbGQucG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS13aXRoaW4tcGFyZW5zXG4gICAgICBmb3IgKGkgPSBjaGlsZC5sZW5ndGg7IGktLTsgKSBzdGFjay5wdXNoKGNoaWxkW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIGNoaWxkID0gbnVsbFxuXG4gICAgICBub2RlVHlwZSA9IHR5cGVvZiBub2RlTmFtZVxuXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgICAgaWYgKChzaW1wbGUgPSBub2RlVHlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIGNoaWxkID0gbnVsbFxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnKSBzaW1wbGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIHtcbiAgICAgICAgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGRcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICAgIH1cblxuICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiBub2RlTmFtZSxcbiAgICBhdHRyczogYXR0cmlidXRlcyB8fCB7fSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4gfHwgW11cbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/createElement.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/types.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This are the actions that travel thru the wire.\n * We should NEVER change this actions to honor the contract we are\n * creating and to maintain backwards compatibility.\n */\nvar Actions;\n(function (Actions) {\n    Actions[Actions[\"action\"] = 0] = \"action\";\n    Actions[Actions[\"groupLength\"] = 1] = \"groupLength\";\n    Actions[Actions[\"addAttribute\"] = 2] = \"addAttribute\";\n    Actions[Actions[\"modifyAttribute\"] = 3] = \"modifyAttribute\";\n    Actions[Actions[\"removeAttribute\"] = 4] = \"removeAttribute\";\n    Actions[Actions[\"relocateGroup\"] = 5] = \"relocateGroup\";\n    Actions[Actions[\"removeElement\"] = 6] = \"removeElement\";\n    Actions[Actions[\"addElement\"] = 7] = \"addElement\";\n    Actions[Actions[\"replaceElement\"] = 8] = \"replaceElement\";\n    Actions[Actions[\"route\"] = 9] = \"route\";\n    Actions[Actions[\"oldValue\"] = 10] = \"oldValue\";\n    Actions[Actions[\"newValue\"] = 11] = \"newValue\";\n    Actions[Actions[\"element\"] = 12] = \"element\";\n    Actions[Actions[\"group\"] = 13] = \"group\";\n    Actions[Actions[\"from\"] = 14] = \"from\";\n    Actions[Actions[\"to\"] = 15] = \"to\";\n    Actions[Actions[\"name\"] = 16] = \"name\";\n    Actions[Actions[\"data\"] = 17] = \"data\";\n    Actions[Actions[\"attrs\"] = 18] = \"attrs\";\n    Actions[Actions[\"tag\"] = 19] = \"tag\";\n    Actions[Actions[\"children\"] = 20] = \"children\";\n    Actions[Actions[\"value\"] = 21] = \"value\";\n})(Actions = exports.Actions || (exports.Actions = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFTQTs7OztHQUlHO0FBQ0gsSUFBWSxPQXVCWDtBQXZCRCxXQUFZLE9BQU87SUFDakIseUNBQVUsQ0FBQTtJQUNWLG1EQUFlLENBQUE7SUFDZixxREFBZ0IsQ0FBQTtJQUNoQiwyREFBbUIsQ0FBQTtJQUNuQiwyREFBbUIsQ0FBQTtJQUNuQix1REFBaUIsQ0FBQTtJQUNqQix1REFBaUIsQ0FBQTtJQUNqQixpREFBYyxDQUFBO0lBQ2QseURBQWtCLENBQUE7SUFDbEIsdUNBQVMsQ0FBQTtJQUNULDhDQUFhLENBQUE7SUFDYiw4Q0FBYSxDQUFBO0lBQ2IsNENBQVksQ0FBQTtJQUNaLHdDQUFVLENBQUE7SUFDVixzQ0FBUyxDQUFBO0lBQ1Qsa0NBQU8sQ0FBQTtJQUNQLHNDQUFTLENBQUE7SUFDVCxzQ0FBUyxDQUFBO0lBQ1Qsd0NBQVUsQ0FBQTtJQUNWLG9DQUFRLENBQUE7SUFDUiw4Q0FBYSxDQUFBO0lBQ2Isd0NBQVUsQ0FBQTtBQUNaLENBQUMsRUF2QlcsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBdUJsQiIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgSURpZmYge1xuICBbYWN0aW9uOiBudW1iZXJdOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaWZmUGFja2V0IHtcbiAgcHJvdG9jb2w6IDFcbiAgZGlmZjogSURpZmZbXVxufVxuXG4vKipcbiAqIFRoaXMgYXJlIHRoZSBhY3Rpb25zIHRoYXQgdHJhdmVsIHRocnUgdGhlIHdpcmUuXG4gKiBXZSBzaG91bGQgTkVWRVIgY2hhbmdlIHRoaXMgYWN0aW9ucyB0byBob25vciB0aGUgY29udHJhY3Qgd2UgYXJlXG4gKiBjcmVhdGluZyBhbmQgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvbnMge1xuICBhY3Rpb24gPSAwLFxuICBncm91cExlbmd0aCA9IDEsXG4gIGFkZEF0dHJpYnV0ZSA9IDIsXG4gIG1vZGlmeUF0dHJpYnV0ZSA9IDMsXG4gIHJlbW92ZUF0dHJpYnV0ZSA9IDQsXG4gIHJlbG9jYXRlR3JvdXAgPSA1LFxuICByZW1vdmVFbGVtZW50ID0gNixcbiAgYWRkRWxlbWVudCA9IDcsXG4gIHJlcGxhY2VFbGVtZW50ID0gOCxcbiAgcm91dGUgPSA5LFxuICBvbGRWYWx1ZSA9IDEwLFxuICBuZXdWYWx1ZSA9IDExLFxuICBlbGVtZW50ID0gMTIsXG4gIGdyb3VwID0gMTMsXG4gIGZyb20gPSAxNCxcbiAgdG8gPSAxNSxcbiAgbmFtZSA9IDE2LFxuICBkYXRhID0gMTcsXG4gIGF0dHJzID0gMTgsXG4gIHRhZyA9IDE5LFxuICBjaGlsZHJlbiA9IDIwLFxuICB2YWx1ZSA9IDIxXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/types.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/vdom.js":
/*!************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/vdom.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/decentraland-api/lib/internal/types.js\");\nconst SubsetMapping_1 = __webpack_require__(/*! ./SubsetMapping */ \"./node_modules/decentraland-api/lib/internal/SubsetMapping.js\");\nconst Diff_1 = __webpack_require__(/*! ./Diff */ \"./node_modules/decentraland-api/lib/internal/Diff.js\");\nconst ReplaceWholeTreeException_1 = __webpack_require__(/*! ./ReplaceWholeTreeException */ \"./node_modules/decentraland-api/lib/internal/ReplaceWholeTreeException.js\");\nconst deepEqual_1 = __webpack_require__(/*! ../utils/deepEqual */ \"./node_modules/decentraland-api/lib/utils/deepEqual.js\");\n// tslint:disable:no-console\nconst innerDone = Symbol('innerDone');\nconst outerDone = Symbol('outerDone');\nlet diffcount;\nlet foundAll = false;\n/** Returns the elements conaining a .tag string property */\nfunction filterHavingTag($) {\n    return typeof $.tag === 'string';\n}\n/**\n * Returns element descriptors, it is an array used to identify the given node\n */\nfunction elementDescriptors(el) {\n    let output = [];\n    output.push(el.tag);\n    if (el.attrs) {\n        if (el.attrs.key) {\n            output.push(el.tag + '.' + el.attrs.key);\n        }\n        if (el.attrs.id) {\n            output.push(el.tag + '#' + el.attrs.id);\n        }\n        if (el.attrs.src) {\n            output.push(el.tag + '%' + el.attrs.src);\n        }\n    }\n    return output;\n}\nfunction findUniqueDescriptors(list) {\n    let uniqueDescriptors = {};\n    let duplicateDescriptors = {};\n    let node;\n    let descriptors;\n    let descriptor;\n    let inUnique;\n    let inDupes;\n    for (let i = 0; i < list.length; i++) {\n        node = list[i];\n        descriptors = elementDescriptors(node);\n        for (let j = 0; j < descriptors.length; j++) {\n            descriptor = descriptors[j];\n            inUnique = descriptor in uniqueDescriptors;\n            inDupes = descriptor in duplicateDescriptors;\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true;\n            }\n            else if (inUnique) {\n                delete uniqueDescriptors[descriptor];\n                duplicateDescriptors[descriptor] = true;\n            }\n        }\n    }\n    return uniqueDescriptors;\n}\nfunction uniqueInBoth(l1, l2) {\n    let l1Unique = findUniqueDescriptors(l1);\n    let l2Unique = findUniqueDescriptors(l2);\n    let inBoth = {};\n    let keys = Object.keys(l1Unique);\n    let length = keys.length;\n    let key;\n    for (let i = 0; i < length; i++) {\n        key = keys[i];\n        if (l2Unique[key]) {\n            inBoth[key] = true;\n        }\n    }\n    return inBoth;\n}\nfunction removeDone(tree) {\n    // @ts-ignore\n    delete tree[outerDone];\n    // @ts-ignore\n    delete tree[innerDone];\n    if (tree.children) {\n        return tree.children.every(removeDone);\n    }\n    else {\n        return true;\n    }\n}\nfunction isEqual(e1, e2) {\n    let e1Attributes;\n    let e2Attributes;\n    if (!['tag'].every(function (element) {\n        if (e1[element] !== e2[element]) {\n            return false;\n        }\n        return true;\n    })) {\n        return false;\n    }\n    if (Boolean(e1.attrs) !== Boolean(e2.attrs)) {\n        return false;\n    }\n    if (Boolean(e1.children) !== Boolean(e2.children)) {\n        return false;\n    }\n    if (e1.attrs) {\n        e1Attributes = Object.keys(e1.attrs);\n        e2Attributes = Object.keys(e2.attrs);\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false;\n        }\n        if (!e1Attributes.every(function (attribute) {\n            if (!deepEqual_1.deepEqual(e1.attrs[attribute], e2.attrs[attribute])) {\n                return false;\n            }\n            return true;\n        })) {\n            return false;\n        }\n    }\n    if (e1.children) {\n        if (e1.children.filter(filterHavingTag).length !== e2.children.filter(filterHavingTag).length) {\n            return false;\n        }\n        if (!e1.children.filter(filterHavingTag).every(function (childNode, index) {\n            return isEqual(childNode, e2.children.filter(filterHavingTag)[index]);\n        })) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion = false) {\n    let childUniqueDescriptors;\n    let nodeList1;\n    let nodeList2;\n    if (!e1 || !e2) {\n        return false;\n    }\n    if (e1.tag !== e2.tag) {\n        return false;\n    }\n    if (e1.tag in uniqueDescriptors) {\n        return true;\n    }\n    if (e1.attrs && e2.attrs) {\n        if (e1.attrs.id) {\n            if (e1.attrs.id !== e2.attrs.id) {\n                return false;\n            }\n            else {\n                let idDescriptor = e1.tag + '#' + e1.attrs.id;\n                if (idDescriptor in uniqueDescriptors) {\n                    return true;\n                }\n            }\n        }\n        if (e1.attrs.key) {\n            if (e1.attrs.key !== e2.attrs.key) {\n                return false;\n            }\n            else {\n                let keyDescriptor = e1.tag + '.' + e1.attrs.key;\n                if (keyDescriptor in uniqueDescriptors) {\n                    return true;\n                }\n            }\n        }\n        if (e1.attrs.src) {\n            if (e1.attrs.src !== e2.attrs.src) {\n                return false;\n            }\n            else {\n                let keyDescriptor = e1.tag + '%' + e1.attrs.src;\n                if (keyDescriptor in uniqueDescriptors) {\n                    return true;\n                }\n            }\n        }\n    }\n    if (sameSiblings) {\n        return true;\n    }\n    nodeList1 = e1.children\n        ? e1.children\n            .slice()\n            .filter(filterHavingTag)\n            .reverse()\n        : [];\n    nodeList2 = e2.children\n        ? e2.children\n            .slice()\n            .filter(filterHavingTag)\n            .reverse()\n        : [];\n    if (nodeList1.length !== nodeList2.length) {\n        return false;\n    }\n    if (preventRecursion) {\n        return nodeList1.every(function (element, index) {\n            return element.tag === nodeList2[index].tag;\n        });\n    }\n    else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2);\n        return nodeList1.every(function (element, index) {\n            return roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true);\n        });\n    }\n}\nfunction cloneObj(obj) {\n    //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0;\n    let index = [];\n    let c1Length = c1.length;\n    let c2Length = c2.length;\n    let matches = Array.apply(null, new Array(c1Length + 1)).map(function () {\n        return [];\n    });\n    // set up the matching table\n    let uniqueDescriptors = uniqueInBoth(c1, c2);\n    // If all of the elements are the same tag, id and class, then we can\n    // consider them roughly the same even if they have a different number of\n    // children. This will reduce removing and re-adding similar elements.\n    let subsetsSame = c1Length === c2Length;\n    let origin;\n    let ret;\n    let c1Index;\n    let c2Index;\n    let c1Element;\n    let c2Element;\n    if (subsetsSame) {\n        c1.some(function (element, i) {\n            let c1Desc = elementDescriptors(element);\n            let c2Desc = elementDescriptors(c2[i]);\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false;\n                return true;\n            }\n            c1Desc.some(function (description, i) {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false;\n                    return true;\n                }\n                return false;\n            });\n            if (!subsetsSame) {\n                return true;\n            }\n            return false;\n        });\n    }\n    // fill the matches with distance values\n    for (c1Index = 0; c1Index < c1Length; c1Index++) {\n        c1Element = c1[c1Index];\n        for (c2Index = 0; c2Index < c2Length; c2Index++) {\n            c2Element = c2[c2Index];\n            if (!marked1[c1Index] &&\n                !marked2[c2Index] &&\n                roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                matches[c1Index + 1][c2Index + 1] = matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1;\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1];\n                    index = [c1Index + 1, c2Index + 1];\n                }\n            }\n            else {\n                matches[c1Index + 1][c2Index + 1] = 0;\n            }\n        }\n    }\n    if (lcsSize === 0) {\n        return undefined;\n    }\n    origin = [index[0] - lcsSize, index[1] - lcsSize];\n    ret = new SubsetMapping_1.SubsetMapping(origin[0], origin[1]);\n    ret.length = lcsSize;\n    return ret;\n}\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array.apply(null, new Array(n)).map(function () {\n        return v;\n    });\n}\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nfunction getGapInformation(t1, t2, stable) {\n    let gaps1 = t1.children\n        ? makeArray(t1.children.filter(filterHavingTag).length, true)\n        : [];\n    let gaps2 = t2.children\n        ? makeArray(t2.children.filter(filterHavingTag).length, true)\n        : [];\n    let group = 0;\n    let length = stable.length;\n    let i;\n    let j;\n    let endOld;\n    let endNew;\n    let subset;\n    // give elements from the same subset the same group number\n    for (i = 0; i < length; i++) {\n        subset = stable[i];\n        endOld = subset.oldValue + subset.length;\n        endNew = subset.newValue + subset.length;\n        for (j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group;\n        }\n        for (j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group;\n        }\n        group += 1;\n    }\n    return {\n        gaps1: gaps1,\n        gaps2: gaps2\n    };\n}\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nfunction markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    let oldChildren = oldTree.children ? oldTree.children.filter(filterHavingTag) : [];\n    let newChildren = newTree.children ? newTree.children.filter(filterHavingTag) : [];\n    let marked1 = makeArray(oldChildren.length, false);\n    let marked2 = makeArray(newChildren.length, false);\n    let subsets = [];\n    let subset;\n    let returnIndex = function (_, index) {\n        return index;\n    };\n    let markBoth = function (i) {\n        if (subset) {\n            marked1[subset.oldValue + i] = true;\n            marked2[subset.newValue + i] = true;\n        }\n    };\n    let subsetArray;\n    do {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2);\n        if (subset) {\n            subsets.push(subset);\n            subsetArray = Array.apply(null, new Array(subset.length)).map(returnIndex);\n            // TODO: this might be a for 0..subset.length\n            for (let i = 0; i < subsetArray.length; i++) {\n                markBoth(subsetArray[i]);\n            }\n        }\n    } while (subset);\n    return subsets;\n}\nclass DiffDOM {\n    constructor(options = {}) {\n        this.options = options;\n        this.tracker = [];\n        this.t1Orig = undefined;\n        this.t2Orig = undefined;\n        this.debug = false;\n        this.diffcap = 10; // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n        this.maxDepth = false; // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n        this.maxChildCount = false; // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildCountDiffCount differences among child nodes.\n        this.maxChildCountDiffCount = 3; // Numeral. See maxChildCount.\n        this.filterOuterDiff = null;\n        this.compress = false;\n    }\n    // ===== Create a diff =====\n    diff(t1Node, t2Node) {\n        diffcount = 0;\n        if (this.debug) {\n            this.t1Orig = t1Node;\n            this.t2Orig = t2Node;\n        }\n        this.tracker = [];\n        return this.findDiffs(t1Node, t2Node);\n    }\n    findDiffs(t1, t2) {\n        let diffs;\n        do {\n            if (this.debug) {\n                diffcount += 1;\n                if (diffcount > this.diffcap) {\n                    // tslint:disable-next-line\n                    ;\n                    window.diffError = [this.t1Orig, this.t2Orig];\n                    throw new Error('surpassed diffcap:' + JSON.stringify(this.t1Orig) + ' -> ' + JSON.stringify(this.t2Orig));\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, []);\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (foundAll) {\n                        console.error('Could not find remaining diffs!');\n                        console.trace({ t1, t2 });\n                    }\n                    else {\n                        foundAll = true;\n                        removeDone(t1);\n                        diffs = this.findNextDiff(t1, t2, []);\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                foundAll = false;\n                this.tracker.push(...diffs);\n                this.applyVirtual(t1, diffs);\n            }\n        } while (diffs.length > 0);\n        return this.tracker;\n    }\n    findNextDiff(t1, t2, route) {\n        let diffs;\n        let fdiffs;\n        if (this.maxDepth && route.length > this.maxDepth) {\n            return [];\n        }\n        // outer differences?\n        if (!t1[outerDone]) {\n            diffs = this.findOuterDiff(t1, t2, route);\n            if (this.filterOuterDiff) {\n                fdiffs = this.filterOuterDiff(t1, t2, diffs);\n                if (fdiffs)\n                    diffs = fdiffs;\n            }\n            if (diffs.length > 0) {\n                // tslint:disable-next-line:semicolon\n                ;\n                t1[outerDone] = true;\n                return diffs;\n            }\n            else {\n                // tslint:disable-next-line:semicolon\n                ;\n                t1[outerDone] = true;\n            }\n        }\n        // inner differences?\n        if (!t1[innerDone]) {\n            diffs = this.findInnerDiff(t1, t2, route);\n            if (diffs.length > 0) {\n                return diffs;\n            }\n            else {\n                // tslint:disable-next-line:semicolon\n                ;\n                t1[innerDone] = true;\n            }\n        }\n        // no differences\n        return [];\n    }\n    findOuterDiff(t1, t2, route) {\n        let diffs = [];\n        let attr;\n        let attr1;\n        let attr2;\n        let attrLength;\n        let pos;\n        let i;\n        if (t1.tag !== t2.tag) {\n            return [\n                new Diff_1.Diff()\n                    .setValue(types_1.Actions.action, types_1.Actions.replaceElement)\n                    .setValue(types_1.Actions.oldValue, t1)\n                    .setValue(types_1.Actions.newValue, cloneObj(t2))\n                    .setValue(types_1.Actions.route, route)\n            ];\n        }\n        let t1Children = t1.children.filter(filterHavingTag);\n        let t2Children = t2.children.filter(filterHavingTag);\n        if (this.maxChildCount &&\n            t1Children &&\n            t2Children &&\n            t1Children.length > this.maxChildCount &&\n            t2Children.length > this.maxChildCount) {\n            let childNodesLength = t1Children.length < t2Children.length ? t1Children.length : t2Children.length;\n            let childDiffCount = 0;\n            let j = 0;\n            while (childDiffCount < this.maxChildCountDiffCount && j < childNodesLength) {\n                if (!isEqual(t1Children[j], t2Children[j])) {\n                    childDiffCount++;\n                }\n                j++;\n            }\n            if (childDiffCount === this.maxChildCountDiffCount) {\n                return [\n                    new Diff_1.Diff()\n                        .setValue(types_1.Actions.action, types_1.Actions.replaceElement)\n                        .setValue(types_1.Actions.oldValue, cloneObj(t1))\n                        .setValue(types_1.Actions.newValue, cloneObj(t2))\n                        .setValue(types_1.Actions.route, route)\n                ];\n            }\n        }\n        attr1 = t1.attrs ? Object.keys(t1.attrs).sort() : [];\n        attr2 = t2.attrs ? Object.keys(t2.attrs).sort() : [];\n        attrLength = attr1.length;\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i];\n            pos = attr2.indexOf(attr);\n            if (pos === -1) {\n                diffs.push(new Diff_1.Diff()\n                    .setValue(types_1.Actions.action, types_1.Actions.removeAttribute)\n                    .setValue(types_1.Actions.route, route)\n                    .setValue(types_1.Actions.name, attr));\n            }\n            else {\n                attr2.splice(pos, 1);\n                if (!deepEqual_1.deepEqual(t1.attrs[attr], t2.attrs[attr])) {\n                    diffs.push(new Diff_1.Diff()\n                        .setValue(types_1.Actions.action, types_1.Actions.modifyAttribute)\n                        .setValue(types_1.Actions.route, route)\n                        .setValue(types_1.Actions.name, attr)\n                        .setValue(types_1.Actions.oldValue, t1.attrs[attr])\n                        .setValue(types_1.Actions.newValue, t2.attrs[attr]));\n                }\n            }\n        }\n        attrLength = attr2.length;\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i];\n            diffs.push(new Diff_1.Diff()\n                .setValue(types_1.Actions.action, types_1.Actions.addAttribute)\n                .setValue(types_1.Actions.route, route)\n                .setValue(types_1.Actions.name, attr));\n        }\n        return diffs;\n    }\n    findInnerDiff(t1, t2, route) {\n        let subtrees = t1.children && t2.children ? markSubTrees(t1, t2) : [];\n        let t1ChildNodes = t1.children ? t1.children.filter(filterHavingTag) : [];\n        let t2ChildNodes = t2.children ? t2.children.filter(filterHavingTag) : [];\n        let childNodesLengthDifference;\n        let diffs = [];\n        let index = 0;\n        let last;\n        let e1;\n        let e2;\n        let i;\n        if (subtrees.length > 0) {\n            /* One or more groups have been identified among the children of t1\n             * and t2.\n             */\n            diffs = this.attemptGroupRelocation(t1, t2, subtrees, route);\n            if (diffs.length > 0) {\n                return diffs;\n            }\n        }\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n        last = Math.max(t1ChildNodes.length, t2ChildNodes.length);\n        if (t1ChildNodes.length !== t2ChildNodes.length) {\n            childNodesLengthDifference = true;\n        }\n        for (i = 0; i < last; i += 1) {\n            e1 = t1ChildNodes[i];\n            e2 = t2ChildNodes[i];\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of children. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    diffs.push(new Diff_1.Diff()\n                        .setValue(types_1.Actions.action, types_1.Actions.removeElement)\n                        .setValue(types_1.Actions.route, route.concat(index))\n                        .setValue(types_1.Actions.element, e1));\n                    index -= 1;\n                }\n                else if (e2 && !e1) {\n                    diffs.push(new Diff_1.Diff()\n                        .setValue(types_1.Actions.action, types_1.Actions.addElement)\n                        .setValue(types_1.Actions.route, route.concat(index))\n                        .setValue(types_1.Actions.element, cloneObj(e2)));\n                }\n            }\n            /* We are now guaranteed that children e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n            if (e1 && e2) {\n                diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)));\n            }\n            index += 1;\n        }\n        // tslint:disable-next-line:semicolon\n        ;\n        t1[innerDone] = true;\n        return diffs;\n    }\n    attemptGroupRelocation(t1, t2, subtrees, route) {\n        /* Either t1.children and t2.children have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n        */\n        let gapInformation = getGapInformation(t1, t2, subtrees);\n        let gaps1 = gapInformation.gaps1;\n        let gaps2 = gapInformation.gaps2;\n        let shortest = Math.min(gaps1.length, gaps2.length);\n        let destinationDifferent;\n        let toGroup;\n        let group;\n        let node;\n        let diffs = [];\n        let index1;\n        let index2;\n        let j;\n        let t1Children = t1.children.filter(filterHavingTag);\n        let t2Children = t2.children.filter(filterHavingTag);\n        for (index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n            if (gaps1[index2] === true) {\n                node = t1Children[index1];\n                diffs.push(new Diff_1.Diff()\n                    .setValue(types_1.Actions.action, types_1.Actions.removeElement)\n                    .setValue(types_1.Actions.route, route.concat(index2))\n                    .setValue(types_1.Actions.element, cloneObj(node)));\n                gaps1.splice(index2, 1);\n                shortest = Math.min(gaps1.length, gaps2.length);\n                index2 -= 1;\n            }\n            else if (gaps2[index2] === true) {\n                node = t2Children[index2];\n                diffs.push(new Diff_1.Diff()\n                    .setValue(types_1.Actions.action, types_1.Actions.addElement)\n                    .setValue(types_1.Actions.route, route.concat(index2))\n                    .setValue(types_1.Actions.element, cloneObj(node)));\n                gaps1.splice(index2, 0, true);\n                shortest = Math.min(gaps1.length, gaps2.length);\n                index1 -= 1;\n            }\n            else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs;\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]];\n                toGroup = Math.min(group.newValue, t1Children.length - group.length);\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false;\n                    for (j = 0; j < group.length; j += 1) {\n                        if (!roughlyEqual(t1Children[toGroup + j], t1Children[group.oldValue + j], {}, false, true)) {\n                            destinationDifferent = true;\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [\n                            new Diff_1.Diff()\n                                .setValue(types_1.Actions.action, types_1.Actions.relocateGroup)\n                                .setValue(types_1.Actions.groupLength, group.length)\n                                .setValue(types_1.Actions.from, group.oldValue)\n                                .setValue(types_1.Actions.to, toGroup)\n                                .setValue(types_1.Actions.route, route)\n                        ];\n                    }\n                }\n            }\n        }\n        return diffs;\n    }\n    // ===== Apply a virtual diff =====\n    /** Patches a virtual tree using a list of diffs */\n    applyVirtual(tree, diffs) {\n        let length = diffs.length;\n        if (length === 0) {\n            return true;\n        }\n        for (let i = 0; i < length; i++) {\n            let diff = diffs[i];\n            this.applyVirtualDiff(tree, diff);\n        }\n        return true;\n    }\n    /** Gets a node in the virtual tree by a route */\n    getFromVirtualRoute(tree, route) {\n        let node = tree;\n        let parentNode = undefined;\n        let nodeIndex = 0;\n        let newRoute = route.slice();\n        while (newRoute.length > 0) {\n            const ch = node.children.filter(filterHavingTag);\n            if (!ch.length) {\n                return undefined;\n            }\n            nodeIndex = newRoute.shift();\n            parentNode = node;\n            node = ch[nodeIndex];\n        }\n        return {\n            node,\n            parentNode,\n            nodeIndex\n        };\n    }\n    /** Patches a virtual tree using a diff */\n    applyVirtualDiff(tree, diff) {\n        let routeInfo = this.getFromVirtualRoute(tree, diff[types_1.Actions.route]);\n        let node = routeInfo && routeInfo.node;\n        let parentNode = routeInfo && routeInfo.parentNode;\n        let nodeIndex = (routeInfo && routeInfo.nodeIndex) || 0;\n        let newNode = undefined;\n        switch (diff[types_1.Actions.action]) {\n            case types_1.Actions.addElement:\n                const route = diff[types_1.Actions.route].slice();\n                const position = route.pop();\n                const x = this.getFromVirtualRoute(tree, route);\n                if (x) {\n                    node = x.node;\n                    newNode = cloneObj(diff[types_1.Actions.element]);\n                    // @ts-ignore\n                    newNode[outerDone] = true;\n                    // @ts-ignore\n                    newNode[innerDone] = true;\n                    if (!node.children) {\n                        node.children = [];\n                    }\n                    if (newNode) {\n                        if (node.children[position]) {\n                            node.children.splice(position, 0, newNode);\n                        }\n                        else {\n                            node.children.push(newNode);\n                        }\n                    }\n                }\n                break;\n            case types_1.Actions.addAttribute:\n                if (!node)\n                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n                if (!node.attrs) {\n                    node.attrs = {};\n                }\n                node.attrs[diff[types_1.Actions.name]] = diff[types_1.Actions.value];\n                break;\n            case types_1.Actions.modifyAttribute:\n                if (!node)\n                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n                node.attrs[diff[types_1.Actions.name]] = diff[types_1.Actions.newValue];\n                break;\n            case types_1.Actions.removeAttribute:\n                if (!node)\n                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n                delete node.attrs[diff[types_1.Actions.name]];\n                break;\n            case types_1.Actions.replaceElement:\n                newNode = cloneObj(diff[types_1.Actions.newValue]);\n                // @ts-ignore\n                newNode[outerDone] = true;\n                // @ts-ignore\n                newNode[innerDone] = true;\n                if (parentNode && newNode) {\n                    parentNode.children[nodeIndex] = newNode;\n                }\n                else {\n                    debugger;\n                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n                }\n                break;\n            case types_1.Actions.relocateGroup:\n                if (node) {\n                    const nodeArray = node.children.splice(diff[types_1.Actions.from], diff[types_1.Actions.groupLength]).reverse();\n                    for (let i = 0; i < nodeArray.length; i++) {\n                        node.children.splice(diff[types_1.Actions.to], 0, nodeArray[i]);\n                    }\n                }\n                break;\n            case types_1.Actions.removeElement:\n                if (!parentNode)\n                    throw new ReplaceWholeTreeException_1.ReplaceWholeTreeException();\n                parentNode.children.splice(nodeIndex, 1);\n                break;\n            default:\n                console.log('unknown action');\n        }\n        return undefined;\n    }\n}\nexports.DiffDOM = DiffDOM;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmRvbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC92ZG9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQXdDO0FBRXhDLG1EQUErQztBQUMvQyxpQ0FBNkI7QUFDN0IsMkVBQXVFO0FBQ3ZFLGtEQUE4QztBQUM5Qyw0QkFBNEI7QUFFNUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQ3JDLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUVyQyxJQUFJLFNBQWMsQ0FBQTtBQUNsQixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUE7QUFFcEIsNERBQTREO0FBQzVELFNBQVMsZUFBZSxDQUFDLENBQWtCO0lBQ3pDLE9BQU8sT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLFFBQVEsQ0FBQTtBQUNsQyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLGtCQUFrQixDQUFDLEVBQW1CO0lBQzdDLElBQUksTUFBTSxHQUFhLEVBQUUsQ0FBQTtJQUV6QixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUVuQixJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUU7UUFDWixJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO1lBQ2hCLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUN6QztRQUNELElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDZixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7U0FDeEM7UUFDRCxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO1lBQ2hC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U0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDekMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7cUJBQ3hEO2lCQUNGO2dCQUNELE1BQUs7WUFDUCxLQUFLLGVBQU8sQ0FBQyxhQUFhO2dCQUN4QixJQUFJLENBQUMsVUFBVTtvQkFBRSxNQUFNLElBQUkscURBQXlCLEVBQUUsQ0FBQTtnQkFDdEQsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFBO2dCQUN4QyxNQUFLO1lBQ1A7Z0JBQ0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO1NBQ2hDO1FBRUQsT0FBTyxTQUFTLENBQUE7SUFDbEIsQ0FBQztDQUNGO0FBL2RELDBCQStkQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGlvbnMsIElEaWZmIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IElTaW1wbGlmaWVkTm9kZSB9IGZyb20gJy4uL2ludGVyZmFjZXMnXG5pbXBvcnQgeyBTdWJzZXRNYXBwaW5nIH0gZnJvbSAnLi9TdWJzZXRNYXBwaW5nJ1xuaW1wb3J0IHsgRGlmZiB9IGZyb20gJy4vRGlmZidcbmltcG9ydCB7IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gfSBmcm9tICcuL1JlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24nXG5pbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tICcuLi91dGlscy9kZWVwRXF1YWwnXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5cbmNvbnN0IGlubmVyRG9uZSA9IFN5bWJvbCgnaW5uZXJEb25lJylcbmNvbnN0IG91dGVyRG9uZSA9IFN5bWJvbCgnb3V0ZXJEb25lJylcblxubGV0IGRpZmZjb3VudDogYW55XG5sZXQgZm91bmRBbGwgPSBmYWxzZVxuXG4vKiogUmV0dXJucyB0aGUgZWxlbWVudHMgY29uYWluaW5nIGEgLnRhZyBzdHJpbmcgcHJvcGVydHkgKi9cbmZ1bmN0aW9uIGZpbHRlckhhdmluZ1RhZygkOiBJU2ltcGxpZmllZE5vZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiAkLnRhZyA9PT0gJ3N0cmluZydcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGVsZW1lbnQgZGVzY3JpcHRvcnMsIGl0IGlzIGFuIGFycmF5IHVzZWQgdG8gaWRlbnRpZnkgdGhlIGdpdmVuIG5vZGVcbiAqL1xuZnVuY3Rpb24gZWxlbWVudERlc2NyaXB0b3JzKGVsOiBJU2ltcGxpZmllZE5vZGUpOiBzdHJpbmdbXSB7XG4gIGxldCBvdXRwdXQ6IHN0cmluZ1tdID0gW11cblxuICBvdXRwdXQucHVzaChlbC50YWcpXG5cbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgaWYgKGVsLmF0dHJzLmtleSkge1xuICAgICAgb3V0cHV0LnB1c2goZWwudGFnICsgJy4nICsgZWwuYXR0cnMua2V5KVxuICAgIH1cbiAgICBpZiAoZWwuYXR0cnMuaWQpIHtcbiAgICAgIG91dHB1dC5wdXNoKGVsLnRhZyArICcjJyArIGVsLmF0dHJzLmlkKVxuICAgIH1cbiAgICBpZiAoZWwuYXR0cnMuc3JjKSB7XG4gICAgICBvdXRwdXQucHVzaChlbC50YWcgKyAnJScgKyBlbC5hdHRycy5zcmMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5mdW5jdGlvbiBmaW5kVW5pcXVlRGVzY3JpcHRvcnMobGlzdDogSVNpbXBsaWZpZWROb2RlW10pIHtcbiAgbGV0IHVuaXF1ZURlc2NyaXB0b3JzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9XG4gIGxldCBkdXBsaWNhdGVEZXNjcmlwdG9yczogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fVxuICBsZXQgbm9kZTogSVNpbXBsaWZpZWROb2RlXG4gIGxldCBkZXNjcmlwdG9yczogc3RyaW5nW11cbiAgbGV0IGRlc2NyaXB0b3I6IHN0cmluZ1xuICBsZXQgaW5VbmlxdWU6IGJvb2xlYW5cbiAgbGV0IGluRHVwZXM6IGJvb2xlYW5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbGlzdFtpXVxuICAgIGRlc2NyaXB0b3JzID0gZWxlbWVudERlc2NyaXB0b3JzKG5vZGUpXG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRlc2NyaXB0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICBkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbal1cbiAgICAgIGluVW5pcXVlID0gZGVzY3JpcHRvciBpbiB1bmlxdWVEZXNjcmlwdG9yc1xuICAgICAgaW5EdXBlcyA9IGRlc2NyaXB0b3IgaW4gZHVwbGljYXRlRGVzY3JpcHRvcnNcbiAgICAgIGlmICghaW5VbmlxdWUgJiYgIWluRHVwZXMpIHtcbiAgICAgICAgdW5pcXVlRGVzY3JpcHRvcnNbZGVzY3JpcHRvcl0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGluVW5pcXVlKSB7XG4gICAgICAgIGRlbGV0ZSB1bmlxdWVEZXNjcmlwdG9yc1tkZXNjcmlwdG9yXVxuICAgICAgICBkdXBsaWNhdGVEZXNjcmlwdG9yc1tkZXNjcmlwdG9yXSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pcXVlRGVzY3JpcHRvcnNcbn1cblxuZnVuY3Rpb24gdW5pcXVlSW5Cb3RoKGwxOiBJU2ltcGxpZmllZE5vZGVbXSwgbDI6IElTaW1wbGlmaWVkTm9kZVtdKSB7XG4gIGxldCBsMVVuaXF1ZSA9IGZpbmRVbmlxdWVEZXNjcmlwdG9ycyhsMSlcbiAgbGV0IGwyVW5pcXVlID0gZmluZFVuaXF1ZURlc2NyaXB0b3JzKGwyKVxuICBsZXQgaW5Cb3RoOiB7IFtkZXNjcmlwdG9yOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGwxVW5pcXVlKVxuICBsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgbGV0IGtleTogc3RyaW5nXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBpZiAobDJVbmlxdWVba2V5XSkge1xuICAgICAgaW5Cb3RoW2tleV0gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluQm90aFxufVxuXG5mdW5jdGlvbiByZW1vdmVEb25lKHRyZWU6IElTaW1wbGlmaWVkTm9kZSk6IGJvb2xlYW4ge1xuICAvLyBAdHMtaWdub3JlXG4gIGRlbGV0ZSB0cmVlW291dGVyRG9uZV1cbiAgLy8gQHRzLWlnbm9yZVxuICBkZWxldGUgdHJlZVtpbm5lckRvbmVdXG5cbiAgaWYgKHRyZWUuY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5ldmVyeShyZW1vdmVEb25lKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcXVhbChlMTogSVNpbXBsaWZpZWROb2RlLCBlMjogSVNpbXBsaWZpZWROb2RlKSB7XG4gIGxldCBlMUF0dHJpYnV0ZXM6IHN0cmluZ1tdXG4gIGxldCBlMkF0dHJpYnV0ZXM6IHN0cmluZ1tdXG5cbiAgaWYgKFxuICAgICFbJ3RhZyddLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQ6IGFueSkge1xuICAgICAgaWYgKChlMSBhcyBhbnkpW2VsZW1lbnRdICE9PSAoZTIgYXMgYW55KVtlbGVtZW50XSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoQm9vbGVhbihlMS5hdHRycykgIT09IEJvb2xlYW4oZTIuYXR0cnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoQm9vbGVhbihlMS5jaGlsZHJlbikgIT09IEJvb2xlYW4oZTIuY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGUxLmF0dHJzKSB7XG4gICAgZTFBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZTEuYXR0cnMpXG4gICAgZTJBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZTIuYXR0cnMpXG5cbiAgICBpZiAoZTFBdHRyaWJ1dGVzLmxlbmd0aCAhPT0gZTJBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChcbiAgICAgICFlMUF0dHJpYnV0ZXMuZXZlcnkoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGUxLmF0dHJzW2F0dHJpYnV0ZV0sIGUyLmF0dHJzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKGUxLmNoaWxkcmVuKSB7XG4gICAgaWYgKGUxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpLmxlbmd0aCAhPT0gZTIuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZykubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWUxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpLmV2ZXJ5KGZ1bmN0aW9uKGNoaWxkTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwoY2hpbGROb2RlLCBlMi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVtpbmRleF0pXG4gICAgICB9KVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcm91Z2hseUVxdWFsKFxuICBlMTogSVNpbXBsaWZpZWROb2RlLFxuICBlMjogSVNpbXBsaWZpZWROb2RlLFxuICB1bmlxdWVEZXNjcmlwdG9yczogeyBbZGVzY3JpcHRvcjogc3RyaW5nXTogYm9vbGVhbiB9LFxuICBzYW1lU2libGluZ3M6IGJvb2xlYW4sXG4gIHByZXZlbnRSZWN1cnNpb24gPSBmYWxzZVxuKTogYm9vbGVhbiB7XG4gIGxldCBjaGlsZFVuaXF1ZURlc2NyaXB0b3JzOiB7IFtkZXNjcmlwdG9yOiBzdHJpbmddOiBib29sZWFuIH1cbiAgbGV0IG5vZGVMaXN0MTogSVNpbXBsaWZpZWROb2RlW11cbiAgbGV0IG5vZGVMaXN0MjogSVNpbXBsaWZpZWROb2RlW11cblxuICBpZiAoIWUxIHx8ICFlMikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGUxLnRhZyAhPT0gZTIudGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZTEudGFnIGluIHVuaXF1ZURlc2NyaXB0b3JzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChlMS5hdHRycyAmJiBlMi5hdHRycykge1xuICAgIGlmIChlMS5hdHRycy5pZCkge1xuICAgICAgaWYgKGUxLmF0dHJzLmlkICE9PSBlMi5hdHRycy5pZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpZERlc2NyaXB0b3IgPSBlMS50YWcgKyAnIycgKyBlMS5hdHRycy5pZFxuICAgICAgICBpZiAoaWREZXNjcmlwdG9yIGluIHVuaXF1ZURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZTEuYXR0cnMua2V5KSB7XG4gICAgICBpZiAoZTEuYXR0cnMua2V5ICE9PSBlMi5hdHRycy5rZXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga2V5RGVzY3JpcHRvciA9IGUxLnRhZyArICcuJyArIGUxLmF0dHJzLmtleVxuICAgICAgICBpZiAoa2V5RGVzY3JpcHRvciBpbiB1bmlxdWVEZXNjcmlwdG9ycykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUxLmF0dHJzLnNyYykge1xuICAgICAgaWYgKGUxLmF0dHJzLnNyYyAhPT0gZTIuYXR0cnMuc3JjKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGtleURlc2NyaXB0b3IgPSBlMS50YWcgKyAnJScgKyBlMS5hdHRycy5zcmNcbiAgICAgICAgaWYgKGtleURlc2NyaXB0b3IgaW4gdW5pcXVlRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNhbWVTaWJsaW5ncykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBub2RlTGlzdDEgPSBlMS5jaGlsZHJlblxuICAgID8gZTEuY2hpbGRyZW5cbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICA6IFtdXG4gIG5vZGVMaXN0MiA9IGUyLmNoaWxkcmVuXG4gICAgPyBlMi5jaGlsZHJlblxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuZmlsdGVyKGZpbHRlckhhdmluZ1RhZylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgIDogW11cblxuICBpZiAobm9kZUxpc3QxLmxlbmd0aCAhPT0gbm9kZUxpc3QyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHByZXZlbnRSZWN1cnNpb24pIHtcbiAgICByZXR1cm4gbm9kZUxpc3QxLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50YWcgPT09IG5vZGVMaXN0MltpbmRleF0udGFnXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBub3RlOiB3ZSBvbmx5IGFsbG93IG9uZSBsZXZlbCBvZiByZWN1cnNpb24gYXQgYW55IGRlcHRoLiBJZiAncHJldmVudFJlY3Vyc2lvbidcbiAgICAvLyB3YXMgbm90IHNldCwgd2UgbXVzdCBleHBsaWNpdGx5IGZvcmNlIGl0IHRvIHRydWUgZm9yIGNoaWxkIGl0ZXJhdGlvbnMuXG4gICAgY2hpbGRVbmlxdWVEZXNjcmlwdG9ycyA9IHVuaXF1ZUluQm90aChub2RlTGlzdDEsIG5vZGVMaXN0MilcbiAgICByZXR1cm4gbm9kZUxpc3QxLmV2ZXJ5KGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcm91Z2hseUVxdWFsKGVsZW1lbnQsIG5vZGVMaXN0MltpbmRleF0sIGNoaWxkVW5pcXVlRGVzY3JpcHRvcnMsIHRydWUsIHRydWUpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZU9iajxUPihvYmo6IFQpOiBUIHtcbiAgLy8gIFRPRE86IERvIHdlIHJlYWxseSBuZWVkIHRvIGNsb25lIGhlcmU/IElzIGl0IG5vdCBlbm91Z2ggdG8ganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsIG9iamVjdD9cbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cblxuLyoqXG4gKiBiYXNlZCBvbiBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1faW1wbGVtZW50YXRpb24vU3RyaW5ncy9Mb25nZXN0X2NvbW1vbl9zdWJzdHJpbmcjSmF2YVNjcmlwdFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uU3Vic2V0cyhcbiAgYzE6IElTaW1wbGlmaWVkTm9kZVtdLFxuICBjMjogSVNpbXBsaWZpZWROb2RlW10sXG4gIG1hcmtlZDE6IGJvb2xlYW5bXSxcbiAgbWFya2VkMjogYm9vbGVhbltdXG4pOiBTdWJzZXRNYXBwaW5nIHwgdm9pZCB7XG4gIGxldCBsY3NTaXplID0gMFxuICBsZXQgaW5kZXg6IG51bWJlcltdID0gW11cbiAgbGV0IGMxTGVuZ3RoID0gYzEubGVuZ3RoXG4gIGxldCBjMkxlbmd0aCA9IGMyLmxlbmd0aFxuICBsZXQgbWF0Y2hlcyA9IEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheShjMUxlbmd0aCArIDEpKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0pXG4gIC8vIHNldCB1cCB0aGUgbWF0Y2hpbmcgdGFibGVcbiAgbGV0IHVuaXF1ZURlc2NyaXB0b3JzID0gdW5pcXVlSW5Cb3RoKGMxLCBjMilcbiAgLy8gSWYgYWxsIG9mIHRoZSBlbGVtZW50cyBhcmUgdGhlIHNhbWUgdGFnLCBpZCBhbmQgY2xhc3MsIHRoZW4gd2UgY2FuXG4gIC8vIGNvbnNpZGVyIHRoZW0gcm91Z2hseSB0aGUgc2FtZSBldmVuIGlmIHRoZXkgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgLy8gY2hpbGRyZW4uIFRoaXMgd2lsbCByZWR1Y2UgcmVtb3ZpbmcgYW5kIHJlLWFkZGluZyBzaW1pbGFyIGVsZW1lbnRzLlxuICBsZXQgc3Vic2V0c1NhbWUgPSBjMUxlbmd0aCA9PT0gYzJMZW5ndGhcbiAgbGV0IG9yaWdpblxuICBsZXQgcmV0XG4gIGxldCBjMUluZGV4OiBudW1iZXJcbiAgbGV0IGMySW5kZXg6IG51bWJlclxuICBsZXQgYzFFbGVtZW50OiBJU2ltcGxpZmllZE5vZGVcbiAgbGV0IGMyRWxlbWVudDogSVNpbXBsaWZpZWROb2RlXG5cbiAgaWYgKHN1YnNldHNTYW1lKSB7XG4gICAgYzEuc29tZShmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICBsZXQgYzFEZXNjID0gZWxlbWVudERlc2NyaXB0b3JzKGVsZW1lbnQpXG4gICAgICBsZXQgYzJEZXNjID0gZWxlbWVudERlc2NyaXB0b3JzKGMyW2ldKVxuICAgICAgaWYgKGMxRGVzYy5sZW5ndGggIT09IGMyRGVzYy5sZW5ndGgpIHtcbiAgICAgICAgc3Vic2V0c1NhbWUgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgYzFEZXNjLnNvbWUoZnVuY3Rpb24oZGVzY3JpcHRpb24sIGkpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSBjMkRlc2NbaV0pIHtcbiAgICAgICAgICBzdWJzZXRzU2FtZSA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG4gICAgICBpZiAoIXN1YnNldHNTYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgLy8gZmlsbCB0aGUgbWF0Y2hlcyB3aXRoIGRpc3RhbmNlIHZhbHVlc1xuICBmb3IgKGMxSW5kZXggPSAwOyBjMUluZGV4IDwgYzFMZW5ndGg7IGMxSW5kZXgrKykge1xuICAgIGMxRWxlbWVudCA9IGMxW2MxSW5kZXhdXG4gICAgZm9yIChjMkluZGV4ID0gMDsgYzJJbmRleCA8IGMyTGVuZ3RoOyBjMkluZGV4KyspIHtcbiAgICAgIGMyRWxlbWVudCA9IGMyW2MySW5kZXhdXG4gICAgICBpZiAoXG4gICAgICAgICFtYXJrZWQxW2MxSW5kZXhdICYmXG4gICAgICAgICFtYXJrZWQyW2MySW5kZXhdICYmXG4gICAgICAgIHJvdWdobHlFcXVhbChjMUVsZW1lbnQsIGMyRWxlbWVudCwgdW5pcXVlRGVzY3JpcHRvcnMsIHN1YnNldHNTYW1lKVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoZXNbYzFJbmRleCArIDFdW2MySW5kZXggKyAxXSA9IG1hdGNoZXNbYzFJbmRleF1bYzJJbmRleF0gPyBtYXRjaGVzW2MxSW5kZXhdW2MySW5kZXhdICsgMSA6IDFcbiAgICAgICAgaWYgKG1hdGNoZXNbYzFJbmRleCArIDFdW2MySW5kZXggKyAxXSA+PSBsY3NTaXplKSB7XG4gICAgICAgICAgbGNzU2l6ZSA9IG1hdGNoZXNbYzFJbmRleCArIDFdW2MySW5kZXggKyAxXVxuICAgICAgICAgIGluZGV4ID0gW2MxSW5kZXggKyAxLCBjMkluZGV4ICsgMV1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlc1tjMUluZGV4ICsgMV1bYzJJbmRleCArIDFdID0gMFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsY3NTaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIG9yaWdpbiA9IFtpbmRleFswXSAtIGxjc1NpemUsIGluZGV4WzFdIC0gbGNzU2l6ZV1cbiAgcmV0ID0gbmV3IFN1YnNldE1hcHBpbmcob3JpZ2luWzBdLCBvcmlnaW5bMV0pXG4gIHJldC5sZW5ndGggPSBsY3NTaXplXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIFRoaXMgc2hvdWxkIHJlYWxseSBiZSBhIHByZWRlZmluZWQgZnVuY3Rpb24gaW4gQXJyYXkuLi5cbiAqL1xuZnVuY3Rpb24gbWFrZUFycmF5PFQ+KG46IG51bWJlciwgdjogVCk6IFRbXSB7XG4gIHJldHVybiBBcnJheS5hcHBseShudWxsLCBuZXcgQXJyYXkobikpLm1hcChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdlxuICB9KVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFycmF5cyB0aGF0IGluZGljYXRlIHdoaWNoIG5vZGUgYmVsb25ncyB0byB3aGljaCBzdWJzZXQsXG4gKiBvciB3aGV0aGVyIGl0J3MgYWN0dWFsbHkgYW4gb3JwaGFuIG5vZGUsIGV4aXN0aW5nIGluIG9ubHkgb25lXG4gKiBvZiB0aGUgdHdvIHRyZWVzLCByYXRoZXIgdGhhbiBzb21ld2hlcmUgaW4gYm90aC5cbiAqXG4gKiBTbyBpZiB0MSA9IDxpbWc+PGNhbnZhcz48YnI+LCB0MiA9IDxjYW52YXM+PGJyPjxpbWc+LlxuICogVGhlIGxvbmdlc3Qgc3Vic2V0IGlzIFwiPGNhbnZhcz48YnI+XCIgKGxlbmd0aCAyKSwgc28gaXQgd2lsbCBncm91cCAwLlxuICogVGhlIHNlY29uZCBsb25nZXN0IGlzIFwiPGltZz5cIiAobGVuZ3RoIDEpLCBzbyBpdCB3aWxsIGJlIGdyb3VwIDEuXG4gKiBnYXBzMSB3aWxsIHRoZXJlZm9yZSBiZSBbMSwwLDBdIGFuZCBnYXBzMiBbMCwwLDFdLlxuICpcbiAqIElmIGFuIGVsZW1lbnQgaXMgbm90IHBhcnQgb2YgYW55IGdyb3VwLCBpdCB3aWxsIHN0YXkgYmVpbmcgJ3RydWUnLCB3aGljaFxuICogaXMgdGhlIGluaXRpYWwgdmFsdWUuIEZvciBleGFtcGxlOlxuICogdDEgPSA8aW1nPjxwPjwvcD48YnI+PGNhbnZhcz4sIHQyID0gPGI+PC9iPjxicj48Y2FudmFzPjxpbWc+XG4gKlxuICogVGhlIFwiPHA+PC9wPlwiIGFuZCBcIjxiPjwvYj5cIiBkbyBvbmx5IHNob3cgdXAgaW4gb25lIG9mIHRoZSB0d28gYW5kIHdpbGxcbiAqIHRoZXJlZm9yZSBiZSBtYXJrZWQgYnkgXCJ0cnVlXCIuIFRoZSByZW1haW5pbmcgcGFydHMgYXJlIHBhcnRzIG9mIHRoZVxuICogZ3JvdXBzIDAgYW5kIDE6XG4gKiBnYXBzMSA9IFsxLCB0cnVlLCAwLCAwXSwgZ2FwczIgPSBbdHJ1ZSwgMCwgMCwgMV1cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldEdhcEluZm9ybWF0aW9uKHQxOiBJU2ltcGxpZmllZE5vZGUsIHQyOiBJU2ltcGxpZmllZE5vZGUsIHN0YWJsZTogU3Vic2V0TWFwcGluZ1tdKSB7XG4gIGxldCBnYXBzMTogKG51bWJlciB8IHRydWUpW10gPSB0MS5jaGlsZHJlblxuICAgID8gKG1ha2VBcnJheSh0MS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKS5sZW5ndGgsIHRydWUpIGFzIHRydWVbXSlcbiAgICA6IFtdXG4gIGxldCBnYXBzMjogKG51bWJlciB8IHRydWUpW10gPSB0Mi5jaGlsZHJlblxuICAgID8gKG1ha2VBcnJheSh0Mi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKS5sZW5ndGgsIHRydWUpIGFzIHRydWVbXSlcbiAgICA6IFtdXG4gIGxldCBncm91cCA9IDBcbiAgbGV0IGxlbmd0aCA9IHN0YWJsZS5sZW5ndGhcbiAgbGV0IGk6IG51bWJlclxuICBsZXQgajogbnVtYmVyXG4gIGxldCBlbmRPbGQ6IG51bWJlclxuICBsZXQgZW5kTmV3OiBudW1iZXJcbiAgbGV0IHN1YnNldDogU3Vic2V0TWFwcGluZ1xuXG4gIC8vIGdpdmUgZWxlbWVudHMgZnJvbSB0aGUgc2FtZSBzdWJzZXQgdGhlIHNhbWUgZ3JvdXAgbnVtYmVyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHN1YnNldCA9IHN0YWJsZVtpXVxuICAgIGVuZE9sZCA9IHN1YnNldC5vbGRWYWx1ZSArIHN1YnNldC5sZW5ndGhcbiAgICBlbmROZXcgPSBzdWJzZXQubmV3VmFsdWUgKyBzdWJzZXQubGVuZ3RoXG4gICAgZm9yIChqID0gc3Vic2V0Lm9sZFZhbHVlOyBqIDwgZW5kT2xkOyBqICs9IDEpIHtcbiAgICAgIGdhcHMxW2pdID0gZ3JvdXBcbiAgICB9XG4gICAgZm9yIChqID0gc3Vic2V0Lm5ld1ZhbHVlOyBqIDwgZW5kTmV3OyBqICs9IDEpIHtcbiAgICAgIGdhcHMyW2pdID0gZ3JvdXBcbiAgICB9XG4gICAgZ3JvdXAgKz0gMVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnYXBzMTogZ2FwczEsXG4gICAgZ2FwczI6IGdhcHMyXG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kIGFsbCBtYXRjaGluZyBzdWJzZXRzLCBiYXNlZCBvbiBpbW1lZGlhdGUgY2hpbGQgZGlmZmVyZW5jZXMgb25seS5cbiAqL1xuZnVuY3Rpb24gbWFya1N1YlRyZWVzKG9sZFRyZWU6IElTaW1wbGlmaWVkTm9kZSwgbmV3VHJlZTogSVNpbXBsaWZpZWROb2RlKSB7XG4gIC8vIG5vdGU6IHRoZSBjaGlsZCBsaXN0cyBhcmUgdmlld3MsIGFuZCBzbyB1cGRhdGUgYXMgd2UgdXBkYXRlIG9sZC9uZXdUcmVlXG4gIGxldCBvbGRDaGlsZHJlbiA9IG9sZFRyZWUuY2hpbGRyZW4gPyBvbGRUcmVlLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpIDogW11cbiAgbGV0IG5ld0NoaWxkcmVuID0gbmV3VHJlZS5jaGlsZHJlbiA/IG5ld1RyZWUuY2hpbGRyZW4uZmlsdGVyKGZpbHRlckhhdmluZ1RhZykgOiBbXVxuICBsZXQgbWFya2VkMSA9IG1ha2VBcnJheShvbGRDaGlsZHJlbi5sZW5ndGgsIGZhbHNlKVxuICBsZXQgbWFya2VkMiA9IG1ha2VBcnJheShuZXdDaGlsZHJlbi5sZW5ndGgsIGZhbHNlKVxuICBsZXQgc3Vic2V0cyA9IFtdXG4gIGxldCBzdWJzZXQ6IFN1YnNldE1hcHBpbmcgfCB2b2lkXG4gIGxldCByZXR1cm5JbmRleCA9IGZ1bmN0aW9uKF86IGFueSwgaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4XG4gIH1cbiAgbGV0IG1hcmtCb3RoID0gZnVuY3Rpb24oaTogbnVtYmVyKSB7XG4gICAgaWYgKHN1YnNldCkge1xuICAgICAgbWFya2VkMVtzdWJzZXQub2xkVmFsdWUgKyBpXSA9IHRydWVcbiAgICAgIG1hcmtlZDJbc3Vic2V0Lm5ld1ZhbHVlICsgaV0gPSB0cnVlXG4gICAgfVxuICB9XG4gIGxldCBzdWJzZXRBcnJheTogbnVtYmVyW11cblxuICBkbyB7XG4gICAgc3Vic2V0ID0gZmluZENvbW1vblN1YnNldHMob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBtYXJrZWQxLCBtYXJrZWQyKVxuICAgIGlmIChzdWJzZXQpIHtcbiAgICAgIHN1YnNldHMucHVzaChzdWJzZXQpXG4gICAgICBzdWJzZXRBcnJheSA9IEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheShzdWJzZXQubGVuZ3RoKSkubWFwKHJldHVybkluZGV4KVxuXG4gICAgICAvLyBUT0RPOiB0aGlzIG1pZ2h0IGJlIGEgZm9yIDAuLnN1YnNldC5sZW5ndGhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2V0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFya0JvdGgoc3Vic2V0QXJyYXlbaV0pXG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChzdWJzZXQpXG4gIHJldHVybiBzdWJzZXRzXG59XG5cbmV4cG9ydCBjbGFzcyBEaWZmRE9NIHtcbiAgdHJhY2tlcjogRGlmZltdID0gW11cbiAgdDFPcmlnOiBJU2ltcGxpZmllZE5vZGUgfCB2b2lkID0gdW5kZWZpbmVkXG4gIHQyT3JpZzogSVNpbXBsaWZpZWROb2RlIHwgdm9pZCA9IHVuZGVmaW5lZFxuICBkZWJ1ZyA9IGZhbHNlXG4gIGRpZmZjYXAgPSAxMCAvLyBMaW1pdCBmb3IgaG93IG1hbnkgZGlmZnMgYXJlIGFjY2VwdGluZyB3aGVuIGRlYnVnZ2luZy4gSW5hY3RpdmUgd2hlbiBkZWJ1ZyBpcyBmYWxzZS5cbiAgbWF4RGVwdGg6IG51bWJlciB8IGZhbHNlID0gZmFsc2UgLy8gRmFsc2Ugb3IgYSBudW1lcmFsLiBJZiBzZXQgdG8gYSBudW1lcmFsLCBsaW1pdHMgdGhlIGxldmVsIG9mIGRlcHRoIHRoYXQgdGhlIHRoZSBkaWZmIG1lY2hhbmlzbSBsb29rcyBmb3IgZGlmZmVyZW5jZXMuIElmIGZhbHNlLCBnb2VzIHRocm91Z2ggdGhlIGVudGlyZSB0cmVlLlxuICBtYXhDaGlsZENvdW50OiBudW1iZXIgfCBmYWxzZSA9IGZhbHNlIC8vIEZhbHNlIG9yIGEgbnVtZXJhbC4gSWYgc2V0IHRvIGEgbnVtZXJhbCwgZG9lcyBub3QgdHJ5IHRvIGRpZmYgdGhlIGNvbnRlbnRzIG9mIG5vZGVzIHdpdGggbW9yZSBjaGlsZHJlbiBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG1heENoaWxkQ291bnREaWZmQ291bnQgZGlmZmVyZW5jZXMgYW1vbmcgY2hpbGQgbm9kZXMuXG4gIG1heENoaWxkQ291bnREaWZmQ291bnQgPSAzIC8vIE51bWVyYWwuIFNlZSBtYXhDaGlsZENvdW50LlxuICBmaWx0ZXJPdXRlckRpZmY6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGxcbiAgY29tcHJlc3MgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zID0ge30pIHt9XG5cbiAgLy8gPT09PT0gQ3JlYXRlIGEgZGlmZiA9PT09PVxuXG4gIGRpZmYodDFOb2RlOiBJU2ltcGxpZmllZE5vZGUsIHQyTm9kZTogSVNpbXBsaWZpZWROb2RlKTogRGlmZltdIHtcbiAgICBkaWZmY291bnQgPSAwXG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgdGhpcy50MU9yaWcgPSB0MU5vZGVcbiAgICAgIHRoaXMudDJPcmlnID0gdDJOb2RlXG4gICAgfVxuXG4gICAgdGhpcy50cmFja2VyID0gW11cbiAgICByZXR1cm4gdGhpcy5maW5kRGlmZnModDFOb2RlLCB0Mk5vZGUpXG4gIH1cblxuICBmaW5kRGlmZnModDE6IElTaW1wbGlmaWVkTm9kZSwgdDI6IElTaW1wbGlmaWVkTm9kZSk6IERpZmZbXSB7XG4gICAgbGV0IGRpZmZzOiBEaWZmW11cbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBkaWZmY291bnQgKz0gMVxuICAgICAgICBpZiAoZGlmZmNvdW50ID4gdGhpcy5kaWZmY2FwKSB7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5kaWZmRXJyb3IgPSBbdGhpcy50MU9yaWcsIHRoaXMudDJPcmlnXVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3VycGFzc2VkIGRpZmZjYXA6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMudDFPcmlnKSArICcgLT4gJyArIEpTT04uc3RyaW5naWZ5KHRoaXMudDJPcmlnKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlmZnMgPSB0aGlzLmZpbmROZXh0RGlmZih0MSwgdDIsIFtdKVxuXG4gICAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIExhc3QgY2hlY2sgaWYgdGhlIGVsZW1lbnRzIHJlYWxseSBhcmUgdGhlIHNhbWUgbm93LlxuICAgICAgICAvLyBJZiBub3QsIHJlbW92ZSBhbGwgaW5mbyBhYm91dCBiZWluZyBkb25lIGFuZCBzdGFydCBvdmVyLlxuICAgICAgICAvLyBTb21ldGltZXMgYSBub2RlIGNhbiBiZSBtYXJrZWQgYXMgZG9uZSwgYnV0IHRoZSBjcmVhdGlvbiBvZiBzdWJzZXF1ZW50IGRpZmZzIG1lYW5zIHRoYXQgaXQgaGFzIHRvIGJlIGNoYW5nZWQgYWdhaW4uXG4gICAgICAgIGlmICghaXNFcXVhbCh0MSwgdDIpKSB7XG4gICAgICAgICAgaWYgKGZvdW5kQWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZmluZCByZW1haW5pbmcgZGlmZnMhJylcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoeyB0MSwgdDIgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm91bmRBbGwgPSB0cnVlXG4gICAgICAgICAgICByZW1vdmVEb25lKHQxKVxuICAgICAgICAgICAgZGlmZnMgPSB0aGlzLmZpbmROZXh0RGlmZih0MSwgdDIsIFtdKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZmZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm91bmRBbGwgPSBmYWxzZVxuICAgICAgICB0aGlzLnRyYWNrZXIucHVzaCguLi5kaWZmcylcbiAgICAgICAgdGhpcy5hcHBseVZpcnR1YWwodDEsIGRpZmZzKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGRpZmZzLmxlbmd0aCA+IDApXG4gICAgcmV0dXJuIHRoaXMudHJhY2tlclxuICB9XG5cbiAgZmluZE5leHREaWZmKHQxOiBJU2ltcGxpZmllZE5vZGUsIHQyOiBJU2ltcGxpZmllZE5vZGUsIHJvdXRlOiBudW1iZXJbXSk6IERpZmZbXSB7XG4gICAgbGV0IGRpZmZzOiBEaWZmW11cbiAgICBsZXQgZmRpZmZzXG5cbiAgICBpZiAodGhpcy5tYXhEZXB0aCAmJiByb3V0ZS5sZW5ndGggPiB0aGlzLm1heERlcHRoKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgLy8gb3V0ZXIgZGlmZmVyZW5jZXM/XG4gICAgaWYgKCEodDEgYXMgYW55KVtvdXRlckRvbmVdKSB7XG4gICAgICBkaWZmcyA9IHRoaXMuZmluZE91dGVyRGlmZih0MSwgdDIsIHJvdXRlKVxuICAgICAgaWYgKHRoaXMuZmlsdGVyT3V0ZXJEaWZmKSB7XG4gICAgICAgIGZkaWZmcyA9IHRoaXMuZmlsdGVyT3V0ZXJEaWZmKHQxLCB0MiwgZGlmZnMpXG4gICAgICAgIGlmIChmZGlmZnMpIGRpZmZzID0gZmRpZmZzXG4gICAgICB9XG4gICAgICBpZiAoZGlmZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgICAgIDsodDEgYXMgYW55KVtvdXRlckRvbmVdID0gdHJ1ZVxuICAgICAgICByZXR1cm4gZGlmZnNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzZW1pY29sb25cbiAgICAgICAgOyh0MSBhcyBhbnkpW291dGVyRG9uZV0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlubmVyIGRpZmZlcmVuY2VzP1xuICAgIGlmICghKHQxIGFzIGFueSlbaW5uZXJEb25lXSkge1xuICAgICAgZGlmZnMgPSB0aGlzLmZpbmRJbm5lckRpZmYodDEsIHQyLCByb3V0ZSlcbiAgICAgIGlmIChkaWZmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgICA7KHQxIGFzIGFueSlbaW5uZXJEb25lXSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBkaWZmZXJlbmNlc1xuICAgIHJldHVybiBbXVxuICB9XG4gIGZpbmRPdXRlckRpZmYodDE6IElTaW1wbGlmaWVkTm9kZSwgdDI6IElTaW1wbGlmaWVkTm9kZSwgcm91dGU6IG51bWJlcltdKTogRGlmZltdIHtcbiAgICBsZXQgZGlmZnM6IERpZmZbXSA9IFtdXG4gICAgbGV0IGF0dHJcbiAgICBsZXQgYXR0cjFcbiAgICBsZXQgYXR0cjJcbiAgICBsZXQgYXR0ckxlbmd0aFxuICAgIGxldCBwb3NcbiAgICBsZXQgaVxuXG4gICAgaWYgKHQxLnRhZyAhPT0gdDIudGFnKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLnJlcGxhY2VFbGVtZW50KVxuICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLm9sZFZhbHVlLCB0MSlcbiAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5uZXdWYWx1ZSwgY2xvbmVPYmoodDIpKVxuICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZSlcbiAgICAgIF1cbiAgICB9XG5cbiAgICBsZXQgdDFDaGlsZHJlbiA9IHQxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG4gICAgbGV0IHQyQ2hpbGRyZW4gPSB0Mi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5tYXhDaGlsZENvdW50ICYmXG4gICAgICB0MUNoaWxkcmVuICYmXG4gICAgICB0MkNoaWxkcmVuICYmXG4gICAgICB0MUNoaWxkcmVuLmxlbmd0aCA+IHRoaXMubWF4Q2hpbGRDb3VudCAmJlxuICAgICAgdDJDaGlsZHJlbi5sZW5ndGggPiB0aGlzLm1heENoaWxkQ291bnRcbiAgICApIHtcbiAgICAgIGxldCBjaGlsZE5vZGVzTGVuZ3RoID0gdDFDaGlsZHJlbi5sZW5ndGggPCB0MkNoaWxkcmVuLmxlbmd0aCA/IHQxQ2hpbGRyZW4ubGVuZ3RoIDogdDJDaGlsZHJlbi5sZW5ndGhcbiAgICAgIGxldCBjaGlsZERpZmZDb3VudCA9IDBcbiAgICAgIGxldCBqID0gMFxuICAgICAgd2hpbGUgKGNoaWxkRGlmZkNvdW50IDwgdGhpcy5tYXhDaGlsZENvdW50RGlmZkNvdW50ICYmIGogPCBjaGlsZE5vZGVzTGVuZ3RoKSB7XG4gICAgICAgIGlmICghaXNFcXVhbCh0MUNoaWxkcmVuW2pdLCB0MkNoaWxkcmVuW2pdKSkge1xuICAgICAgICAgIGNoaWxkRGlmZkNvdW50KytcbiAgICAgICAgfVxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZERpZmZDb3VudCA9PT0gdGhpcy5tYXhDaGlsZENvdW50RGlmZkNvdW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLnJlcGxhY2VFbGVtZW50KVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMub2xkVmFsdWUsIGNsb25lT2JqKHQxKSlcbiAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLm5ld1ZhbHVlLCBjbG9uZU9iaih0MikpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUpXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyMSA9IHQxLmF0dHJzID8gT2JqZWN0LmtleXModDEuYXR0cnMpLnNvcnQoKSA6IFtdXG4gICAgYXR0cjIgPSB0Mi5hdHRycyA/IE9iamVjdC5rZXlzKHQyLmF0dHJzKS5zb3J0KCkgOiBbXVxuXG4gICAgYXR0ckxlbmd0aCA9IGF0dHIxLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHIgPSBhdHRyMVtpXVxuICAgICAgcG9zID0gYXR0cjIuaW5kZXhPZihhdHRyKVxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVtb3ZlQXR0cmlidXRlKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMubmFtZSwgYXR0cilcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cjIuc3BsaWNlKHBvcywgMSlcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwodDEuYXR0cnNbYXR0cl0sIHQyLmF0dHJzW2F0dHJdKSkge1xuICAgICAgICAgIGRpZmZzLnB1c2goXG4gICAgICAgICAgICBuZXcgRGlmZigpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5tb2RpZnlBdHRyaWJ1dGUpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZSlcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMubmFtZSwgYXR0cilcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMub2xkVmFsdWUsIHQxLmF0dHJzW2F0dHJdKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5uZXdWYWx1ZSwgdDIuYXR0cnNbYXR0cl0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0ckxlbmd0aCA9IGF0dHIyLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHIgPSBhdHRyMltpXVxuICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5hZGRBdHRyaWJ1dGUpXG4gICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlKVxuICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLm5hbWUsIGF0dHIpXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmZzXG4gIH1cbiAgZmluZElubmVyRGlmZih0MTogSVNpbXBsaWZpZWROb2RlLCB0MjogSVNpbXBsaWZpZWROb2RlLCByb3V0ZTogbnVtYmVyW10pOiBEaWZmW10ge1xuICAgIGxldCBzdWJ0cmVlcyA9IHQxLmNoaWxkcmVuICYmIHQyLmNoaWxkcmVuID8gbWFya1N1YlRyZWVzKHQxLCB0MikgOiBbXVxuICAgIGxldCB0MUNoaWxkTm9kZXMgPSB0MS5jaGlsZHJlbiA/IHQxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpIDogW11cbiAgICBsZXQgdDJDaGlsZE5vZGVzID0gdDIuY2hpbGRyZW4gPyB0Mi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKSA6IFtdXG4gICAgbGV0IGNoaWxkTm9kZXNMZW5ndGhEaWZmZXJlbmNlXG4gICAgbGV0IGRpZmZzOiBEaWZmW10gPSBbXVxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbGFzdFxuICAgIGxldCBlMVxuICAgIGxldCBlMlxuICAgIGxldCBpXG5cbiAgICBpZiAoc3VidHJlZXMubGVuZ3RoID4gMCkge1xuICAgICAgLyogT25lIG9yIG1vcmUgZ3JvdXBzIGhhdmUgYmVlbiBpZGVudGlmaWVkIGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0MVxuICAgICAgICogYW5kIHQyLlxuICAgICAgICovXG4gICAgICBkaWZmcyA9IHRoaXMuYXR0ZW1wdEdyb3VwUmVsb2NhdGlvbih0MSwgdDIsIHN1YnRyZWVzLCByb3V0ZSlcbiAgICAgIGlmIChkaWZmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIDAgb3IgMSBncm91cHMgb2Ygc2ltaWxhciBjaGlsZCBub2RlcyBoYXZlIGJlZW4gZm91bmRcbiAgICAgKiBmb3IgdDEgYW5kIHQyLiAxIElmIHRoZXJlIGlzIDEsIGl0IGNvdWxkIGJlIGEgc2lnbiB0aGF0IHRoZVxuICAgICAqIGNvbnRlbnRzIGFyZSB0aGUgc2FtZS4gV2hlbiB0aGUgbnVtYmVyIG9mIGdyb3VwcyBpcyBiZWxvdyAyLFxuICAgICAqIHQxIGFuZCB0MiBhcmUgbWFkZSB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgZWFjaCBvZiB0aGVcbiAgICAgKiBwYWlycyBvZiBjaGlsZCBub2RlcyBhcmUgZGlmZmVkLlxuICAgICAqL1xuXG4gICAgbGFzdCA9IE1hdGgubWF4KHQxQ2hpbGROb2Rlcy5sZW5ndGgsIHQyQ2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgaWYgKHQxQ2hpbGROb2Rlcy5sZW5ndGggIT09IHQyQ2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGNoaWxkTm9kZXNMZW5ndGhEaWZmZXJlbmNlID0gdHJ1ZVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXN0OyBpICs9IDEpIHtcbiAgICAgIGUxID0gdDFDaGlsZE5vZGVzW2ldXG4gICAgICBlMiA9IHQyQ2hpbGROb2Rlc1tpXVxuXG4gICAgICBpZiAoY2hpbGROb2Rlc0xlbmd0aERpZmZlcmVuY2UpIHtcbiAgICAgICAgLyogdDEgYW5kIHQyIGhhdmUgZGlmZmVyZW50IGFtb3VudHMgb2YgY2hpbGRyZW4uIEFkZFxuICAgICAgICAgKiBhbmQgcmVtb3ZlIGFzIG5lY2Vzc2FyeSB0byBvYnRhaW4gdGhlIHNhbWUgbGVuZ3RoICovXG4gICAgICAgIGlmIChlMSAmJiAhZTIpIHtcbiAgICAgICAgICBkaWZmcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVtb3ZlRWxlbWVudClcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlLmNvbmNhdChpbmRleCkpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmVsZW1lbnQsIGUxKVxuICAgICAgICAgIClcbiAgICAgICAgICBpbmRleCAtPSAxXG4gICAgICAgIH0gZWxzZSBpZiAoZTIgJiYgIWUxKSB7XG4gICAgICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLmFkZEVsZW1lbnQpXG4gICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZS5jb25jYXQoaW5kZXgpKVxuICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5lbGVtZW50LCBjbG9uZU9iaihlMikpXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBXZSBhcmUgbm93IGd1YXJhbnRlZWQgdGhhdCBjaGlsZHJlbiBlMSBhbmQgZTIgZXhpc3QsXG4gICAgICAgKiBhbmQgdGhhdCB0aGV5IGNhbiBiZSBkaWZmZWQuXG4gICAgICAgKi9cbiAgICAgIC8qIERpZmZzIGluIGNoaWxkIG5vZGVzIHNob3VsZCBub3QgYWZmZWN0IHRoZSBwYXJlbnQgbm9kZSxcbiAgICAgICAqIHNvIHdlIGxldCB0aGVzZSBkaWZmcyBiZSBzdWJtaXR0ZWQgdG9nZXRoZXIgd2l0aCBvdGhlclxuICAgICAgICogZGlmZnMuXG4gICAgICAgKi9cblxuICAgICAgaWYgKGUxICYmIGUyKSB7XG4gICAgICAgIGRpZmZzID0gZGlmZnMuY29uY2F0KHRoaXMuZmluZE5leHREaWZmKGUxLCBlMiwgcm91dGUuY29uY2F0KGluZGV4KSkpXG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IDFcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgIDsodDEgYXMgYW55KVtpbm5lckRvbmVdID0gdHJ1ZVxuICAgIHJldHVybiBkaWZmc1xuICB9XG5cbiAgYXR0ZW1wdEdyb3VwUmVsb2NhdGlvbih0MTogSVNpbXBsaWZpZWROb2RlLCB0MjogSVNpbXBsaWZpZWROb2RlLCBzdWJ0cmVlczogU3Vic2V0TWFwcGluZ1tdLCByb3V0ZTogbnVtYmVyW10pOiBEaWZmW10ge1xuICAgIC8qIEVpdGhlciB0MS5jaGlsZHJlbiBhbmQgdDIuY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIG9yXG4gICAgICogdGhlcmUgYXJlIGF0IGxlYXN0IHR3byBncm91cHMgb2Ygc2ltaWxhciBlbGVtZW50cyBjYW4gYmUgZm91bmQuXG4gICAgICogYXR0ZW1wdHMgYXJlIG1hZGUgYXQgZXF1YWxpemluZyB0MSB3aXRoIHQyLiBGaXJzdCBhbGwgaW5pdGlhbFxuICAgICAqIGVsZW1lbnRzIHdpdGggbm8gZ3JvdXAgYWZmaWxpYXRpb24gKGdhcHM9dHJ1ZSkgYXJlIHJlbW92ZWQgKGlmXG4gICAgICogb25seSBpbiB0MSkgb3IgYWRkZWQgKGlmIG9ubHkgaW4gdDIpLiBUaGVuIHRoZSBjcmVhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogcmVsb2NhdGlvbiBkaWZmIGlzIGF0dGVtcHRlZC5cbiAgICAqL1xuXG4gICAgbGV0IGdhcEluZm9ybWF0aW9uID0gZ2V0R2FwSW5mb3JtYXRpb24odDEsIHQyLCBzdWJ0cmVlcylcbiAgICBsZXQgZ2FwczEgPSBnYXBJbmZvcm1hdGlvbi5nYXBzMVxuICAgIGxldCBnYXBzMiA9IGdhcEluZm9ybWF0aW9uLmdhcHMyXG4gICAgbGV0IHNob3J0ZXN0ID0gTWF0aC5taW4oZ2FwczEubGVuZ3RoLCBnYXBzMi5sZW5ndGgpXG4gICAgbGV0IGRlc3RpbmF0aW9uRGlmZmVyZW50OiBib29sZWFuXG4gICAgbGV0IHRvR3JvdXBcbiAgICBsZXQgZ3JvdXBcbiAgICBsZXQgbm9kZVxuICAgIGxldCBkaWZmczogRGlmZltdID0gW11cbiAgICBsZXQgaW5kZXgxXG4gICAgbGV0IGluZGV4MlxuICAgIGxldCBqXG5cbiAgICBsZXQgdDFDaGlsZHJlbiA9IHQxLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIYXZpbmdUYWcpXG4gICAgbGV0IHQyQ2hpbGRyZW4gPSB0Mi5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuXG4gICAgZm9yIChpbmRleDIgPSAwLCBpbmRleDEgPSAwOyBpbmRleDIgPCBzaG9ydGVzdDsgaW5kZXgxICs9IDEsIGluZGV4MiArPSAxKSB7XG4gICAgICBpZiAoZ2FwczFbaW5kZXgyXSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gdDFDaGlsZHJlbltpbmRleDFdXG4gICAgICAgIGRpZmZzLnB1c2goXG4gICAgICAgICAgbmV3IERpZmYoKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuYWN0aW9uLCBBY3Rpb25zLnJlbW92ZUVsZW1lbnQpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5yb3V0ZSwgcm91dGUuY29uY2F0KGluZGV4MikpXG4gICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5lbGVtZW50LCBjbG9uZU9iaihub2RlKSlcbiAgICAgICAgKVxuICAgICAgICBnYXBzMS5zcGxpY2UoaW5kZXgyLCAxKVxuICAgICAgICBzaG9ydGVzdCA9IE1hdGgubWluKGdhcHMxLmxlbmd0aCwgZ2FwczIubGVuZ3RoKVxuICAgICAgICBpbmRleDIgLT0gMVxuICAgICAgfSBlbHNlIGlmIChnYXBzMltpbmRleDJdID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSB0MkNoaWxkcmVuW2luZGV4Ml1cblxuICAgICAgICBkaWZmcy5wdXNoKFxuICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmFjdGlvbiwgQWN0aW9ucy5hZGRFbGVtZW50KVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMucm91dGUsIHJvdXRlLmNvbmNhdChpbmRleDIpKVxuICAgICAgICAgICAgLnNldFZhbHVlKEFjdGlvbnMuZWxlbWVudCwgY2xvbmVPYmoobm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgZ2FwczEuc3BsaWNlKGluZGV4MiwgMCwgdHJ1ZSlcbiAgICAgICAgc2hvcnRlc3QgPSBNYXRoLm1pbihnYXBzMS5sZW5ndGgsIGdhcHMyLmxlbmd0aClcbiAgICAgICAgaW5kZXgxIC09IDFcbiAgICAgIH0gZWxzZSBpZiAoZ2FwczFbaW5kZXgyXSAhPT0gZ2FwczJbaW5kZXgyXSkge1xuICAgICAgICBpZiAoZGlmZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBkaWZmc1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyb3VwIHJlbG9jYXRpb25cbiAgICAgICAgZ3JvdXAgPSBzdWJ0cmVlc1tnYXBzMVtpbmRleDJdIGFzIG51bWJlcl1cbiAgICAgICAgdG9Hcm91cCA9IE1hdGgubWluKGdyb3VwLm5ld1ZhbHVlLCB0MUNoaWxkcmVuLmxlbmd0aCAtIGdyb3VwLmxlbmd0aClcbiAgICAgICAgaWYgKHRvR3JvdXAgIT09IGdyb3VwLm9sZFZhbHVlKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBkZXN0aW5hdGlvbiBub2RlcyBhcmUgZGlmZmVyZW50IHRoYW4gb3JpZ2luYXRpbmcgb25lcy5cbiAgICAgICAgICBkZXN0aW5hdGlvbkRpZmZlcmVudCA9IGZhbHNlXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdyb3VwLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIXJvdWdobHlFcXVhbCh0MUNoaWxkcmVuW3RvR3JvdXAgKyBqXSwgdDFDaGlsZHJlbltncm91cC5vbGRWYWx1ZSArIGpdLCB7fSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uRGlmZmVyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25EaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIG5ldyBEaWZmKClcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5hY3Rpb24sIEFjdGlvbnMucmVsb2NhdGVHcm91cClcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQWN0aW9ucy5ncm91cExlbmd0aCwgZ3JvdXAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLmZyb20sIGdyb3VwLm9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnRvLCB0b0dyb3VwKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBY3Rpb25zLnJvdXRlLCByb3V0ZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzXG4gIH1cblxuICAvLyA9PT09PSBBcHBseSBhIHZpcnR1YWwgZGlmZiA9PT09PVxuXG4gIC8qKiBQYXRjaGVzIGEgdmlydHVhbCB0cmVlIHVzaW5nIGEgbGlzdCBvZiBkaWZmcyAqL1xuICBhcHBseVZpcnR1YWwodHJlZTogSVNpbXBsaWZpZWROb2RlLCBkaWZmczogSURpZmZbXSkge1xuICAgIGxldCBsZW5ndGggPSBkaWZmcy5sZW5ndGhcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZGlmZiA9IGRpZmZzW2ldXG4gICAgICB0aGlzLmFwcGx5VmlydHVhbERpZmYodHJlZSwgZGlmZilcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKiBHZXRzIGEgbm9kZSBpbiB0aGUgdmlydHVhbCB0cmVlIGJ5IGEgcm91dGUgKi9cbiAgZ2V0RnJvbVZpcnR1YWxSb3V0ZSh0cmVlOiBJU2ltcGxpZmllZE5vZGUsIHJvdXRlOiBudW1iZXJbXSkge1xuICAgIGxldCBub2RlID0gdHJlZVxuICAgIGxldCBwYXJlbnROb2RlOiBJU2ltcGxpZmllZE5vZGUgfCB2b2lkID0gdW5kZWZpbmVkXG4gICAgbGV0IG5vZGVJbmRleDogbnVtYmVyID0gMFxuXG4gICAgbGV0IG5ld1JvdXRlID0gcm91dGUuc2xpY2UoKVxuXG4gICAgd2hpbGUgKG5ld1JvdXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNoID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoZmlsdGVySGF2aW5nVGFnKVxuXG4gICAgICBpZiAoIWNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIG5vZGVJbmRleCA9IChuZXdSb3V0ZS5zaGlmdCgpIGFzIGFueSkgYXMgbnVtYmVyXG4gICAgICBwYXJlbnROb2RlID0gbm9kZVxuICAgICAgbm9kZSA9IGNoW25vZGVJbmRleF1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZSxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICBub2RlSW5kZXhcbiAgICB9XG4gIH1cblxuICAvKiogUGF0Y2hlcyBhIHZpcnR1YWwgdHJlZSB1c2luZyBhIGRpZmYgKi9cbiAgYXBwbHlWaXJ0dWFsRGlmZih0cmVlOiBJU2ltcGxpZmllZE5vZGUsIGRpZmY6IElEaWZmKSB7XG4gICAgbGV0IHJvdXRlSW5mbyA9IHRoaXMuZ2V0RnJvbVZpcnR1YWxSb3V0ZSh0cmVlLCBkaWZmW0FjdGlvbnMucm91dGVdKVxuICAgIGxldCBub2RlID0gcm91dGVJbmZvICYmIHJvdXRlSW5mby5ub2RlXG4gICAgbGV0IHBhcmVudE5vZGU6IElTaW1wbGlmaWVkTm9kZSB8IHZvaWQgPSByb3V0ZUluZm8gJiYgcm91dGVJbmZvLnBhcmVudE5vZGVcbiAgICBsZXQgbm9kZUluZGV4ID0gKHJvdXRlSW5mbyAmJiByb3V0ZUluZm8ubm9kZUluZGV4KSB8fCAwXG4gICAgbGV0IG5ld05vZGU6IElTaW1wbGlmaWVkTm9kZSB8IHZvaWQgPSB1bmRlZmluZWRcblxuICAgIHN3aXRjaCAoZGlmZltBY3Rpb25zLmFjdGlvbl0pIHtcbiAgICAgIGNhc2UgQWN0aW9ucy5hZGRFbGVtZW50OlxuICAgICAgICBjb25zdCByb3V0ZSA9IGRpZmZbQWN0aW9ucy5yb3V0ZV0uc2xpY2UoKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdXRlLnBvcCgpXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEZyb21WaXJ0dWFsUm91dGUodHJlZSwgcm91dGUpXG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgbm9kZSA9IHgubm9kZVxuICAgICAgICAgIG5ld05vZGUgPSBjbG9uZU9iaihkaWZmW0FjdGlvbnMuZWxlbWVudF0pXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIG5ld05vZGVbb3V0ZXJEb25lXSA9IHRydWVcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgbmV3Tm9kZVtpbm5lckRvbmVdID0gdHJ1ZVxuXG4gICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW5bcG9zaXRpb25dKSB7XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKHBvc2l0aW9uLCAwLCBuZXdOb2RlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEFjdGlvbnMuYWRkQXR0cmlidXRlOlxuICAgICAgICBpZiAoIW5vZGUpIHRocm93IG5ldyBSZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uKClcblxuICAgICAgICBpZiAoIW5vZGUuYXR0cnMpIHtcbiAgICAgICAgICBub2RlLmF0dHJzID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuYXR0cnNbZGlmZltBY3Rpb25zLm5hbWVdXSA9IGRpZmZbQWN0aW9ucy52YWx1ZV1cblxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBY3Rpb25zLm1vZGlmeUF0dHJpYnV0ZTpcbiAgICAgICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbigpXG5cbiAgICAgICAgbm9kZS5hdHRyc1tkaWZmW0FjdGlvbnMubmFtZV1dID0gZGlmZltBY3Rpb25zLm5ld1ZhbHVlXVxuXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIEFjdGlvbnMucmVtb3ZlQXR0cmlidXRlOlxuICAgICAgICBpZiAoIW5vZGUpIHRocm93IG5ldyBSZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uKClcblxuICAgICAgICBkZWxldGUgbm9kZS5hdHRyc1tkaWZmW0FjdGlvbnMubmFtZV1dXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQWN0aW9ucy5yZXBsYWNlRWxlbWVudDpcbiAgICAgICAgbmV3Tm9kZSA9IGNsb25lT2JqKGRpZmZbQWN0aW9ucy5uZXdWYWx1ZV0pXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbmV3Tm9kZVtvdXRlckRvbmVdID0gdHJ1ZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5ld05vZGVbaW5uZXJEb25lXSA9IHRydWVcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgbmV3Tm9kZSkge1xuICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5bbm9kZUluZGV4XSA9IG5ld05vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1Z2dlclxuICAgICAgICAgIHRocm93IG5ldyBSZXBsYWNlV2hvbGVUcmVlRXhjZXB0aW9uKClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBY3Rpb25zLnJlbG9jYXRlR3JvdXA6XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUFycmF5ID0gbm9kZS5jaGlsZHJlbi5zcGxpY2UoZGlmZltBY3Rpb25zLmZyb21dLCBkaWZmW0FjdGlvbnMuZ3JvdXBMZW5ndGhdKS5yZXZlcnNlKClcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoZGlmZltBY3Rpb25zLnRvXSwgMCwgbm9kZUFycmF5W2ldKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBY3Rpb25zLnJlbW92ZUVsZW1lbnQ6XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkgdGhyb3cgbmV3IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24oKVxuICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnNwbGljZShub2RlSW5kZXgsIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZygndW5rbm93biBhY3Rpb24nKVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/vdom.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/utils/deepEqual.js":
/*!**************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/utils/deepEqual.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hasOwn = Object.prototype.hasOwnProperty;\nfunction deepEqual(objA, objB) {\n    if (objA === objB) {\n        return true;\n    }\n    let typeA = typeof objA;\n    let typeB = typeof objB;\n    if (typeA !== typeB)\n        return false;\n    if (typeA !== 'object' || typeB !== 'object')\n        return objA === objB;\n    if ((objA === null) !== (objB === null))\n        return false;\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    // Test for A's keys different from B.\n    for (let i = 0; i < keysA.length; i++) {\n        if (!hasOwn.call(objB, keysA[i]) || !deepEqual(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.deepEqual = deepEqual;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVlcEVxdWFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2RlZXBFcXVhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFBO0FBRTlDLFNBQWdCLFNBQVMsQ0FBQyxJQUFTLEVBQUUsSUFBUztJQUM1QyxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUE7S0FDWjtJQUVELElBQUksS0FBSyxHQUFHLE9BQU8sSUFBSSxDQUFBO0lBQ3ZCLElBQUksS0FBSyxHQUFHLE9BQU8sSUFBSSxDQUFBO0lBRXZCLElBQUksS0FBSyxLQUFLLEtBQUs7UUFBRSxPQUFPLEtBQUssQ0FBQTtJQUVqQyxJQUFJLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLFFBQVE7UUFBRSxPQUFPLElBQUksS0FBSyxJQUFJLENBQUE7SUFFbEUsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM7UUFBRSxPQUFPLEtBQUssQ0FBQTtJQUVyRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQy9CLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7SUFFL0IsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDakMsT0FBTyxLQUFLLENBQUE7S0FDYjtJQUVELHNDQUFzQztJQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQzlFLE9BQU8sS0FBSyxDQUFBO1NBQ2I7S0FDRjtJQUVELE9BQU8sSUFBSSxDQUFBO0FBQ2IsQ0FBQztBQTdCRCw4QkE2QkMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXF1YWwob2JqQTogYW55LCBvYmpCOiBhbnkpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IHR5cGVBID0gdHlwZW9mIG9iakFcbiAgbGV0IHR5cGVCID0gdHlwZW9mIG9iakJcblxuICBpZiAodHlwZUEgIT09IHR5cGVCKSByZXR1cm4gZmFsc2VcblxuICBpZiAodHlwZUEgIT09ICdvYmplY3QnIHx8IHR5cGVCICE9PSAnb2JqZWN0JykgcmV0dXJuIG9iakEgPT09IG9iakJcblxuICBpZiAoKG9iakEgPT09IG51bGwpICE9PSAob2JqQiA9PT0gbnVsbCkpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSlcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKVxuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFkZWVwRXF1YWwob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/utils/deepEqual.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/utils/future.js":
/*!***********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/utils/future.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction future() {\n    let resolver = (x) => {\n        throw new Error('Error initilizing mutex');\n    };\n    let rejecter = (x) => {\n        throw x;\n    };\n    const promise = new Promise((ok, err) => {\n        resolver = ok;\n        rejecter = err;\n    });\n    promise.then(() => (promise.isPending = false));\n    promise.catch(() => (promise.isPending = false));\n    promise.resolve = resolver;\n    promise.reject = rejecter;\n    promise.isPending = true;\n    return promise;\n}\nexports.future = future;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnV0dXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2Z1dHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQU1BLFNBQWdCLE1BQU07SUFDcEIsSUFBSSxRQUFRLEdBQW1CLENBQUMsQ0FBSSxFQUFFLEVBQUU7UUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO0lBQzVDLENBQUMsQ0FBQTtJQUNELElBQUksUUFBUSxHQUF1QixDQUFDLENBQVEsRUFBRSxFQUFFO1FBQzlDLE1BQU0sQ0FBQyxDQUFBO0lBQ1QsQ0FBQyxDQUFBO0lBRUQsTUFBTSxPQUFPLEdBQVEsSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDM0MsUUFBUSxHQUFHLEVBQUUsQ0FBQTtRQUNiLFFBQVEsR0FBRyxHQUFHLENBQUE7SUFDaEIsQ0FBQyxDQUFDLENBQUE7SUFFRixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFBO0lBQy9DLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFFaEQsT0FBTyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUE7SUFDMUIsT0FBTyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUE7SUFFekIsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUE7SUFFeEIsT0FBTyxPQUFxQixDQUFBO0FBQzlCLENBQUM7QUF0QkQsd0JBc0JDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgSUZ1dHVyZTxUPiA9IFByb21pc2U8VD4gJiB7XG4gIHJlc29sdmU6ICh4OiBUKSA9PiB2b2lkXG4gIHJlamVjdDogKHg6IEVycm9yKSA9PiB2b2lkXG4gIGlzUGVuZGluZzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnV0dXJlPFQgPSBhbnk+KCk6IElGdXR1cmU8VD4ge1xuICBsZXQgcmVzb2x2ZXI6ICh4OiBUKSA9PiB2b2lkID0gKHg6IFQpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGluaXRpbGl6aW5nIG11dGV4JylcbiAgfVxuICBsZXQgcmVqZWN0ZXI6ICh4OiBFcnJvcikgPT4gdm9pZCA9ICh4OiBFcnJvcikgPT4ge1xuICAgIHRocm93IHhcbiAgfVxuXG4gIGNvbnN0IHByb21pc2U6IGFueSA9IG5ldyBQcm9taXNlKChvaywgZXJyKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSBva1xuICAgIHJlamVjdGVyID0gZXJyXG4gIH0pXG5cbiAgcHJvbWlzZS50aGVuKCgpID0+IChwcm9taXNlLmlzUGVuZGluZyA9IGZhbHNlKSlcbiAgcHJvbWlzZS5jYXRjaCgoKSA9PiAocHJvbWlzZS5pc1BlbmRpbmcgPSBmYWxzZSkpXG5cbiAgcHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZXJcbiAgcHJvbWlzZS5yZWplY3QgPSByZWplY3RlclxuXG4gIHByb21pc2UuaXNQZW5kaW5nID0gdHJ1ZVxuXG4gIHJldHVybiBwcm9taXNlIGFzIElGdXR1cmU8VD5cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/utils/future.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/EventSubscriber.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/EventSubscriber.js ***!
  \*********************************************************************/
/*! exports provided: EventSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventSubscriber\", function() { return EventSubscriber; });\n/* harmony import */ var _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n\nclass EventSubscriber extends _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"] {\n    constructor(component) {\n        super();\n        this.component = component;\n        component.onSubscribedEvent((data) => {\n            super.emit(data.event, data);\n        });\n    }\n    on(event, handler) {\n        if (this.getEventBindings(event).length === 0) {\n            this.component.subscribe(event).catch(e => this.emit('error', e));\n        }\n        return super.on.apply(this, arguments);\n    }\n    off(event) {\n        let theEventToValidate = null;\n        const offResult = super.off.apply(this, arguments);\n        if (typeof event === 'string') {\n            theEventToValidate = event;\n        }\n        else if (event instanceof _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcherBinding\"]) {\n            event = event.event;\n        }\n        if (theEventToValidate !== null) {\n            if (this.getEventBindings(theEventToValidate).length === 0) {\n                this.component.unsubscribe(theEventToValidate).catch(e => this.emit('error', e));\n            }\n        }\n        return offResult;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnRTdWJzY3JpYmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NsaWVudC9FdmVudFN1YnNjcmliZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFBO0FBR3hGLE1BQU0sT0FBTyxlQUFnQixTQUFRLGVBQWU7SUFDbEQsWUFBb0IsU0FBMkI7UUFDN0MsS0FBSyxFQUFFLENBQUE7UUFEVyxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUc3QyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRTtZQUN4QyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFDOUIsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBU0QsRUFBRSxDQUFDLEtBQWEsRUFBRSxPQUFZO1FBQzVCLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNsRTtRQUNELE9BQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFBO0lBQ3hDLENBQUM7SUFPRCxHQUFHLENBQUMsS0FBaUQ7UUFDbkQsSUFBSSxrQkFBa0IsR0FBa0IsSUFBSSxDQUFBO1FBQzVDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtRQUVsRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixrQkFBa0IsR0FBRyxLQUFLLENBQUE7U0FDM0I7YUFBTSxJQUFJLEtBQUssWUFBWSxzQkFBc0IsRUFBRTtZQUNsRCxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQTtTQUNwQjtRQUVELElBQUksa0JBQWtCLEtBQUssSUFBSSxFQUFFO1lBQy9CLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFJMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2pGO1NBQ0Y7UUFFRCxPQUFPLFNBQVMsQ0FBQTtJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfSBmcm9tICcuLi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5pbXBvcnQgeyBJU3Vic2NyaWJhYmxlQVBJIH0gZnJvbSAnLi4vaG9zdC9BUEknXG5cbmV4cG9ydCBjbGFzcyBFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbXBvbmVudDogSVN1YnNjcmliYWJsZUFQSSkge1xuICAgIHN1cGVyKClcblxuICAgIGNvbXBvbmVudC5vblN1YnNjcmliZWRFdmVudCgoZGF0YTogYW55KSA9PiB7XG4gICAgICBzdXBlci5lbWl0KGRhdGEuZXZlbnQsIGRhdGEpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgbGlzdGVuZXIgZm9yIGFuIHNwZWNpZmljIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBoYW5kbGVyIEEgaGFuZGxlciB3aGljaCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSBldmVudCBpcyByZWNlaXZlZFxuICAgKi9cbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCwgb25jZT86IGJvb2xlYW4pOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nXG4gIG9uKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBhbnksIG9uY2U/OiBib29sZWFuKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbihldmVudDogc3RyaW5nLCBoYW5kbGVyOiBhbnkpIHtcbiAgICBpZiAodGhpcy5nZXRFdmVudEJpbmRpbmdzKGV2ZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnN1YnNjcmliZShldmVudCkuY2F0Y2goZSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZSkpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZvciBhbiBzcGVjaWZpYyBldmVudFxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBiaW5kaW5nIEEgcmVmZXJlbmNlIHRvIGEgYmluZGluZyByZXR1cm5lZCBieSBhIHByZXZpb3VzIGBhZGRFdmVudExpc3RlbmVyYCBjYWxsXG4gICAqL1xuICBvZmYoZXZlbnQ6IHN0cmluZyB8IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfCBGdW5jdGlvbikge1xuICAgIGxldCB0aGVFdmVudFRvVmFsaWRhdGU6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgY29uc3Qgb2ZmUmVzdWx0ID0gc3VwZXIub2ZmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGVFdmVudFRvVmFsaWRhdGUgPSBldmVudFxuICAgIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gICAgICBldmVudCA9IGV2ZW50LmV2ZW50XG4gICAgfVxuXG4gICAgaWYgKHRoZUV2ZW50VG9WYWxpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuZ2V0RXZlbnRCaW5kaW5ncyh0aGVFdmVudFRvVmFsaWRhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVtb3ZpbmcgdGhlIGxhc3QgZXZlbnQgbGlzdGVuZXIsIHJlbW92ZSBpdCBhbHNvIGZyb20gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyB0aGlzIHdpbGwga2VlcCBsaXN0ZW5lcnMgdW5yZWxhdGVkIHRvIHRoZSBjb21wb25lbnQgaW50YWN0XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnQudW5zdWJzY3JpYmUodGhlRXZlbnRUb1ZhbGlkYXRlKS5jYXRjaChlID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2ZmUmVzdWx0XG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/EventSubscriber.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/Script.js":
/*!************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/Script.js ***!
  \************************************************************/
/*! exports provided: inject, getInjectedAPIs, Script */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return inject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInjectedAPIs\", function() { return getInjectedAPIs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Script\", function() { return Script; });\n/* harmony import */ var _common_json_rpc_Client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/json-rpc/Client */ \"./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js\");\n/* harmony import */ var _common_json_rpc_API__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/json-rpc/API */ \"./node_modules/decentraland-rpc/lib/common/json-rpc/API.js\");\n/* harmony import */ var _common_core_isPromiseLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/core/isPromiseLike */ \"./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js\");\n\n\n\nconst loadAPIsNotificationName = 'LoadComponents';\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\nconst injectedAPISymbol = hasSymbol ? Symbol('injectedAPIs') : 0xfea0;\nfunction inject(apiName) {\n    if (apiName !== undefined && !apiName) {\n        throw new TypeError('API name cannot be null / empty');\n    }\n    return function (target, propertyKey) {\n        if (typeof propertyKey === 'string') {\n            getInjectedAPIs(target).set(propertyKey, apiName || propertyKey);\n        }\n        else\n            throw new TypeError('Cannot inject APIs with non-string names');\n    };\n}\nfunction getInjectedAPIs(instance) {\n    const instanceAny = instance;\n    instanceAny[injectedAPISymbol] = instanceAny[injectedAPISymbol] || new Map();\n    return instanceAny[injectedAPISymbol];\n}\nasync function _injectAPIs(target) {\n    const injectedMap = getInjectedAPIs(target);\n    if (injectedMap.size === 0)\n        return;\n    await target.loadAPIs(Array.from(injectedMap.values()));\n    injectedMap.forEach(function (apiName, property) {\n        target[property] = target.loadedAPIs[apiName];\n    });\n}\nclass Script extends _common_json_rpc_Client__WEBPACK_IMPORTED_MODULE_0__[\"Client\"] {\n    constructor(transport, opt) {\n        super(opt);\n        this.transport = transport;\n        this.loadedAPIs = {};\n        this.started = false;\n        if (transport.onError) {\n            transport.onError(e => {\n                this.emit('error', e);\n            });\n        }\n        if (transport.onClose) {\n            transport.onClose(() => {\n                this.emit('transportClosed');\n            });\n        }\n        transport.onMessage(message => {\n            this.processMessage(message);\n        });\n        if (transport.onConnect) {\n            transport.onConnect(() => {\n                this.didConnect();\n            });\n        }\n        else {\n            this.didConnect();\n        }\n    }\n    sendMessage(message) {\n        this.transport.sendMessage(message);\n    }\n    async loadAPIs(apiName) {\n        const loadedKeys = Object.keys(this.loadedAPIs);\n        const keysToRequest = apiName.filter(function ($) {\n            return !loadedKeys.includes($);\n        });\n        if (keysToRequest.length) {\n            await this.call(loadAPIsNotificationName, [keysToRequest]);\n            keysToRequest.forEach(async (apiName) => {\n                this.loadedAPIs[apiName] = Object(_common_json_rpc_API__WEBPACK_IMPORTED_MODULE_1__[\"getApi\"])(this, apiName);\n            });\n        }\n        return this.loadedAPIs;\n    }\n    didConnect() {\n        const injection = _injectAPIs(this);\n        super.didConnect();\n        injection\n            .then(() => {\n            if (this.systemDidEnable && !this.started) {\n                this.started = true;\n                try {\n                    const r = this.systemDidEnable();\n                    if (r && Object(_common_core_isPromiseLike__WEBPACK_IMPORTED_MODULE_2__[\"isPromiseLike\"])(r)) {\n                        r.catch(e => this.emit('error', e));\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            }\n        })\n            .catch(e => this.emit('error', e));\n    }\n}\nScript.inject = inject;\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NsaWVudC9TY3JpcHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQ2xELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQTtBQUUvQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUE7QUFHNUQsTUFBTSx3QkFBd0IsR0FBRyxnQkFBZ0IsQ0FBQTtBQU1qRCxNQUFNLFNBQVMsR0FBRyxPQUFPLE1BQU0sS0FBSyxVQUFVLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQTtBQUU1RCxNQUFNLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUE7QUFZckUsTUFBTSxVQUFVLE1BQU0sQ0FBQyxPQUFnQjtJQUNyQyxJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDckMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFBO0tBQ3ZEO0lBQ0QsT0FBTyxVQUEyQixNQUFTLEVBQUUsV0FBb0I7UUFDL0QsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7WUFDbkMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFBO1NBQ2pFOztZQUFNLE1BQU0sSUFBSSxTQUFTLENBQUMsMENBQTBDLENBQUMsQ0FBQTtJQUN4RSxDQUFDLENBQUE7QUFDSCxDQUFDO0FBTUQsTUFBTSxVQUFVLGVBQWUsQ0FBbUIsUUFBVztJQUMzRCxNQUFNLFdBQVcsR0FBUSxRQUFRLENBQUE7SUFDakMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLElBQUksSUFB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S0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFBO1FBRWxCLFNBQVM7YUFDTixJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1QsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUE7Z0JBQ25CLElBQUk7b0JBQ0YsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFBO29CQUNoQyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQ3pCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO3FCQUNwQztpQkFDRjtnQkFBQyxPQUFPLENBQUMsRUFBRTtvQkFDVixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQTtpQkFDdEI7YUFDRjtRQUNILENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7SUFDdEMsQ0FBQzs7QUFwRk0sYUFBTSxHQUFHLE1BQU0sQ0FBQTtBQXVGeEIsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSAnLi4vY29tbW9uL2pzb24tcnBjL0NsaWVudCdcbmltcG9ydCB7IGdldEFwaSB9IGZyb20gJy4uL2NvbW1vbi9qc29uLXJwYy9BUEknXG5pbXBvcnQgeyBJTG9nT3B0cywgU2NyaXB0aW5nVHJhbnNwb3J0IH0gZnJvbSAnLi4vY29tbW9uL2pzb24tcnBjL3R5cGVzJ1xuaW1wb3J0IHsgaXNQcm9taXNlTGlrZSB9IGZyb20gJy4uL2NvbW1vbi9jb3JlL2lzUHJvbWlzZUxpa2UnXG5cbi8qKiB0aGlzIGlzIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIFNjcmlwdGluZ0hvc3QoKSAqL1xuY29uc3QgbG9hZEFQSXNOb3RpZmljYXRpb25OYW1lID0gJ0xvYWRDb21wb25lbnRzJ1xuXG4vLyBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuY29uc3QgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yXG5cbmNvbnN0IGluamVjdGVkQVBJU3ltYm9sID0gaGFzU3ltYm9sID8gU3ltYm9sKCdpbmplY3RlZEFQSXMnKSA6IDB4ZmVhMFxuXG5pbnRlcmZhY2UgU2NyaXB0IHtcbiAgc3lzdGVtRGlkRW5hYmxlPygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxufVxuXG5leHBvcnQgdHlwZSBBUEkgPSBhbnlcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRlY29yYXRlcyBwYXJhbWV0ZXJzIHRvIGxvYWQgQVBJc1xuICogQHBhcmFtIGFwaU5hbWUgbmFtZSBvZiB0aGUgQVBJIHRvIGxvYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdChhcGlOYW1lPzogc3RyaW5nKSB7XG4gIGlmIChhcGlOYW1lICE9PSB1bmRlZmluZWQgJiYgIWFwaU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBUEkgbmFtZSBjYW5ub3QgYmUgbnVsbCAvIGVtcHR5JylcbiAgfVxuICByZXR1cm4gZnVuY3Rpb248VCBleHRlbmRzIFNjcmlwdD4odGFyZ2V0OiBULCBwcm9wZXJ0eUtleToga2V5b2YgVCkge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHlLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBnZXRJbmplY3RlZEFQSXModGFyZ2V0KS5zZXQocHJvcGVydHlLZXksIGFwaU5hbWUgfHwgcHJvcGVydHlLZXkpXG4gICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbmplY3QgQVBJcyB3aXRoIG5vbi1zdHJpbmcgbmFtZXMnKVxuICB9XG59XG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIGluamVjdGVkIEFQSXMgb2YgYSBzY3JpcHRcbiAqIEBwYXJhbSBpbnN0YW5jZSBBIHNjcmlwdCB0byBnZXQgdGhlIEFQSXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluamVjdGVkQVBJczxUIGV4dGVuZHMgU2NyaXB0PihpbnN0YW5jZTogVCk6IE1hcDxrZXlvZiBULCBzdHJpbmc+IHtcbiAgY29uc3QgaW5zdGFuY2VBbnk6IGFueSA9IGluc3RhbmNlXG4gIGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXSA9IGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXSB8fCBuZXcgTWFwKClcbiAgcmV0dXJuIGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaW5qZWN0QVBJcyh0YXJnZXQ6IFNjcmlwdCkge1xuICBjb25zdCBpbmplY3RlZE1hcCA9IGdldEluamVjdGVkQVBJcyh0YXJnZXQpXG5cbiAgaWYgKGluamVjdGVkTWFwLnNpemUgPT09IDApIHJldHVyblxuXG4gIGF3YWl0IHRhcmdldC5sb2FkQVBJcyhBcnJheS5mcm9tKGluamVjdGVkTWFwLnZhbHVlcygpKSlcblxuICBpbmplY3RlZE1hcC5mb3JFYWNoKGZ1bmN0aW9uKGFwaU5hbWU6IHN0cmluZywgcHJvcGVydHkpIHtcbiAgICB0YXJnZXRbcHJvcGVydHldID0gdGFyZ2V0LmxvYWRlZEFQSXNbYXBpTmFtZV1cbiAgfSlcbn1cblxuY2xhc3MgU2NyaXB0IGV4dGVuZHMgQ2xpZW50IHtcbiAgc3RhdGljIGluamVjdCA9IGluamVjdFxuXG4gIGxvYWRlZEFQSXM6IHsgW2tleTogc3RyaW5nXTogQVBJIH0gPSB7fVxuXG4gIHByb3RlY3RlZCBzdGFydGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyYW5zcG9ydDogU2NyaXB0aW5nVHJhbnNwb3J0LCBvcHQ/OiBJTG9nT3B0cykge1xuICAgIHN1cGVyKG9wdClcblxuICAgIGlmICh0cmFuc3BvcnQub25FcnJvcikge1xuICAgICAgdHJhbnNwb3J0Lm9uRXJyb3IoZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHJhbnNwb3J0Lm9uQ2xvc2UpIHtcbiAgICAgIHRyYW5zcG9ydC5vbkNsb3NlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnRDbG9zZWQnKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0cmFuc3BvcnQub25NZXNzYWdlKG1lc3NhZ2UgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKVxuICAgIH0pXG5cbiAgICBpZiAodHJhbnNwb3J0Lm9uQ29ubmVjdCkge1xuICAgICAgdHJhbnNwb3J0Lm9uQ29ubmVjdCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlkQ29ubmVjdCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpZENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmRNZXNzYWdlKG1lc3NhZ2UpXG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIGdsb2JhbCBwb2ludCBvZiBhY2Nlc3MgdG8gYSBzZXJ2aWNlIHdpdGhvdXRcbiAgICogY291cGxpbmcgdXNlcnMgdG8gdGhlIGNvbmNyZXRlIGNsYXNzIHRoYXQgaW1wbGVtZW50cyBpdC5cbiAgICpcbiAgICogQHBhcmFtIGFwaU5hbWUgTmFtZSBvZiB0aGUgcGx1Z2luIHdlIGFyZSB0cnlpbmcgdG8gb2J0YWluXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGxvYWRlZEFQSXNcbiAgICovXG4gIGFzeW5jIGxvYWRBUElzKGFwaU5hbWU6IHN0cmluZ1tdKTogUHJvbWlzZTx7IFtrZXk6IHN0cmluZ106IGFueSB9PiB7XG4gICAgY29uc3QgbG9hZGVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubG9hZGVkQVBJcylcblxuICAgIGNvbnN0IGtleXNUb1JlcXVlc3QgPSBhcGlOYW1lLmZpbHRlcihmdW5jdGlvbigkKSB7XG4gICAgICByZXR1cm4gIWxvYWRlZEtleXMuaW5jbHVkZXMoJClcbiAgICB9KVxuXG4gICAgaWYgKGtleXNUb1JlcXVlc3QubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLmNhbGwobG9hZEFQSXNOb3RpZmljYXRpb25OYW1lLCBba2V5c1RvUmVxdWVzdF0pXG5cbiAgICAgIC8vIExvYWQgLyByZXF1ZXN0IHRoZSBBUElcbiAgICAgIGtleXNUb1JlcXVlc3QuZm9yRWFjaChhc3luYyBhcGlOYW1lID0+IHtcbiAgICAgICAgdGhpcy5sb2FkZWRBUElzW2FwaU5hbWVdID0gZ2V0QXBpKHRoaXMsIGFwaU5hbWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYWRlZEFQSXNcbiAgfVxuXG4gIHByb3RlY3RlZCBkaWRDb25uZWN0KCkge1xuICAgIGNvbnN0IGluamVjdGlvbiA9IF9pbmplY3RBUElzKHRoaXMpXG5cbiAgICBzdXBlci5kaWRDb25uZWN0KClcblxuICAgIGluamVjdGlvblxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zeXN0ZW1EaWRFbmFibGUgJiYgIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuc3lzdGVtRGlkRW5hYmxlKClcbiAgICAgICAgICAgIGlmIChyICYmIGlzUHJvbWlzZUxpa2UocikpIHtcbiAgICAgICAgICAgICAgci5jYXRjaChlID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZSkpXG4gIH1cbn1cblxuZXhwb3J0IHsgU2NyaXB0IH1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/Script.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/index.js ***!
  \***********************************************************/
/*! exports provided: WebWorkerTransport, WebSocketTransport, MemoryTransport, inject, getInjectedAPIs, Script, EventSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Script */ \"./node_modules/decentraland-rpc/lib/client/Script.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"inject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getInjectedAPIs\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"getInjectedAPIs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Script\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"Script\"]; });\n\n/* harmony import */ var _EventSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSubscriber */ \"./node_modules/decentraland-rpc/lib/client/EventSubscriber.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EventSubscriber\", function() { return _EventSubscriber__WEBPACK_IMPORTED_MODULE_1__[\"EventSubscriber\"]; });\n\n/* harmony import */ var _common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebWorkerTransport\", function() { return _common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__[\"WebWorkerTransport\"]; });\n\n/* harmony import */ var _common_transports_WebSocket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/transports/WebSocket */ \"./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return _common_transports_WebSocket__WEBPACK_IMPORTED_MODULE_3__[\"WebSocketTransport\"]; });\n\n/* harmony import */ var _common_transports_Memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/transports/Memory */ \"./node_modules/decentraland-rpc/lib/common/transports/Memory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MemoryTransport\", function() { return _common_transports_Memory__WEBPACK_IMPORTED_MODULE_4__[\"MemoryTransport\"]; });\n\n\n\n\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpZW50L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLGNBQWMsVUFBVSxDQUFBO0FBQ3hCLGNBQWMsbUJBQW1CLENBQUE7QUFFakMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFDbkUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFDbkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xuXG5leHBvcnQgKiBmcm9tICcuL1NjcmlwdCdcbmV4cG9ydCAqIGZyb20gJy4vRXZlbnRTdWJzY3JpYmVyJ1xuXG5leHBvcnQgeyBXZWJXb3JrZXJUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9XZWJXb3JrZXInXG5leHBvcnQgeyBXZWJTb2NrZXRUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9XZWJTb2NrZXQnXG5leHBvcnQgeyBNZW1vcnlUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9NZW1vcnknXG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js ***!
  \**************************************************************************/
/*! exports provided: EventDispatcherBinding, EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcherBinding\", function() { return EventDispatcherBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\nconst eventSplitter = /\\s+/g;\nclass EventDispatcherBinding {\n    constructor(id, cb, event, sharedList, object) {\n        this.id = id;\n        this.cb = cb;\n        this.event = event;\n        this.sharedList = sharedList;\n        this.object = object;\n        this.enabled = true;\n    }\n    off() {\n        if (this.object) {\n            this.cb && this.object.off(this);\n            this.cb = null;\n            this.object = null;\n            if (this.sharedList) {\n                delete this.sharedList;\n            }\n        }\n    }\n    enable() {\n        if (this.sharedList) {\n            for (let i = 0; i < this.sharedList.length; i++) {\n                this.sharedList[i].enabled = true;\n            }\n        }\n        else\n            this.enabled = true;\n    }\n    disable() {\n        if (this.sharedList) {\n            for (let i = 0; i < this.sharedList.length; i++) {\n                this.sharedList[i].enabled = false;\n            }\n        }\n        else {\n            this.enabled = false;\n        }\n    }\n}\nfunction turnOffCallback(f) {\n    delete f.cb;\n}\nclass EventDispatcher {\n    constructor() {\n        this.edBindings = {};\n        this.edBindCount = 0;\n    }\n    on(event, callback, once) {\n        this.edBindCount++;\n        let events = event.split(eventSplitter);\n        let bindList = [];\n        let latest = null;\n        for (let evt of events) {\n            let tmp = new EventDispatcherBinding(this.edBindCount, null, evt, bindList, this);\n            bindList && bindList.push(tmp);\n            if (once) {\n                tmp.cb = function () {\n                    callback.apply(this, arguments);\n                    tmp.cb = null;\n                }.bind(this);\n            }\n            else {\n                tmp.cb = callback.bind(this);\n            }\n            this.edBindings[evt] = this.edBindings[evt] || [];\n            this.edBindings[evt].push(tmp);\n            latest = tmp;\n        }\n        return latest;\n    }\n    once(event, callback) {\n        return this.on(event, callback, true);\n    }\n    off(arg0, arg1) {\n        if (arguments.length === 0) {\n            for (let i in this.edBindings) {\n                for (let e in this.edBindings[i]) {\n                    delete this.edBindings[i][e].cb;\n                }\n                this.edBindings[i].length = 0;\n            }\n        }\n        else if (arg0 instanceof EventDispatcherBinding) {\n            arg0.cb = null;\n            arg0.sharedList && arg0.sharedList.length && arg0.sharedList.forEach(turnOffCallback);\n        }\n        else if (typeof arg0 === 'string') {\n            if (typeof arg1 === 'function') {\n                for (let i in this.edBindings[arg0]) {\n                    if (this.edBindings[arg0][i].cb === arg1) {\n                        this.edBindings[arg0][i].cb = null;\n                    }\n                }\n            }\n            else if (typeof arg0 === 'string') {\n                this.edBindings[arg0] = [];\n            }\n        }\n        else if (typeof arg0 === 'function') {\n            for (let evt in this.edBindings) {\n                for (let i in this.edBindings[evt]) {\n                    if (this.edBindings[evt][i].cb === arg0) {\n                        this.edBindings[evt][i].cb = null;\n                    }\n                }\n            }\n        }\n    }\n    emit(event) {\n        if (event in this.edBindings) {\n            if (arguments.length === 1) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb();\n                }\n            }\n            else if (arguments.length === 2) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1]);\n                }\n            }\n            else if (arguments.length === 3) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2]);\n                }\n            }\n            else if (arguments.length === 4) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2], arguments[3]);\n                }\n            }\n            else if (arguments.length === 5) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2], arguments[3], arguments[4]);\n                }\n            }\n            else if (arguments.length > 4) {\n                let args = Array.prototype.slice.call(arguments, 1);\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb.apply(this, args);\n                }\n            }\n        }\n        else if (event === 'error') {\n            const firstArgument = arguments[1];\n            let error = null;\n            if (firstArgument instanceof Error) {\n                error = firstArgument;\n            }\n            else {\n                error = Object.assign(new Error('EventDispatcher: Unhandled \"error\" event'), { data: arguments });\n            }\n            console.error(error);\n            console.trace(arguments);\n            throw error;\n        }\n    }\n    getEventBindings(event) {\n        return (this.edBindings[event] || []).filter($ => $ && $.enabled);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnREaXNwYXRjaGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9jb3JlL0V2ZW50RGlzcGF0Y2hlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUE7QUFFNUIsTUFBTSxPQUFPLHNCQUFzQjtJQUVqQyxZQUNTLEVBQVUsRUFDVixFQUFtQixFQUNuQixLQUFhLEVBQ2IsVUFBb0MsRUFDcEMsTUFBbUM7UUFKbkMsT0FBRSxHQUFGLEVBQUUsQ0FBUTtRQUNWLE9BQUUsR0FBRixFQUFFLENBQWlCO1FBQ25CLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixlQUFVLEdBQVYsVUFBVSxDQUEwQjtRQUNwQyxXQUFNLEdBQU4sTUFBTSxDQUE2QjtRQU41QyxZQUFPLEdBQVksSUFBSSxDQUFBO0lBT3BCLENBQUM7SUFFSixHQUFHO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNoQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQTtZQUNkLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFBO1lBQ2xCLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFBO2FBQ3ZCO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNKLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9DLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQTthQUNsQztTQUNGOztZQUFNLElBQUks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QUMsS0FBYTtRQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ25FLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgRGljdGlvbmFyeTxUID0gYW55PiB7XG4gIFtrZXk6IHN0cmluZ106IFRcbn1cblxuY29uc3QgZXZlbnRTcGxpdHRlciA9IC9cXHMrL2dcblxuZXhwb3J0IGNsYXNzIEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcge1xuICBlbmFibGVkOiBib29sZWFuID0gdHJ1ZVxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWQ6IG51bWJlcixcbiAgICBwdWJsaWMgY2I6IEZ1bmN0aW9uIHwgbnVsbCxcbiAgICBwdWJsaWMgZXZlbnQ6IHN0cmluZyxcbiAgICBwdWJsaWMgc2hhcmVkTGlzdDogRXZlbnREaXNwYXRjaGVyQmluZGluZ1tdLFxuICAgIHB1YmxpYyBvYmplY3Q6IEV2ZW50RGlzcGF0Y2hlcjxhbnk+IHwgbnVsbFxuICApIHt9XG5cbiAgb2ZmKCkge1xuICAgIGlmICh0aGlzLm9iamVjdCkge1xuICAgICAgdGhpcy5jYiAmJiB0aGlzLm9iamVjdC5vZmYodGhpcylcbiAgICAgIHRoaXMuY2IgPSBudWxsXG4gICAgICB0aGlzLm9iamVjdCA9IG51bGxcbiAgICAgIGlmICh0aGlzLnNoYXJlZExpc3QpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2hhcmVkTGlzdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zaGFyZWRMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNoYXJlZExpc3RbaV0uZW5hYmxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgdGhpcy5lbmFibGVkID0gdHJ1ZVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zaGFyZWRMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNoYXJlZExpc3RbaV0uZW5hYmxlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHR1cm5PZmZDYWxsYmFjayhmOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gIGRlbGV0ZSBmLmNiXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnREaXNwYXRjaGVyRXZlbnRzQmFzZSB7XG4gIFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uXG59XG5cbmV4cG9ydCBjbGFzcyBFdmVudERpc3BhdGNoZXI8VCA9IEV2ZW50RGlzcGF0Y2hlckV2ZW50c0Jhc2U+IHtcbiAgcHJpdmF0ZSBlZEJpbmRpbmdzOiBEaWN0aW9uYXJ5PEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdbXT4gPSB7fVxuICBwcml2YXRlIGVkQmluZENvdW50ID0gMFxuXG4gIG9uPEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudDogSywgY2FsbGJhY2s6IFRbS10sIG9uY2U/OiBib29sZWFuKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbihldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkLCBvbmNlPzogYm9vbGVhbik6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdcbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGFueSwgb25jZT86IGJvb2xlYW4pOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nIHtcbiAgICB0aGlzLmVkQmluZENvdW50KytcblxuICAgIGxldCBldmVudHMgPSBldmVudC5zcGxpdChldmVudFNwbGl0dGVyKVxuXG4gICAgbGV0IGJpbmRMaXN0OiBFdmVudERpc3BhdGNoZXJCaW5kaW5nW10gPSBbXVxuICAgIGxldCBsYXRlc3Q6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgZm9yIChsZXQgZXZ0IG9mIGV2ZW50cykge1xuICAgICAgbGV0IHRtcCA9IG5ldyBFdmVudERpc3BhdGNoZXJCaW5kaW5nKHRoaXMuZWRCaW5kQ291bnQsIG51bGwsIGV2dCwgYmluZExpc3QsIHRoaXMpXG5cbiAgICAgIGJpbmRMaXN0ICYmIGJpbmRMaXN0LnB1c2godG1wKVxuXG4gICAgICBpZiAob25jZSkge1xuICAgICAgICB0bXAuY2IgPSBmdW5jdGlvbih0aGlzOiBFdmVudERpc3BhdGNoZXI8VD4pIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgdG1wLmNiID0gbnVsbFxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcC5jYiA9IGNhbGxiYWNrLmJpbmQodGhpcylcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF0gPSB0aGlzLmVkQmluZGluZ3NbZXZ0XSB8fCBbXVxuICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF0ucHVzaCh0bXApXG5cbiAgICAgIGxhdGVzdCA9IHRtcFxuICAgIH1cblxuICAgIHJldHVybiBsYXRlc3QgYXMgRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICB9XG5cbiAgb25jZTxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnQ6IEssIGNhbGxiYWNrOiBUW0tdKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbmNlKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdcbiAgb25jZShldmVudDogc3RyaW5nLCBjYWxsYmFjazogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGNhbGxiYWNrLCB0cnVlKVxuICB9XG5cbiAgb2ZmKGJpbmRpbmc6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcpOiB2b2lkXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgYm91bmRDYWxsYmFjaz86IEZ1bmN0aW9uKTogdm9pZFxuICBvZmYoYm91bmRDYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkXG4gIG9mZihhcmcwPzogc3RyaW5nIHwgRnVuY3Rpb24gfCBFdmVudERpc3BhdGNoZXJCaW5kaW5nLCBhcmcxPzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgZSBpbiB0aGlzLmVkQmluZGluZ3NbaV0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5lZEJpbmRpbmdzW2ldW2VdLmNiXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZEJpbmRpbmdzW2ldLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gICAgICBhcmcwLmNiID0gbnVsbFxuICAgICAgYXJnMC5zaGFyZWRMaXN0ICYmIGFyZzAuc2hhcmVkTGlzdC5sZW5ndGggJiYgYXJnMC5zaGFyZWRMaXN0LmZvckVhY2godHVybk9mZkNhbGxiYWNrKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3NbYXJnMF0pIHtcbiAgICAgICAgICBpZiAodGhpcy5lZEJpbmRpbmdzW2FyZzBdW2ldLmNiID09PSBhcmcxKSB7XG4gICAgICAgICAgICB0aGlzLmVkQmluZGluZ3NbYXJnMF1baV0uY2IgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoYXJnMCBhcyBhbnkpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVkQmluZGluZ3NbYXJnMF0gPSBbXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAobGV0IGV2dCBpbiB0aGlzLmVkQmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3NbZXZ0XSkge1xuICAgICAgICAgIGlmICh0aGlzLmVkQmluZGluZ3NbZXZ0XVtpXS5jYiA9PT0gYXJnMCkge1xuICAgICAgICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF1baV0uY2IgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW1pdChldmVudDogJ2Vycm9yJywgZXJyb3I6IGFueSk6IHZvaWRcbiAgZW1pdDxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnQ6IEssIC4uLnBhcmFtczogYW55W10pOiB2b2lkXG4gIGVtaXQoZXZlbnQ6IHN0cmluZywgLi4ucGFyYW1zOiBhbnlbXSk6IHZvaWRcbiAgZW1pdChldmVudDogc3RyaW5nKSB7XG4gICAgaWYgKGV2ZW50IGluIHRoaXMuZWRCaW5kaW5ncykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkQmluZGluZ3NbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGUgPSB0aGlzLmVkQmluZGluZ3NbZXZlbnRdW2ldXG4gICAgICAgICAgZSAmJiBlLmNiICYmIGUuZW5hYmxlZCAmJiBlLmNiKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZEJpbmRpbmdzW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBlID0gdGhpcy5lZEJpbmRpbmdzW2V2ZW50XVtpXVxuICAgICAgICAgIGUgJiYgZS5jYiAmJiBlLmVuYWJsZWQgJiYgZS5jYihhcmd1bWVudHNbMV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRCaW5kaW5nc1tldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZSA9IHRoaXMuZWRCaW5kaW5nc1tldmVudF1baV1cbiAgICAgICAgICBlICYmIGUuY2IgJiYgZS5lbmFibGVkICYmIGUuY2IoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRCaW5kaW5nc1tldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZSA9IHRoaXMuZWRCaW5kaW5nc1tldmVudF1baV1cbiAgICAgICAgICBlICYmIGUuY2IgJiYgZS5lbmFibGVkICYmIGUuY2IoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZEJpbmRpbmdzW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBlID0gdGhpcy5lZEJpbmRpbmdzW2V2ZW50XVtpXVxuICAgICAgICAgIGUgJiYgZS5jYiAmJiBlLmVuYWJsZWQgJiYgZS5jYihhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkQmluZGluZ3NbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGUgPSB0aGlzLmVkQmluZGluZ3NbZXZlbnRdW2ldXG4gICAgICAgICAgZSAmJiBlLmNiICYmIGUuZW5hYmxlZCAmJiBlLmNiLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICBjb25zdCBmaXJzdEFyZ3VtZW50OiBhbnkgPSBhcmd1bWVudHNbMV1cbiAgICAgIGxldCBlcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbFxuXG4gICAgICBpZiAoZmlyc3RBcmd1bWVudCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVycm9yID0gZmlyc3RBcmd1bWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignRXZlbnREaXNwYXRjaGVyOiBVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50JyksIHsgZGF0YTogYXJndW1lbnRzIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICBjb25zb2xlLnRyYWNlKGFyZ3VtZW50cylcblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RXZlbnRCaW5kaW5ncyhldmVudDogc3RyaW5nKSB7XG4gICAgcmV0dXJuICh0aGlzLmVkQmluZGluZ3NbZXZlbnRdIHx8IFtdKS5maWx0ZXIoJCA9PiAkICYmICQuZW5hYmxlZClcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js ***!
  \************************************************************************/
/*! exports provided: isPromiseLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPromiseLike\", function() { return isPromiseLike; });\nfunction isPromiseLike(thing) {\n    return (thing &&\n        typeof thing === 'object' &&\n        typeof thing['then'] === 'function' &&\n        typeof thing['catch'] === 'function');\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXNQcm9taXNlTGlrZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vY29yZS9pc1Byb21pc2VMaWtlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBVTtJQUN0QyxPQUFPLENBQ0wsS0FBSztRQUVMLE9BQU8sS0FBSyxLQUFLLFFBQVE7UUFFekIsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssVUFBVTtRQUVuQyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxVQUFVLENBQ3JDLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodGhpbmc6IFByb21pc2U8YW55Pik6IHRydWVcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKHRoaW5nOiB2b2lkKTogZmFsc2VcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKHRoaW5nOiBhbnkpOiBmYWxzZVxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodGhpbmc6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHRoaW5nICYmXG4gICAgLy8gaXQgaXMgYW4gb2JqZWN0XG4gICAgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JyAmJlxuICAgIC8vIGl0IGhhcyB0aGVuXG4gICAgdHlwZW9mIHRoaW5nWyd0aGVuJ10gPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBpdCBoYXMgY2F0Y2hcbiAgICB0eXBlb2YgdGhpbmdbJ2NhdGNoJ10gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/json-rpc/API.js":
/*!******************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/json-rpc/API.js ***!
  \******************************************************************/
/*! exports provided: getApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getApi\", function() { return getApi; });\nconst blacklistedMethods = ['then', 'catch'];\nfunction getApi(rpcClient, _prefix = '') {\n    if (!Proxy) {\n        throw new Error('getApi() requires ES6 Proxy. Please use an ES6 compatible engine');\n    }\n    const prefix = _prefix === '' ? '' : `${_prefix}.`;\n    return new Proxy({}, {\n        get: (target, prop) => {\n            if (target[prop]) {\n                return target[prop];\n            }\n            if (prop === '__proto__' || prop === 'prototype') {\n                return Object.prototype;\n            }\n            else if (prop.substr(0, 2) === 'on' && prop.length > 3) {\n                const method = prop.substr(2);\n                target[prop] = (handler) => rpcClient.on(`${prefix}${method}`, (params) => {\n                    try {\n                        if (params && params instanceof Array) {\n                            handler.apply(null, params);\n                        }\n                        else {\n                            handler.call(null, params);\n                        }\n                    }\n                    catch (e) {\n                        rpcClient.emit('error', e);\n                    }\n                });\n            }\n            else if (prop.substr(0, 4) === 'emit' && prop.length > 5) {\n                const method = prop.substr(4);\n                target[prop] = (...args) => rpcClient.notify(`${prefix}${method}`, args);\n            }\n            else if (blacklistedMethods.indexOf(prop) !== -1) {\n                return undefined;\n            }\n            else {\n                const method = prop;\n                target[prop] = (...args) => rpcClient.call(`${prefix}${method}`, args);\n            }\n            return target[prop];\n        }\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVBJLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9qc29uLXJwYy9BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQTtBQVU1QyxNQUFNLFVBQVUsTUFBTSxDQUF5QixTQUFpQixFQUFFLFVBQWtCLEVBQUU7SUFDcEYsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsa0VBQWtFLENBQUMsQ0FBQTtLQUNwRjtJQUVELE1BQU0sTUFBTSxHQUFHLE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEdBQUcsQ0FBQTtJQUVsRCxPQUFPLElBQUksS0FBSyxDQUFDLEVBQU8sRUFBRTtRQUN4QixHQUFHLEVBQUUsQ0FBQyxNQUFXLEVBQUUsSUFBWSxFQUFFLEVBQUU7WUFDakMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO2FBQ3BCO1lBRUQsSUFBSSxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksS0FBSyxXQUFXLEVBQUU7Z0JBQ2hELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQTthQUN4QjtpQkFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDeEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBaUIsRUFBRSxFQUFFLENBQ25DLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFXLEVBQUUsRUFBRTtvQkFDakQsSUFBSTt3QkFDRixJQUFJLE1BQU0sSUFBSSxNQUFNLFlBQVksS0FBSyxFQUFFOzRCQUNyQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQTt5QkFDNUI7NkJBQU07NEJBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7eUJBQzNCO3FCQUNGO29CQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUNWLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFBO3FCQUMzQjtnQkFDSCxDQUFDLENBQUMsQ0FBQTthQUNMO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMxRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO2dCQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQVcsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQTthQUNoRjtpQkFBTSxJQUFJLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQkFDbEQsT0FBTyxTQUFTLENBQUE7YUFDakI7aUJBQU07Z0JBQ0wsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFBO2dCQUNuQixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQVcsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQTthQUM5RTtZQUVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3JCLENBQUM7S0FDRixDQUFDLENBQUE7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSAnLi9DbGllbnQnXG5cbmNvbnN0IGJsYWNrbGlzdGVkTWV0aG9kcyA9IFsndGhlbicsICdjYXRjaCddXG5cbi8qKlxuICogQnVpbGRzIGFuIEVTNiBQcm94eSB3aGVyZSBhcGkuZG9tYWluLm1ldGhvZChwYXJhbXMpIHRyYW5zYXRlcyBpbnRvIGNsaWVudC5zZW5kKCd7ZG9tYWlufS57bWV0aG9kfScsIHBhcmFtcykgY2FsbHNcbiAqIGFwaS5kb21haW4ub257bWV0aG9kfSB3aWxsIGFkZCBldmVudCBoYW5kbGVycyBmb3Ige21ldGhvZH0gZXZlbnRzXG4gKiBhcGkuZG9tYWluLmVtaXR7bWV0aG9kfSB3aWxsIHNlbmQge21ldGhvZH0gbm90aWZpY2F0aW9ucyB0byB0aGUgc2VydmVyXG4gKiBUaGUgYXBpIG9iamVjdCBsZWFkcyBpdHNlbGYgdG8gYSB2ZXJ5IGNsZWFuIGludGVyZmFjZSBpLmUgYGF3YWl0IGFwaS5Eb21haW4uZnVuYyhwYXJhbXMpYCBjYWxsc1xuICogVGhpcyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGFic3RyYWN0IGFsbCB0aGUgaW50ZXJuYWwgZGV0YWlscyBvZiBtYXJzaGFsbGluZyB0aGUgbWVzc2FnZSBmcm9tIGZ1bmN0aW9uIGNhbGwgdG8gYSBzdHJpbmdcbiAqIENhbGxpbmcgY2xpZW50LmFwaSgnJykgd2lsbCByZXR1cm4gYW4gdW5wcmVmaXhlZCBjbGllbnQuIGUuZyBhcGkuaGVsbG8oKSBpcyBlcXVpdmFsaWVudCB0byBjbGllbnQuc2VuZCgnaGVsbG8nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBpPFQgZXh0ZW5kcyBvYmplY3QgPSBhbnk+KHJwY0NsaWVudDogQ2xpZW50LCBfcHJlZml4OiBzdHJpbmcgPSAnJyk6IFQge1xuICBpZiAoIVByb3h5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRBcGkoKSByZXF1aXJlcyBFUzYgUHJveHkuIFBsZWFzZSB1c2UgYW4gRVM2IGNvbXBhdGlibGUgZW5naW5lJylcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IF9wcmVmaXggPT09ICcnID8gJycgOiBgJHtfcHJlZml4fS5gXG5cbiAgcmV0dXJuIG5ldyBQcm94eSh7fSBhcyBULCB7XG4gICAgZ2V0OiAodGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHRhcmdldFtwcm9wXSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdXG4gICAgICB9XG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBwcm90b3R5cGUgc28gY29uc29sZSBpbnRlbGxpc2Vuc2Ugd29ya3Mgb24gb2JqZWN0c1xuICAgICAgaWYgKHByb3AgPT09ICdfX3Byb3RvX18nIHx8IHByb3AgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlXG4gICAgICB9IGVsc2UgaWYgKHByb3Auc3Vic3RyKDAsIDIpID09PSAnb24nICYmIHByb3AubGVuZ3RoID4gMykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwcm9wLnN1YnN0cigyKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSAoaGFuZGxlcjogRnVuY3Rpb24pID0+XG4gICAgICAgICAgcnBjQ2xpZW50Lm9uKGAke3ByZWZpeH0ke21ldGhvZH1gLCAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwobnVsbCwgcGFyYW1zKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJwY0NsaWVudC5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5zdWJzdHIoMCwgNCkgPT09ICdlbWl0JyAmJiBwcm9wLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJvcC5zdWJzdHIoNClcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBycGNDbGllbnQubm90aWZ5KGAke3ByZWZpeH0ke21ldGhvZH1gLCBhcmdzKVxuICAgICAgfSBlbHNlIGlmIChibGFja2xpc3RlZE1ldGhvZHMuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJvcFxuICAgICAgICB0YXJnZXRbcHJvcF0gPSAoLi4uYXJnczogYW55W10pID0+IHJwY0NsaWVudC5jYWxsKGAke3ByZWZpeH0ke21ldGhvZH1gLCBhcmdzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdXG4gICAgfVxuICB9KVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/json-rpc/API.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js ***!
  \*********************************************************************/
/*! exports provided: Client */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n/* harmony import */ var msgpack_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! msgpack-lite */ \"./node_modules/msgpack-lite/lib/browser.js\");\n/* harmony import */ var msgpack_lite__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst codec = Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"createCodec\"])();\nclass Client extends _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"] {\n    constructor(opts) {\n        super();\n        this.sendEncoding = 'JSON';\n        this._responsePromiseMap = new Map();\n        this._nextMessageId = 0;\n        this._consoleLog = false;\n        this._requestQueue = [];\n        this._connected = false;\n        this.setLogging(opts);\n    }\n    processMessage(messageStr) {\n        let message;\n        if (typeof messageStr === 'string' && messageStr.charAt(0) === '{') {\n            this._logMessage(messageStr, 'receive');\n            try {\n                message = JSON.parse(messageStr);\n            }\n            catch (e) {\n                return this.emit('error', e);\n            }\n        }\n        else if (typeof messageStr === 'string' ||\n            messageStr instanceof Uint8Array ||\n            (typeof Buffer !== 'undefined' && messageStr instanceof Buffer) ||\n            messageStr instanceof Array) {\n            message = Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(messageStr, { codec });\n        }\n        else {\n            message = messageStr;\n        }\n        if (!message) {\n            this.emit('error', new Error(`Message cannot be null, empty or undefined`));\n        }\n        else if (message.id) {\n            if (this._responsePromiseMap.has(message.id)) {\n                const promise = this._responsePromiseMap.get(message.id);\n                this._responsePromiseMap.delete(message.id);\n                if ('result' in message) {\n                    promise.resolve(message.result);\n                }\n                else if ('error' in message) {\n                    const error = Object.assign(new Error('Remote error'), message.error, (message.error && message.error.data) || {});\n                    promise.reject(error);\n                }\n                else {\n                    promise.reject(Object.assign(new Error(`Response must have result or error: ${messageStr}`), {\n                        code: -32700\n                    }));\n                }\n            }\n            else {\n                this.emit('error', new Error(`Response with id:${message.id} has no pending request`));\n            }\n        }\n        else if (message.method) {\n            this.emit(message.method, message.params);\n        }\n        else {\n            this.emit('error', new Error(`Invalid message: ${messageStr}`));\n        }\n    }\n    setLogging({ logConsole } = {}) {\n        this._consoleLog = !!logConsole;\n    }\n    call(method, params) {\n        if (typeof params !== 'undefined' && typeof params !== 'object') {\n            throw new Error(`Client#call Params must be structured data (Array | Object) got ${JSON.stringify(params)}`);\n        }\n        const id = ++this._nextMessageId;\n        const message = { id, method, params, jsonrpc: '2.0' };\n        return new Promise((resolve, reject) => {\n            try {\n                this._responsePromiseMap.set(id, { resolve, reject });\n                this._send(message);\n            }\n            catch (error) {\n                return reject(error);\n            }\n        });\n    }\n    notify(method, params) {\n        if (typeof params !== 'undefined' && typeof params !== 'object') {\n            throw new Error(`Client#notify Params must be structured data (Array | Object) got ${JSON.stringify(params)}`);\n        }\n        this._send({ method, params, jsonrpc: '2.0' });\n    }\n    didConnect() {\n        if (this._connected === false) {\n            this._connected = true;\n            this._sendQueuedRequests();\n        }\n    }\n    _send(message) {\n        if (this.sendEncoding === 'msgpack') {\n            this._requestQueue.push(Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(message, { codec }));\n        }\n        else {\n            this._requestQueue.push(JSON.stringify(message));\n        }\n        this._sendQueuedRequests();\n    }\n    _sendQueuedRequests() {\n        if (this._connected) {\n            const queue = this._requestQueue.splice(0, this._requestQueue.length);\n            for (let messageStr of queue) {\n                this._logMessage(messageStr, 'send');\n                this.sendMessage(messageStr);\n            }\n        }\n    }\n    _logMessage(message, direction) {\n        if (this._consoleLog) {\n            console.log(`Client ${direction === 'send' ? '>' : '<'}`, message.toString());\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9qc29uLXJwYy9DbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFBO0FBRXpELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLGNBQWMsQ0FBQTtBQUUxRCxNQUFNLEtBQUssR0FBRyxXQUFXLEVBQUUsQ0FBQTtBQU0zQixNQUFNLE9BQWdCLE1BQU8sU0FBUSxlQUFlO0lBU2xELFlBQVksSUFBMkI7UUFDckMsS0FBSyxFQUFFLENBQUE7UUFUVCxpQkFBWSxHQUF1QixNQUFNLENBQUE7UUFFakMsd0JBQW1CLEdBQXFDLElBQUksR0FBRyxFQUFFLENBQUE7UUFDakUsbUJBQWMsR0FBVyxDQUFDLENBQUE7UUFDMUIsZ0JBQVcsR0FBWSxLQUFLLENBQUE7UUFDNUIsa0JBQWEsR0FBd0IsRUFBRSxDQUFBO1FBQ3ZDLGVBQVUsR0FBRyxLQUFLLENBQUE7UUFJeEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUN2QixDQUFDO0lBSU0sY0FBYyxDQUNuQixVQUFtRztRQUVuRyxJQUFJLE9BQW9ELENBQUE7UUFFeEQsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7WUFDbEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUE7WUFHdkMsSUFBSTtnQkFDRixPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQTthQUNqQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUE7YUFDN0I7U0FDRjthQUFNLElBQ0ws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U0FDakQ7UUFDRCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQTtJQUM1QixDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUNyRSxLQUFLLElBQUksVUFBVSxJQUFJLEtBQUssRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUE7Z0JBQ3BDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUE7YUFDN0I7U0FDRjtJQUNILENBQUM7SUFFTyxXQUFXLENBQUMsT0FBd0IsRUFBRSxTQUE2QjtRQUN6RSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLFNBQVMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUE7U0FDOUU7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi9jb3JlL0V2ZW50RGlzcGF0Y2hlcidcbmltcG9ydCAqIGFzIEpzb25ScGMyIGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVDb2RlYywgZW5jb2RlLCBkZWNvZGUgfSBmcm9tICdtc2dwYWNrLWxpdGUnXG5cbmNvbnN0IGNvZGVjID0gY3JlYXRlQ29kZWMoKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSUEMgQ2xpZW50LlxuICogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBDbGllbnQgZG9lcyBub3QgY3JlYXRlIGEgV2ViU29ja2V0IG9iamVjdCBzaW5jZSB3ZSBwcmVmZXIgY29tcG9zYWJpbGl0eVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIGltcGxlbWVudHMgSnNvblJwYzIuSUNsaWVudCB7XG4gIHNlbmRFbmNvZGluZzogJ0pTT04nIHwgJ21zZ3BhY2snID0gJ0pTT04nXG5cbiAgcHJpdmF0ZSBfcmVzcG9uc2VQcm9taXNlTWFwOiBNYXA8bnVtYmVyLCBKc29uUnBjMi5SZXNvbHZhYmxlPiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIF9uZXh0TWVzc2FnZUlkOiBudW1iZXIgPSAwXG4gIHByaXZhdGUgX2NvbnNvbGVMb2c6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIF9yZXF1ZXN0UXVldWU6IChzdHJpbmcgfCBCdWZmZXIpW10gPSBbXVxuICBwcml2YXRlIF9jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKG9wdHM/OiBKc29uUnBjMi5JQ2xpZW50T3B0cykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNldExvZ2dpbmcob3B0cylcbiAgfVxuXG4gIGFic3RyYWN0IHNlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IHZvaWRcblxuICBwdWJsaWMgcHJvY2Vzc01lc3NhZ2UoXG4gICAgbWVzc2FnZVN0cjogc3RyaW5nIHwgKEpzb25ScGMyLklSZXNwb25zZSAmIEpzb25ScGMyLklOb3RpZmljYXRpb24pIHwgQnVmZmVyIHwgVWludDhBcnJheSB8IG51bWJlcltdXG4gICkge1xuICAgIGxldCBtZXNzYWdlOiBKc29uUnBjMi5JUmVzcG9uc2UgJiBKc29uUnBjMi5JTm90aWZpY2F0aW9uXG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VTdHIgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2VTdHIuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgIHRoaXMuX2xvZ01lc3NhZ2UobWVzc2FnZVN0ciwgJ3JlY2VpdmUnKVxuXG4gICAgICAvLyBFbnN1cmUgSlNPTiBpcyBub3QgbWFsZm9ybWVkXG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlU3RyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBtZXNzYWdlU3RyID09PSAnc3RyaW5nJyB8fFxuICAgICAgbWVzc2FnZVN0ciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovIHx8XG4gICAgICAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgbWVzc2FnZVN0ciBpbnN0YW5jZW9mIEJ1ZmZlcikgfHxcbiAgICAgIG1lc3NhZ2VTdHIgaW5zdGFuY2VvZiBBcnJheVxuICAgICkge1xuICAgICAgbWVzc2FnZSA9IGRlY29kZShtZXNzYWdlU3RyIGFzIGFueSwgeyBjb2RlYyB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZVN0clxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgbWVzc2FnZXMgaXMgd2VsbCBmb3JtZWRcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYE1lc3NhZ2UgY2Fubm90IGJlIG51bGwsIGVtcHR5IG9yIHVuZGVmaW5lZGApKVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pZCkge1xuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlUHJvbWlzZU1hcC5oYXMobWVzc2FnZS5pZCkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBwcm9taXNlIGZyb20gcGVuZGluZyBtZXNzYWdlXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9yZXNwb25zZVByb21pc2VNYXAuZ2V0KG1lc3NhZ2UuaWQpIGFzIEpzb25ScGMyLlJlc29sdmFibGVcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQcm9taXNlTWFwLmRlbGV0ZShtZXNzYWdlLmlkKVxuXG4gICAgICAgIGlmICgncmVzdWx0JyBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICB9IGVsc2UgaWYgKCdlcnJvcicgaW4gbWVzc2FnZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIG5ldyBFcnJvcignUmVtb3RlIGVycm9yJyksXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICAgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB8fCB7fVxuICAgICAgICAgIClcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBSZXNwb25zZSBtdXN0IGhhdmUgcmVzdWx0IG9yIGVycm9yOiAke21lc3NhZ2VTdHJ9YCksIHtcbiAgICAgICAgICAgICAgY29kZTogSnNvblJwYzIuRXJyb3JDb2RlLlBhcnNlRXJyb3JcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBSZXNwb25zZSB3aXRoIGlkOiR7bWVzc2FnZS5pZH0gaGFzIG5vIHBlbmRpbmcgcmVxdWVzdGApKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgIC8vIFNlcnZlciBoYXMgc2VudCBhIG5vdGlmaWNhdGlvblxuICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlOiAke21lc3NhZ2VTdHJ9YCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBsb2dnaW5nIGZvciBhbGwgcmVjZWl2ZWQgYW5kIHNlbnQgbWVzc2FnZXNcbiAgICovXG4gIHB1YmxpYyBzZXRMb2dnaW5nKHsgbG9nQ29uc29sZSB9OiBKc29uUnBjMi5JTG9nT3B0cyA9IHt9KSB7XG4gICAgdGhpcy5fY29uc29sZUxvZyA9ICEhbG9nQ29uc29sZVxuICB9XG5cbiAgY2FsbChtZXRob2Q6IHN0cmluZyk6IFByb21pc2U8YW55PlxuICBjYWxsKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHN0cmluZyk6IG5ldmVyXG4gIGNhbGwobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVtYmVyKTogbmV2ZXJcbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBib29sZWFuKTogbmV2ZXJcbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBudWxsKTogbmV2ZXJcbiAgY2FsbDxUPihtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBJdGVyYWJsZTxUPik6IFByb21pc2U8YW55PlxuICBjYWxsKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPGFueT5cbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCNjYWxsIFBhcmFtcyBtdXN0IGJlIHN0cnVjdHVyZWQgZGF0YSAoQXJyYXkgfCBPYmplY3QpIGdvdCAke0pTT04uc3RyaW5naWZ5KHBhcmFtcyl9YClcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fbmV4dE1lc3NhZ2VJZFxuICAgIGNvbnN0IG1lc3NhZ2U6IEpzb25ScGMyLklSZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMsIGpzb25ycGM6ICcyLjAnIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZVByb21pc2VNYXAuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KVxuICAgICAgICB0aGlzLl9zZW5kKG1lc3NhZ2UpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcpOiB2b2lkXG4gIG5vdGlmeShtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBzdHJpbmcpOiBuZXZlclxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVtYmVyKTogbmV2ZXJcbiAgbm90aWZ5KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IGJvb2xlYW4pOiBuZXZlclxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVsbCk6IG5ldmVyXG4gIG5vdGlmeTxUPihtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBJdGVyYWJsZTxUPik6IHZvaWRcbiAgbm90aWZ5KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkXG4gIG5vdGlmeShtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55KTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCNub3RpZnkgUGFyYW1zIG11c3QgYmUgc3RydWN0dXJlZCBkYXRhIChBcnJheSB8IE9iamVjdCkgZ290ICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX1gKVxuICAgIH1cblxuICAgIHRoaXMuX3NlbmQoeyBtZXRob2QsIHBhcmFtcywganNvbnJwYzogJzIuMCcgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBkaWRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICB0aGlzLl9zZW5kUXVldWVkUmVxdWVzdHMoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3NlbmQobWVzc2FnZTogSnNvblJwYzIuSU5vdGlmaWNhdGlvbiB8IEpzb25ScGMyLklSZXF1ZXN0KSB7XG4gICAgaWYgKHRoaXMuc2VuZEVuY29kaW5nID09PSAnbXNncGFjaycpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RRdWV1ZS5wdXNoKGVuY29kZShtZXNzYWdlLCB7IGNvZGVjIH0pKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UXVldWUucHVzaChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gICAgdGhpcy5fc2VuZFF1ZXVlZFJlcXVlc3RzKClcbiAgfVxuXG4gIHByaXZhdGUgX3NlbmRRdWV1ZWRSZXF1ZXN0cygpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3JlcXVlc3RRdWV1ZS5zcGxpY2UoMCwgdGhpcy5fcmVxdWVzdFF1ZXVlLmxlbmd0aClcbiAgICAgIGZvciAobGV0IG1lc3NhZ2VTdHIgb2YgcXVldWUpIHtcbiAgICAgICAgdGhpcy5fbG9nTWVzc2FnZShtZXNzYWdlU3RyLCAnc2VuZCcpXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZVN0cilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9sb2dNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgZGlyZWN0aW9uOiAnc2VuZCcgfCAncmVjZWl2ZScpIHtcbiAgICBpZiAodGhpcy5fY29uc29sZUxvZykge1xuICAgICAgY29uc29sZS5sb2coYENsaWVudCAke2RpcmVjdGlvbiA9PT0gJ3NlbmQnID8gJz4nIDogJzwnfWAsIG1lc3NhZ2UudG9TdHJpbmcoKSlcbiAgICB9XG4gIH1cbn1cbiJdfQ==\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/Memory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/Memory.js ***!
  \***********************************************************************/
/*! exports provided: MemoryTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemoryTransport\", function() { return MemoryTransport; });\n/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n\nfunction MemoryTransport() {\n    const clientEd = new _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"]();\n    const serverEd = new _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"]();\n    function configureMemoryTransport(receiver, sender) {\n        return {\n            sendMessage(message) {\n                sender.emit('message', message);\n            },\n            close() {\n                sender.emit('close');\n            },\n            onMessage(handler) {\n                receiver.on('message', handler);\n            },\n            onClose(handler) {\n                receiver.on('close', handler);\n            },\n            onError(handler) {\n                receiver.on('error', handler);\n            },\n            onConnect(handler) {\n                setInterval(handler, 16);\n            }\n        };\n    }\n    const client = configureMemoryTransport(clientEd, serverEd);\n    const server = configureMemoryTransport(serverEd, clientEd);\n    return {\n        client,\n        server\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVtb3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL01lbW9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUE7QUFFekQsTUFBTSxVQUFVLGVBQWU7SUFDN0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxlQUFlLEVBQUUsQ0FBQTtJQUN0QyxNQUFNLFFBQVEsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFBO0lBRXRDLFNBQVMsd0JBQXdCLENBQUMsUUFBeUIsRUFBRSxNQUF1QjtRQUNsRixPQUFPO1lBQ0wsV0FBVyxDQUFDLE9BQU87Z0JBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1lBQ2pDLENBQUM7WUFFRCxLQUFLO2dCQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7WUFDdEIsQ0FBQztZQUVELFNBQVMsQ0FBQyxPQUFPO2dCQUNmLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1lBQ2pDLENBQUM7WUFFRCxPQUFPLENBQUMsT0FBTztnQkFDYixRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUMvQixDQUFDO1lBRUQsT0FBTyxDQUFDLE9BQU87Z0JBQ2IsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUE7WUFDL0IsQ0FBQztZQUVELFNBQVMsQ0FBQyxPQUFPO2dCQUNmLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUE7WUFDMUIsQ0FBQztTQUNGLENBQUE7SUFDSCxDQUFDO0lBRUQsTUFBTSxNQUFNLEdBQUcsd0JBQXdCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQzNELE1BQU0sTUFBTSxHQUFHLHdCQUF3QixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUUzRCxPQUFPO1FBQ0wsTUFBTTtRQUNOLE1BQU07S0FDUCxDQUFBO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjcmlwdGluZ1RyYW5zcG9ydCB9IGZyb20gJy4uL2pzb24tcnBjL3R5cGVzJ1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vY29yZS9FdmVudERpc3BhdGNoZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlUcmFuc3BvcnQoKSB7XG4gIGNvbnN0IGNsaWVudEVkID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpXG4gIGNvbnN0IHNlcnZlckVkID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgZnVuY3Rpb24gY29uZmlndXJlTWVtb3J5VHJhbnNwb3J0KHJlY2VpdmVyOiBFdmVudERpc3BhdGNoZXIsIHNlbmRlcjogRXZlbnREaXNwYXRjaGVyKTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBzZW5kZXIuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpXG4gICAgICB9LFxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgc2VuZGVyLmVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG5cbiAgICAgIG9uTWVzc2FnZShoYW5kbGVyKSB7XG4gICAgICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgaGFuZGxlcilcbiAgICAgIH0sXG5cbiAgICAgIG9uQ2xvc2UoaGFuZGxlcikge1xuICAgICAgICByZWNlaXZlci5vbignY2xvc2UnLCBoYW5kbGVyKVxuICAgICAgfSxcblxuICAgICAgb25FcnJvcihoYW5kbGVyKSB7XG4gICAgICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIGhhbmRsZXIpXG4gICAgICB9LFxuXG4gICAgICBvbkNvbm5lY3QoaGFuZGxlcikge1xuICAgICAgICBzZXRJbnRlcnZhbChoYW5kbGVyLCAxNilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBjbGllbnQgPSBjb25maWd1cmVNZW1vcnlUcmFuc3BvcnQoY2xpZW50RWQsIHNlcnZlckVkKVxuICBjb25zdCBzZXJ2ZXIgPSBjb25maWd1cmVNZW1vcnlUcmFuc3BvcnQoc2VydmVyRWQsIGNsaWVudEVkKVxuXG4gIHJldHVybiB7XG4gICAgY2xpZW50LFxuICAgIHNlcnZlclxuICB9XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/Memory.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js ***!
  \**************************************************************************/
/*! exports provided: WebSocketTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return WebSocketTransport; });\nfunction WebSocketTransport(socket) {\n    const queue = [];\n    socket.addEventListener('open', function () {\n        flush();\n    });\n    function flush() {\n        if (socket.readyState === socket.OPEN) {\n            queue.forEach($ => send($));\n            queue.length = 0;\n        }\n    }\n    function send(msg) {\n        if (typeof msg === 'string') {\n            socket.send(msg, { binary: false });\n        }\n        else if (msg instanceof Uint8Array || msg instanceof ArrayBuffer || msg instanceof SharedArrayBuffer) {\n            ;\n            socket.binaryType = 'arraybuffer';\n            socket.send(msg, { binary: true });\n        }\n    }\n    const api = {\n        onConnect(handler) {\n            if (socket.readyState === socket.OPEN) {\n                handler();\n            }\n            else {\n                socket.addEventListener('open', () => handler(), { once: true });\n            }\n        },\n        onError(handler) {\n            socket.addEventListener('error', (err) => {\n                if (err.error) {\n                    handler(err.error);\n                }\n                else if (err.message) {\n                    handler(Object.assign(new Error(err.message), {\n                        colno: err.colno,\n                        error: err.error,\n                        filename: err.filename,\n                        lineno: err.lineno,\n                        message: err.message\n                    }));\n                }\n            });\n        },\n        onMessage(handler) {\n            socket.addEventListener('message', (message) => {\n                handler(message.data);\n            });\n        },\n        sendMessage(message) {\n            const toSend = message instanceof Uint8Array ? message.buffer : message;\n            if (socket.readyState === socket.OPEN) {\n                send(toSend);\n            }\n            else {\n                queue.push(toSend);\n            }\n        },\n        close() {\n            socket.close();\n        }\n    };\n    return api;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViU29ja2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL1dlYlNvY2tldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtQ0EsTUFBTSxVQUFVLGtCQUFrQixDQUFDLE1BQWtCO0lBQ25ELE1BQU0sS0FBSyxHQUF1RSxFQUFFLENBQUE7SUFFcEYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtRQUM5QixLQUFLLEVBQUUsQ0FBQTtJQUNULENBQUMsQ0FBQyxDQUFBO0lBRUYsU0FBUyxLQUFLO1FBQ1osSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDckMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQzNCLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFBO1NBQ2pCO0lBQ0gsQ0FBQztJQUVELFNBQVMsSUFBSSxDQUFDLEdBQW1FO1FBQy9FLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUE7U0FDcEM7YUFBTSxJQUFJLEdBQUcsWUFBWSxVQUFVLElBQUksR0FBRyxZQUFZLFdBQVcsSUFBSSxHQUFHLFlBQVksaUJBQWlCLEVBQUU7WUFFdEcsQ0FBQztZQUFDLE1BQWMsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFBO1lBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7U0FDbkM7SUFDSCxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQXVCO1FBQzlCLFNBQVMsQ0FBQyxPQUFPO1lBQ2YsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ3JDLE9BQU8sRUFBRSxDQUFBO2FBQ1Y7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO2FBQ2pFO1FBQ0gsQ0FBQztRQUNELE9BQU8sQ0FBQyxPQUFPO1lBQ2IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQWUsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7b0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtpQkFDbkI7cUJBQU0sSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN0QixPQUFPLENBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3BDLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSzt3QkFDaEIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLO3dCQUNoQixRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVE7d0JBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTt3QkFDbEIsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO3FCQUNyQixDQUFDLENBQ0gsQ0FBQTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUNELFNBQVMsQ0FBQyxPQUFPO1lBQ2YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQXNCLEVBQUUsRUFBRTtnQkFDNUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsT0FBTztZQUNqQixNQUFNLE1BQU0sR0FBRyxPQUFPLFlBQVksVUFBVSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUE7WUFFdkUsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTthQUNiO2lCQUFNO2dCQUNMLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7YUFDbkI7UUFDSCxDQUFDO1FBQ0QsS0FBSztZQUNILE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUNoQixDQUFDO0tBQ0YsQ0FBQTtJQUVELE9BQU8sR0FBRyxDQUFBO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjcmlwdGluZ1RyYW5zcG9ydCB9IGZyb20gJy4uL2pzb24tcnBjL3R5cGVzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElXZWJTb2NrZXRFdmVudE1hcCB7XG4gIGNsb3NlOiBhbnlcbiAgZXJyb3I6IGFueVxuICBtZXNzYWdlOiB7IGRhdGE6IGFueSB9XG4gIG9wZW46IGFueVxufVxuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggdGhlIEJyb3dzZXJzIGludGVyZmFjZVxuICogYW5kIG5wbSB3cyBwYWNrYWdlIGZvciBzZXJ2ZXJzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVdlYlNvY2tldCB7XG4gIENPTk5FQ1RJTkc6IG51bWJlclxuICBPUEVOOiBudW1iZXJcbiAgQ0xPU0lORzogbnVtYmVyXG4gIENMT1NFRDogbnVtYmVyXG5cbiAgcmVhZHlTdGF0ZTogbnVtYmVyXG5cbiAgY2xvc2UoY29kZT86IG51bWJlciwgZGF0YT86IHN0cmluZyk6IHZvaWRcblxuICBzZW5kKGRhdGE6IGFueSwgY2I/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCk6IHZvaWRcbiAgc2VuZChkYXRhOiBhbnksIG9wdGlvbnM6IGFueSwgY2I/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCk6IHZvaWRcblxuICB0ZXJtaW5hdGU/KCk6IHZvaWRcblxuICBhZGRFdmVudExpc3RlbmVyPEsgZXh0ZW5kcyBrZXlvZiBJV2ViU29ja2V0RXZlbnRNYXA+KFxuICAgIHR5cGU6IEssXG4gICAgbGlzdGVuZXI6IChldjogSVdlYlNvY2tldEV2ZW50TWFwW0tdKSA9PiBhbnksXG4gICAgb3B0aW9ucz86IGFueVxuICApOiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoc29ja2V0OiBJV2ViU29ja2V0KTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgY29uc3QgcXVldWU6IChzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBTaGFyZWRBcnJheUJ1ZmZlciB8IEJ1ZmZlcilbXSA9IFtdXG5cbiAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBmbHVzaCgpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTikge1xuICAgICAgcXVldWUuZm9yRWFjaCgkID0+IHNlbmQoJCkpXG4gICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VuZChtc2c6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyIHwgQnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb2NrZXQuc2VuZChtc2csIHsgYmluYXJ5OiBmYWxzZSB9KVxuICAgIH0gZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBtc2cgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBtc2cgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgOyhzb2NrZXQgYXMgYW55KS5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgc29ja2V0LnNlbmQobXNnLCB7IGJpbmFyeTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFwaTogU2NyaXB0aW5nVHJhbnNwb3J0ID0ge1xuICAgIG9uQ29ubmVjdChoYW5kbGVyKSB7XG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgIGhhbmRsZXIoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiBoYW5kbGVyKCksIHsgb25jZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgb25FcnJvcihoYW5kbGVyKSB7XG4gICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXJyOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChlcnIuZXJyb3IpIHtcbiAgICAgICAgICBoYW5kbGVyKGVyci5lcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgIGhhbmRsZXIoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnIubWVzc2FnZSksIHtcbiAgICAgICAgICAgICAgY29sbm86IGVyci5jb2xubyxcbiAgICAgICAgICAgICAgZXJyb3I6IGVyci5lcnJvcixcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGVyci5maWxlbmFtZSxcbiAgICAgICAgICAgICAgbGluZW5vOiBlcnIubGluZW5vLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBvbk1lc3NhZ2UoaGFuZGxlcikge1xuICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAobWVzc2FnZTogeyBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UuZGF0YSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBjb25zdCB0b1NlbmQgPSBtZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG1lc3NhZ2UuYnVmZmVyIDogbWVzc2FnZVxuXG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgIHNlbmQodG9TZW5kKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUucHVzaCh0b1NlbmQpXG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwaVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js ***!
  \**************************************************************************/
/*! exports provided: WebWorkerTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebWorkerTransport\", function() { return WebWorkerTransport; });\nfunction WebWorkerTransport(worker) {\n    const api = {\n        onConnect(handler) {\n            worker.addEventListener('message', () => handler(), { once: true });\n        },\n        onError(handler) {\n            worker.addEventListener('error', (err) => {\n                if (err.error) {\n                    handler(err.error);\n                }\n                else if (err.message) {\n                    handler(Object.assign(new Error(err.message), {\n                        colno: err.colno,\n                        error: err.error,\n                        filename: err.filename,\n                        lineno: err.lineno,\n                        message: err.message\n                    }));\n                }\n            });\n        },\n        onMessage(handler) {\n            worker.addEventListener('message', (message) => {\n                handler(message.data);\n            });\n        },\n        sendMessage(message) {\n            worker.postMessage(message);\n        },\n        close() {\n            if ('terminate' in worker) {\n                ;\n                worker.terminate();\n            }\n            else if ('close' in worker) {\n                ;\n                worker.close();\n            }\n        }\n    };\n    return api;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViV29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL1dlYldvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxNQUFNLFVBQVUsa0JBQWtCLENBQUMsTUFBZTtJQUNoRCxNQUFNLEdBQUcsR0FBdUI7UUFDOUIsU0FBUyxDQUFDLE9BQU87WUFDZixNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDckUsQ0FBQztRQUNELE9BQU8sQ0FBQyxPQUFPO1lBQ2IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQWUsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7b0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtpQkFDbkI7cUJBQU0sSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN0QixPQUFPLENBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3BDLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSzt3QkFDaEIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLO3dCQUNoQixRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVE7d0JBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTt3QkFDbEIsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO3FCQUNyQixDQUFDLENBQ0gsQ0FBQTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUNELFNBQVMsQ0FBQyxPQUFPO1lBQ2YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQXFCLEVBQUUsRUFBRTtnQkFDM0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsT0FBTztZQUNqQixNQUFNLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBQzdCLENBQUM7UUFDRCxLQUFLO1lBQ0gsSUFBSSxXQUFXLElBQUksTUFBTSxFQUFFO2dCQUV6QixDQUFDO2dCQUFDLE1BQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTthQUM3QjtpQkFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLEVBQUU7Z0JBRTVCLENBQUM7Z0JBQUMsTUFBYyxDQUFDLEtBQUssRUFBRSxDQUFBO2FBQ3pCO1FBQ0gsQ0FBQztLQUNGLENBQUE7SUFFRCxPQUFPLEdBQUcsQ0FBQTtBQUNaLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHRpbmdUcmFuc3BvcnQgfSBmcm9tICcuLi9qc29uLXJwYy90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBJV29ya2VyIHtcbiAgdGVybWluYXRlPygpOiB2b2lkXG4gIGNsb3NlPygpOiB2b2lkXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2U6IGFueSk6IHZvaWRcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiAnbWVzc2FnZScgfCAnZXJyb3InLCBsaXN0ZW5lcjogRnVuY3Rpb24sIG9wdGlvbnM/OiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXZWJXb3JrZXJUcmFuc3BvcnQod29ya2VyOiBJV29ya2VyKTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgY29uc3QgYXBpOiBTY3JpcHRpbmdUcmFuc3BvcnQgPSB7XG4gICAgb25Db25uZWN0KGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKCkgPT4gaGFuZGxlcigpLCB7IG9uY2U6IHRydWUgfSlcbiAgICB9LFxuICAgIG9uRXJyb3IoaGFuZGxlcikge1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGVycjogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlcihlcnIuZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICBoYW5kbGVyKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpLCB7XG4gICAgICAgICAgICAgIGNvbG5vOiBlcnIuY29sbm8sXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIuZXJyb3IsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBlcnIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIGxpbmVubzogZXJyLmxpbmVubyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgb25NZXNzYWdlKGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UuZGF0YSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSlcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgaWYgKCd0ZXJtaW5hdGUnIGluIHdvcmtlcikge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgICAgIDsod29ya2VyIGFzIGFueSkudGVybWluYXRlKClcbiAgICAgIH0gZWxzZSBpZiAoJ2Nsb3NlJyBpbiB3b3JrZXIpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgICA7KHdvcmtlciBhcyBhbnkpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js?");

/***/ }),

/***/ "./node_modules/event-lite/event-lite.js":
/*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)\n *\n * @copyright Yusuke Kawasaki\n * @license MIT\n * @constructor\n * @see https://github.com/kawanet/event-lite\n * @see http://kawanet.github.io/event-lite/EventLite.html\n * @example\n * var EventLite = require(\"event-lite\");\n *\n * function MyClass() {...}             // your class\n *\n * EventLite.mixin(MyClass.prototype);  // import event methods\n *\n * var obj = new MyClass();\n * obj.on(\"foo\", function() {...});     // add event listener\n * obj.once(\"bar\", function() {...});   // add one-time event listener\n * obj.emit(\"foo\");                     // dispatch event\n * obj.emit(\"bar\");                     // dispatch another event\n * obj.off(\"foo\");                      // remove event listener\n */\n\nfunction EventLite() {\n  if (!(this instanceof EventLite)) return new EventLite();\n}\n\n(function(EventLite) {\n  // export the class for node.js\n  if (true) module.exports = EventLite;\n\n  // property name to hold listeners\n  var LISTENERS = \"listeners\";\n\n  // methods to export\n  var methods = {\n    on: on,\n    once: once,\n    off: off,\n    emit: emit\n  };\n\n  // mixin to self\n  mixin(EventLite.prototype);\n\n  // export mixin function\n  EventLite.mixin = mixin;\n\n  /**\n   * Import on(), once(), off() and emit() methods into target object.\n   *\n   * @function EventLite.mixin\n   * @param target {Prototype}\n   */\n\n  function mixin(target) {\n    for (var key in methods) {\n      target[key] = methods[key];\n    }\n    return target;\n  }\n\n  /**\n   * Add an event listener.\n   *\n   * @function EventLite.prototype.on\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function on(type, func) {\n    getListeners(this, type).push(func);\n    return this;\n  }\n\n  /**\n   * Add one-time event listener.\n   *\n   * @function EventLite.prototype.once\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function once(type, func) {\n    var that = this;\n    wrap.originalListener = func;\n    getListeners(that, type).push(wrap);\n    return that;\n\n    function wrap() {\n      off.call(that, type, wrap);\n      func.apply(this, arguments);\n    }\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @function EventLite.prototype.off\n   * @param [type] {string}\n   * @param [func] {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function off(type, func) {\n    var that = this;\n    var listners;\n    if (!arguments.length) {\n      delete that[LISTENERS];\n    } else if (!func) {\n      listners = that[LISTENERS];\n      if (listners) {\n        delete listners[type];\n        if (!Object.keys(listners).length) return off.call(that);\n      }\n    } else {\n      listners = getListeners(that, type, true);\n      if (listners) {\n        listners = listners.filter(ne);\n        if (!listners.length) return off.call(that, type);\n        that[LISTENERS][type] = listners;\n      }\n    }\n    return that;\n\n    function ne(test) {\n      return test !== func && test.originalListener !== func;\n    }\n  }\n\n  /**\n   * Dispatch (trigger) an event.\n   *\n   * @function EventLite.prototype.emit\n   * @param type {string}\n   * @param [value] {*}\n   * @returns {boolean} True when a listener received the event\n   */\n\n  function emit(type, value) {\n    var that = this;\n    var listeners = getListeners(that, type, true);\n    if (!listeners) return false;\n    var arglen = arguments.length;\n    if (arglen === 1) {\n      listeners.forEach(zeroarg);\n    } else if (arglen === 2) {\n      listeners.forEach(onearg);\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      listeners.forEach(moreargs);\n    }\n    return !!listeners.length;\n\n    function zeroarg(func) {\n      func.call(that);\n    }\n\n    function onearg(func) {\n      func.call(that, value);\n    }\n\n    function moreargs(func) {\n      func.apply(that, args);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n\n  function getListeners(that, type, readonly) {\n    if (readonly && !that[LISTENERS]) return;\n    var listeners = that[LISTENERS] || (that[LISTENERS] = {});\n    return listeners[type] || (listeners[type] = []);\n  }\n\n})(EventLite);\n\n\n//# sourceURL=webpack:///./node_modules/event-lite/event-lite.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/int64-buffer/int64-buffer.js":
/*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// int64-buffer.js\n\n/*jshint -W018 */ // Confusing use of '!'.\n/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.\n/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?\n\nvar Uint64BE, Int64BE, Uint64LE, Int64LE;\n\n!function(exports) {\n  // constants\n\n  var UNDEFINED = \"undefined\";\n  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;\n  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;\n  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;\n  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];\n  var isArray = Array.isArray || _isArray;\n  var BIT32 = 4294967296;\n  var BIT24 = 16777216;\n\n  // storage class\n\n  var storage; // Array;\n\n  // generate classes\n\n  Uint64BE = factory(\"Uint64BE\", true, true);\n  Int64BE = factory(\"Int64BE\", true, false);\n  Uint64LE = factory(\"Uint64LE\", false, true);\n  Int64LE = factory(\"Int64LE\", false, false);\n\n  // class factory\n\n  function factory(name, bigendian, unsigned) {\n    var posH = bigendian ? 0 : 4;\n    var posL = bigendian ? 4 : 0;\n    var pos0 = bigendian ? 0 : 3;\n    var pos1 = bigendian ? 1 : 2;\n    var pos2 = bigendian ? 2 : 1;\n    var pos3 = bigendian ? 3 : 0;\n    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;\n    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;\n    var proto = Int64.prototype;\n    var isName = \"is\" + name;\n    var _isInt64 = \"_\" + isName;\n\n    // properties\n    proto.buffer = void 0;\n    proto.offset = 0;\n    proto[_isInt64] = true;\n\n    // methods\n    proto.toNumber = toNumber;\n    proto.toString = toString;\n    proto.toJSON = toNumber;\n    proto.toArray = toArray;\n\n    // add .toBuffer() method only when Buffer available\n    if (BUFFER) proto.toBuffer = toBuffer;\n\n    // add .toArrayBuffer() method only when Uint8Array available\n    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;\n\n    // isUint64BE, isInt64BE\n    Int64[isName] = isInt64;\n\n    // CommonJS\n    exports[name] = Int64;\n\n    return Int64;\n\n    // constructor\n    function Int64(buffer, offset, value, raddix) {\n      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);\n      return init(this, buffer, offset, value, raddix);\n    }\n\n    // isUint64BE, isInt64BE\n    function isInt64(b) {\n      return !!(b && b[_isInt64]);\n    }\n\n    // initializer\n    function init(that, buffer, offset, value, raddix) {\n      if (UINT8ARRAY && ARRAYBUFFER) {\n        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);\n        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);\n      }\n\n      // Int64BE() style\n      if (!buffer && !offset && !value && !storage) {\n        // shortcut to initialize with zero\n        that.buffer = newArray(ZERO, 0);\n        return;\n      }\n\n      // Int64BE(value, raddix) style\n      if (!isValidBuffer(buffer, offset)) {\n        var _storage = storage || Array;\n        raddix = offset;\n        value = buffer;\n        offset = 0;\n        buffer = new _storage(8);\n      }\n\n      that.buffer = buffer;\n      that.offset = offset |= 0;\n\n      // Int64BE(buffer, offset) style\n      if (UNDEFINED === typeof value) return;\n\n      // Int64BE(buffer, offset, value, raddix) style\n      if (\"string\" === typeof value) {\n        fromString(buffer, offset, value, raddix || 10);\n      } else if (isValidBuffer(value, raddix)) {\n        fromArray(buffer, offset, value, raddix);\n      } else if (\"number\" === typeof raddix) {\n        writeInt32(buffer, offset + posH, value); // high\n        writeInt32(buffer, offset + posL, raddix); // low\n      } else if (value > 0) {\n        fromPositive(buffer, offset, value); // positive\n      } else if (value < 0) {\n        fromNegative(buffer, offset, value); // negative\n      } else {\n        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others\n      }\n    }\n\n    function fromString(buffer, offset, str, raddix) {\n      var pos = 0;\n      var len = str.length;\n      var high = 0;\n      var low = 0;\n      if (str[0] === \"-\") pos++;\n      var sign = pos;\n      while (pos < len) {\n        var chr = parseInt(str[pos++], raddix);\n        if (!(chr >= 0)) break; // NaN\n        low = low * raddix + chr;\n        high = high * raddix + Math.floor(low / BIT32);\n        low %= BIT32;\n      }\n      if (sign) {\n        high = ~high;\n        if (low) {\n          low = BIT32 - low;\n        } else {\n          high++;\n        }\n      }\n      writeInt32(buffer, offset + posH, high);\n      writeInt32(buffer, offset + posL, low);\n    }\n\n    function toNumber() {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      if (!unsigned) high |= 0; // a trick to get signed\n      return high ? (high * BIT32 + low) : low;\n    }\n\n    function toString(radix) {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      var str = \"\";\n      var sign = !unsigned && (high & 0x80000000);\n      if (sign) {\n        high = ~high;\n        low = BIT32 - low;\n      }\n      radix = radix || 10;\n      while (1) {\n        var mod = (high % radix) * BIT32 + low;\n        high = Math.floor(high / radix);\n        low = Math.floor(mod / radix);\n        str = (mod % radix).toString(radix) + str;\n        if (!high && !low) break;\n      }\n      if (sign) {\n        str = \"-\" + str;\n      }\n      return str;\n    }\n\n    function writeInt32(buffer, offset, value) {\n      buffer[offset + pos3] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos2] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos1] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos0] = value & 255;\n    }\n\n    function readInt32(buffer, offset) {\n      return (buffer[offset + pos0] * BIT24) +\n        (buffer[offset + pos1] << 16) +\n        (buffer[offset + pos2] << 8) +\n        buffer[offset + pos3];\n    }\n  }\n\n  function toArray(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = null; // Array\n    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;\n    return newArray(buffer, offset);\n  }\n\n  function toBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = BUFFER;\n    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;\n    var dest = new BUFFER(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest;\n  }\n\n  function toArrayBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    var arrbuf = buffer.buffer;\n    storage = UINT8ARRAY;\n    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;\n    var dest = new UINT8ARRAY(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest.buffer;\n  }\n\n  function isValidBuffer(buffer, offset) {\n    var len = buffer && buffer.length;\n    offset |= 0;\n    return len && (offset + 8 <= len) && (\"string\" !== typeof buffer[offset]);\n  }\n\n  function fromArray(destbuf, destoff, srcbuf, srcoff) {\n    destoff |= 0;\n    srcoff |= 0;\n    for (var i = 0; i < 8; i++) {\n      destbuf[destoff++] = srcbuf[srcoff++] & 255;\n    }\n  }\n\n  function newArray(buffer, offset) {\n    return Array.prototype.slice.call(buffer, offset, offset + 8);\n  }\n\n  function fromPositiveBE(buffer, offset, value) {\n    var pos = offset + 8;\n    while (pos > offset) {\n      buffer[--pos] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeBE(buffer, offset, value) {\n    var pos = offset + 8;\n    value++;\n    while (pos > offset) {\n      buffer[--pos] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  function fromPositiveLE(buffer, offset, value) {\n    var end = offset + 8;\n    while (offset < end) {\n      buffer[offset++] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeLE(buffer, offset, value) {\n    var end = offset + 8;\n    value++;\n    while (offset < end) {\n      buffer[offset++] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  // https://github.com/retrofox/is-array\n  function _isArray(val) {\n    return !!val && \"[object Array]\" == Object.prototype.toString.call(val);\n  }\n\n}(typeof exports === 'object' && typeof exports.nodeName !== 'string' ? exports : (this || {}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/int64-buffer/int64-buffer.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// browser.js\n\nexports.encode = __webpack_require__(/*! ./encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode;\nexports.decode = __webpack_require__(/*! ./decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode;\n\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"./node_modules/msgpack-lite/lib/encoder.js\").Encoder;\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"./node_modules/msgpack-lite/lib/decoder.js\").Decoder;\n\nexports.createCodec = __webpack_require__(/*! ./ext */ \"./node_modules/msgpack-lite/lib/ext.js\").createCodec;\nexports.codec = __webpack_require__(/*! ./codec */ \"./node_modules/msgpack-lite/lib/codec.js\").codec;\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/browser.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-global.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/* globals Buffer */\n\nmodule.exports =\n  c((\"undefined\" !== typeof Buffer) && Buffer) ||\n  c(this.Buffer) ||\n  c((\"undefined\" !== typeof window) && window.Buffer) ||\n  this.Buffer;\n\nfunction c(B) {\n  return B && B.isBuffer && B;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/buffer-global.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-lite.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// buffer-lite.js\n\nvar MAXBUFLEN = 8192;\n\nexports.copy = copy;\nexports.toString = toString;\nexports.write = write;\n\n/**\n * Buffer.prototype.write()\n *\n * @param string {String}\n * @param [offset] {Number}\n * @returns {Number}\n */\n\nfunction write(string, offset) {\n  var buffer = this;\n  var index = offset || (offset |= 0);\n  var length = string.length;\n  var chr = 0;\n  var i = 0;\n  while (i < length) {\n    chr = string.charCodeAt(i++);\n\n    if (chr < 128) {\n      buffer[index++] = chr;\n    } else if (chr < 0x800) {\n      // 2 bytes\n      buffer[index++] = 0xC0 | (chr >>> 6);\n      buffer[index++] = 0x80 | (chr & 0x3F);\n    } else if (chr < 0xD800 || chr > 0xDFFF) {\n      // 3 bytes\n      buffer[index++] = 0xE0 | (chr  >>> 12);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    } else {\n      // 4 bytes - surrogate pair\n      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;\n      buffer[index++] = 0xF0 | (chr >>> 18);\n      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    }\n  }\n  return index - offset;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var buffer = this;\n  var index = start|0;\n  if (!end) end = buffer.length;\n  var string = '';\n  var chr = 0;\n\n  while (index < end) {\n    chr = buffer[index++];\n    if (chr < 128) {\n      string += String.fromCharCode(chr);\n      continue;\n    }\n\n    if ((chr & 0xE0) === 0xC0) {\n      // 2 bytes\n      chr = (chr & 0x1F) << 6 |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF0) === 0xE0) {\n      // 3 bytes\n      chr = (chr & 0x0F)             << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF8) === 0xF0) {\n      // 4 bytes\n      chr = (chr & 0x07)             << 18 |\n            (buffer[index++] & 0x3F) << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n    }\n\n    if (chr >= 0x010000) {\n      // A surrogate pair\n      chr -= 0x010000;\n\n      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n    } else {\n      string += String.fromCharCode(chr);\n    }\n  }\n\n  return string;\n}\n\n/**\n * Buffer.prototype.copy()\n *\n * @param target {Buffer}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {number}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var i;\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (!targetStart) targetStart = 0;\n  var len = end - start;\n\n  if (target === this && start < targetStart && targetStart < end) {\n    // descending\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    // ascending\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start];\n    }\n  }\n\n  return len;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/buffer-lite.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = alloc(0);\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Array}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Array\n  return Array.prototype.slice.call(value);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-buffer.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];\n\nexports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Buffer(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Buffer\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Buffer\n  if (Buffer.from && Buffer.from.length !== 1) {\n    return Buffer.from(value); // node v6+\n  } else {\n    return new Buffer(value); // node v4\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-proto.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-proto.js\n\n/* jshint eqnull:true */\n\nvar BufferLite = __webpack_require__(/*! ./buffer-lite */ \"./node_modules/msgpack-lite/lib/buffer-lite.js\");\n\nexports.copy = copy;\nexports.slice = slice;\nexports.toString = toString;\nexports.write = gen(\"write\");\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar isBufferShim = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;\n\n/**\n * @param target {Buffer|Uint8Array|Array}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var thisIsBuffer = Bufferish.isBuffer(this);\n  var targetIsBuffer = Bufferish.isBuffer(target);\n  if (thisIsBuffer && targetIsBuffer) {\n    // Buffer to Buffer\n    return this.copy(target, targetStart, start, end);\n  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&\n    Bufferish.isView(this) && Bufferish.isView(target)) {\n    // Uint8Array to Uint8Array (except for minor some browsers)\n    var buffer = (start || end != null) ? slice.call(this, start, end) : this;\n    target.set(buffer, targetStart);\n    return buffer.length;\n  } else {\n    // other cases\n    return BufferLite.copy.call(this, target, targetStart, start, end);\n  }\n}\n\n/**\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction slice(start, end) {\n  // for Buffer, Uint8Array (except for minor some browsers) and Array\n  var f = this.slice || (!brokenTypedArray && this.subarray);\n  if (f) return f.call(this, start, end);\n\n  // Uint8Array (for minor some browsers)\n  var target = Bufferish.alloc.call(this, end - start);\n  copy.call(this, target, 0, start, end);\n  return target;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;\n  return f.apply(this, arguments);\n}\n\n/**\n * @private\n */\n\nfunction gen(method) {\n  return wrap;\n\n  function wrap() {\n    var f = this[method] || BufferLite[method];\n    return f.apply(this, arguments);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-proto.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js":
/*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-uint8array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Uint8Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Uint8Array}\n */\n\nfunction from(value) {\n  if (Bufferish.isView(value)) {\n    // TypedArray to ArrayBuffer\n    var byteOffset = value.byteOffset;\n    var byteLength = value.byteLength;\n    value = value.buffer;\n    if (value.byteLength !== byteLength) {\n      if (value.slice) {\n        value = value.slice(byteOffset, byteOffset + byteLength);\n      } else {\n        // Android 4.1 does not have ArrayBuffer.prototype.slice\n        value = new Uint8Array(value);\n        if (value.byteLength !== byteLength) {\n          // TypedArray to ArrayBuffer to Uint8Array to Array\n          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);\n        }\n      }\n    }\n  } else if (typeof value === \"string\") {\n    // String to Uint8Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  return new Uint8Array(value);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-uint8array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish.js\n\nvar Buffer = exports.global = __webpack_require__(/*! ./buffer-global */ \"./node_modules/msgpack-lite/lib/buffer-global.js\");\nvar hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;\nvar hasArrayBuffer = exports.hasArrayBuffer = (\"undefined\" !== typeof ArrayBuffer);\n\nvar isArray = exports.isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nexports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;\nvar isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;\nvar isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is(\"ArrayBuffer\", \"buffer\")) : _false;\n\nexports.alloc = alloc;\nexports.concat = concat;\nexports.from = from;\n\nvar BufferArray = exports.Array = __webpack_require__(/*! ./bufferish-array */ \"./node_modules/msgpack-lite/lib/bufferish-array.js\");\nvar BufferBuffer = exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */ \"./node_modules/msgpack-lite/lib/bufferish-buffer.js\");\nvar BufferUint8Array = exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */ \"./node_modules/msgpack-lite/lib/bufferish-uint8array.js\");\nvar BufferProto = exports.prototype = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction from(value) {\n  if (typeof value === \"string\") {\n    return fromString.call(this, value);\n  } else {\n    return auto(this).from(value);\n  }\n}\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return auto(this).alloc(size);\n}\n\n/**\n * @param list {Array} array of (Buffer|Uint8Array|Array)s\n * @param [length]\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction concat(list, length) {\n  if (!length) {\n    length = 0;\n    Array.prototype.forEach.call(list, dryrun);\n  }\n  var ref = (this !== exports) && this || list[0];\n  var result = alloc.call(ref, length);\n  var offset = 0;\n  Array.prototype.forEach.call(list, append);\n  return result;\n\n  function dryrun(buffer) {\n    length += buffer.length;\n  }\n\n  function append(buffer) {\n    offset += BufferProto.copy.call(buffer, result, offset);\n  }\n}\n\nvar _isArrayBuffer = _is(\"ArrayBuffer\");\n\nfunction isArrayBuffer(value) {\n  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);\n}\n\n/**\n * @private\n */\n\nfunction fromString(value) {\n  var expected = value.length * 3;\n  var that = alloc.call(this, expected);\n  var actual = BufferProto.write.call(that, value);\n  if (expected !== actual) {\n    that = BufferProto.slice.call(that, 0, actual);\n  }\n  return that;\n}\n\nfunction auto(that) {\n  return isBuffer(that) ? BufferBuffer\n    : isView(that) ? BufferUint8Array\n    : isArray(that) ? BufferArray\n    : hasBuffer ? BufferBuffer\n    : hasArrayBuffer ? BufferUint8Array\n    : BufferArray;\n}\n\nfunction _false() {\n  return false;\n}\n\nfunction _is(name, key) {\n  /* jshint eqnull:true */\n  name = \"[object \" + name + \"]\";\n  return function(value) {\n    return (value != null) && {}.toString.call(key ? value[key] : value) === name;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// codec-base.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n\nexports.createCodec = createCodec;\nexports.install = install;\nexports.filter = filter;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction Codec(options) {\n  if (!(this instanceof Codec)) return new Codec(options);\n  this.options = options;\n  this.init();\n}\n\nCodec.prototype.init = function() {\n  var options = this.options;\n\n  if (options && options.uint8array) {\n    this.bufferish = Bufferish.Uint8Array;\n  }\n\n  return this;\n};\n\nfunction install(props) {\n  for (var key in props) {\n    Codec.prototype[key] = add(Codec.prototype[key], props[key]);\n  }\n}\n\nfunction add(a, b) {\n  return (a && b) ? ab : (a || b);\n\n  function ab() {\n    a.apply(this, arguments);\n    return b.apply(this, arguments);\n  }\n}\n\nfunction join(filters) {\n  filters = filters.slice();\n\n  return function(value) {\n    return filters.reduce(iterator, value);\n  };\n\n  function iterator(value, filter) {\n    return filter(value);\n  }\n}\n\nfunction filter(filter) {\n  return IS_ARRAY(filter) ? join(filter) : filter;\n}\n\n// @public\n// msgpack.createCodec()\n\nfunction createCodec(options) {\n  return new Codec(options);\n}\n\n// default shared codec\n\nexports.preset = createCodec({preset: true});\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/codec-base.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec.js":
/*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// codec.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\n// @public\n// msgpack.codec.preset\n\nexports.codec = {\n  preset: __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").preset\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/codec.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decode-buffer.js\n\nexports.DecodeBuffer = DecodeBuffer;\n\nvar preset = __webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\").preset;\n\nvar FlexDecoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexDecoder;\n\nFlexDecoder.mixin(DecodeBuffer.prototype);\n\nfunction DecodeBuffer(options) {\n  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nDecodeBuffer.prototype.codec = preset;\n\nDecodeBuffer.prototype.fetch = function() {\n  return this.codec.decode(this);\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decode.js\n\nexports.decode = decode;\n\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction decode(input, options) {\n  var decoder = new DecodeBuffer(options);\n  decoder.write(input);\n  return decoder.read();\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decoder.js\n\nexports.Decoder = Decoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction Decoder(options) {\n  if (!(this instanceof Decoder)) return new Decoder(options);\n  DecodeBuffer.call(this, options);\n}\n\nDecoder.prototype = new DecodeBuffer();\n\nEventLite.mixin(Decoder.prototype);\n\nDecoder.prototype.decode = function(chunk) {\n  if (arguments.length) this.write(chunk);\n  this.flush();\n};\n\nDecoder.prototype.push = function(chunk) {\n  this.emit(\"data\", chunk);\n};\n\nDecoder.prototype.end = function(chunk) {\n  this.decode(chunk);\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encode-buffer.js\n\nexports.EncodeBuffer = EncodeBuffer;\n\nvar preset = __webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\").preset;\n\nvar FlexEncoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexEncoder;\n\nFlexEncoder.mixin(EncodeBuffer.prototype);\n\nfunction EncodeBuffer(options) {\n  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nEncodeBuffer.prototype.codec = preset;\n\nEncodeBuffer.prototype.write = function(input) {\n  this.codec.encode(this, input);\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encode.js\n\nexports.encode = encode;\n\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction encode(input, options) {\n  var encoder = new EncodeBuffer(options);\n  encoder.write(input);\n  return encoder.read();\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encoder.js\n\nexports.Encoder = Encoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction Encoder(options) {\n  if (!(this instanceof Encoder)) return new Encoder(options);\n  EncodeBuffer.call(this, options);\n}\n\nEncoder.prototype = new EncodeBuffer();\n\nEventLite.mixin(Encoder.prototype);\n\nEncoder.prototype.encode = function(chunk) {\n  this.write(chunk);\n  this.emit(\"data\", this.read());\n};\n\nEncoder.prototype.end = function(chunk) {\n  if (arguments.length) this.encode(chunk);\n  this.flush();\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-buffer.js\n\nexports.ExtBuffer = ExtBuffer;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction ExtBuffer(buffer, type) {\n  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);\n  this.buffer = Bufferish.from(buffer);\n  this.type = type;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-packer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-packer.js\n\nexports.setExtPackers = setExtPackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar packTypedArray = Bufferish.Uint8Array.from;\nvar _encode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtPackers(codec) {\n  codec.addExtPacker(0x0E, Error, [packError, encode]);\n  codec.addExtPacker(0x01, EvalError, [packError, encode]);\n  codec.addExtPacker(0x02, RangeError, [packError, encode]);\n  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);\n  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);\n  codec.addExtPacker(0x05, TypeError, [packError, encode]);\n  codec.addExtPacker(0x06, URIError, [packError, encode]);\n\n  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);\n  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);\n  codec.addExtPacker(0x0C, String, [packValueOf, encode]);\n  codec.addExtPacker(0x0D, Date, [Number, encode]);\n  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtPacker(0x11, Int8Array, packTypedArray);\n    codec.addExtPacker(0x12, Uint8Array, packTypedArray);\n    codec.addExtPacker(0x13, Int16Array, packTypedArray);\n    codec.addExtPacker(0x14, Uint16Array, packTypedArray);\n    codec.addExtPacker(0x15, Int32Array, packTypedArray);\n    codec.addExtPacker(0x16, Uint32Array, packTypedArray);\n    codec.addExtPacker(0x17, Float32Array, packTypedArray);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtPacker(0x18, Float64Array, packTypedArray);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);\n    }\n\n    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);\n    codec.addExtPacker(0x1D, DataView, packTypedArray);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtPacker(0x1B, Buffer, Bufferish.from);\n  }\n}\n\nfunction encode(input) {\n  if (!_encode) _encode = __webpack_require__(/*! ./encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode; // lazy load\n  return _encode(input);\n}\n\nfunction packValueOf(value) {\n  return (value).valueOf();\n}\n\nfunction packRegExp(value) {\n  value = RegExp.prototype.toString.call(value).split(\"/\");\n  value.shift();\n  var out = [value.pop()];\n  out.unshift(value.join(\"/\"));\n  return out;\n}\n\nfunction packError(value) {\n  var out = {};\n  for (var key in ERROR_COLUMNS) {\n    out[key] = value[key];\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-packer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-unpacker.js":
/*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-unpacker.js\n\nexports.setExtUnpackers = setExtUnpackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar _decode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtUnpackers(codec) {\n  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);\n  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);\n  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);\n  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);\n  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);\n  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);\n  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);\n\n  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);\n  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);\n  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);\n  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);\n  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtUnpacker(0x11, unpackClass(Int8Array));\n    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));\n    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);\n    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);\n    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);\n    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);\n    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));\n    }\n\n    codec.addExtUnpacker(0x1A, unpackArrayBuffer);\n    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtUnpacker(0x1B, unpackClass(Buffer));\n  }\n}\n\nfunction decode(input) {\n  if (!_decode) _decode = __webpack_require__(/*! ./decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode; // lazy load\n  return _decode(input);\n}\n\nfunction unpackRegExp(value) {\n  return RegExp.apply(null, value);\n}\n\nfunction unpackError(Class) {\n  return function(value) {\n    var out = new Class();\n    for (var key in ERROR_COLUMNS) {\n      out[key] = value[key];\n    }\n    return out;\n  };\n}\n\nfunction unpackClass(Class) {\n  return function(value) {\n    return new Class(value);\n  };\n}\n\nfunction unpackArrayBuffer(value) {\n  return (new Uint8Array(value)).buffer;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-unpacker.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext.js":
/*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\nexports.createCodec = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").createCodec;\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/flex-buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\n\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/flex-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-core.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */ \"./node_modules/msgpack-lite/lib/ext-unpacker.js\");\nvar readUint8 = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\").readUint8;\nvar ReadToken = __webpack_require__(/*! ./read-token */ \"./node_modules/msgpack-lite/lib/read-token.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtUnpacker: addExtUnpacker,\n  getExtUnpacker: getExtUnpacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getDecoder(options) {\n  var readToken = ReadToken.getReadToken(options);\n  return decode;\n\n  function decode(decoder) {\n    var type = readUint8(decoder);\n    var func = readToken[type];\n    if (!func) throw new Error(\"Invalid type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n    return func(decoder);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.decode = getDecoder(options);\n\n  if (options && options.preset) {\n    ExtUnpacker.setExtUnpackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtUnpacker(etype, unpacker) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  unpackers[etype] = CodecBase.filter(unpacker);\n}\n\nfunction getExtUnpacker(type) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  return unpackers[type] || extUnpacker;\n\n  function extUnpacker(buffer) {\n    return new ExtBuffer(buffer, type);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-format.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-format.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nexports.getReadFormat = getReadFormat;\nexports.readUint8 = uint8;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\nvar HAS_MAP = (\"undefined\" !== typeof Map);\nvar NO_ASSERT = true;\n\nfunction getReadFormat(options) {\n  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;\n  var int64 = options && options.int64;\n  var usemap = HAS_MAP && options && options.usemap;\n\n  var readFormat = {\n    map: (usemap ? map_to_map : map_to_obj),\n    array: array,\n    str: str,\n    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),\n    ext: ext,\n    uint8: uint8,\n    uint16: uint16,\n    uint32: uint32,\n    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),\n    int8: int8,\n    int16: int16,\n    int32: int32,\n    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),\n    float32: read(4, readFloatBE),\n    float64: read(8, readDoubleBE)\n  };\n\n  return readFormat;\n}\n\nfunction map_to_obj(decoder, len) {\n  var value = {};\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value[k[i]] = v[i];\n  }\n  return value;\n}\n\nfunction map_to_map(decoder, len) {\n  var value = new Map();\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value.set(k[i], v[i]);\n  }\n  return value;\n}\n\nfunction array(decoder, len) {\n  var value = new Array(len);\n  var decode = decoder.codec.decode;\n  for (var i = 0; i < len; i++) {\n    value[i] = decode(decoder);\n  }\n  return value;\n}\n\nfunction str(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  return BufferProto.toString.call(decoder.buffer, \"utf-8\", start, end);\n}\n\nfunction bin_buffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.from(buf);\n}\n\nfunction bin_arraybuffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.Uint8Array.from(buf).buffer;\n}\n\nfunction ext(decoder, len) {\n  var start = decoder.reserve(len+1);\n  var type = decoder.buffer[start++];\n  var end = start + len;\n  var unpack = decoder.codec.getExtUnpacker(type);\n  if (!unpack) throw new Error(\"Invalid ext type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return unpack(buf);\n}\n\nfunction uint8(decoder) {\n  var start = decoder.reserve(1);\n  return decoder.buffer[start];\n}\n\nfunction int8(decoder) {\n  var start = decoder.reserve(1);\n  var value = decoder.buffer[start];\n  return (value & 0x80) ? value - 0x100 : value;\n}\n\nfunction uint16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 8) | buffer[start];\n}\n\nfunction int16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  var value = (buffer[start++] << 8) | buffer[start];\n  return (value & 0x8000) ? value - 0x10000 : value;\n}\n\nfunction uint32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];\n}\n\nfunction int32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];\n}\n\nfunction read(len, method) {\n  return function(decoder) {\n    var start = decoder.reserve(len);\n    return method.call(decoder.buffer, start, NO_ASSERT);\n  };\n}\n\nfunction readUInt64BE(start) {\n  return new Uint64BE(this, start).toNumber();\n}\n\nfunction readInt64BE(start) {\n  return new Int64BE(this, start).toNumber();\n}\n\nfunction readUInt64BE_int64(start) {\n  return new Uint64BE(this, start);\n}\n\nfunction readInt64BE_int64(start) {\n  return new Int64BE(this, start);\n}\n\nfunction readFloatBE(start) {\n  return ieee754.read(this, start, false, 23, 4);\n}\n\nfunction readDoubleBE(start) {\n  return ieee754.read(this, start, false, 52, 8);\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-format.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-token.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-token.js\n\nvar ReadFormat = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\");\n\nexports.getReadToken = getReadToken;\n\nfunction getReadToken(options) {\n  var format = ReadFormat.getReadFormat(options);\n\n  if (options && options.useraw) {\n    return init_useraw(format);\n  } else {\n    return init_token(format);\n  }\n}\n\nfunction init_token(format) {\n  var i;\n  var token = new Array(256);\n\n  // positive fixint -- 0x00 - 0x7f\n  for (i = 0x00; i <= 0x7f; i++) {\n    token[i] = constant(i);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  for (i = 0x80; i <= 0x8f; i++) {\n    token[i] = fix(i - 0x80, format.map);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  for (i = 0x90; i <= 0x9f; i++) {\n    token[i] = fix(i - 0x90, format.array);\n  }\n\n  // fixstr -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.str);\n  }\n\n  // nil -- 0xc0\n  token[0xc0] = constant(null);\n\n  // (never used) -- 0xc1\n  token[0xc1] = null;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  token[0xc2] = constant(false);\n  token[0xc3] = constant(true);\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = flex(format.uint8, format.bin);\n  token[0xc5] = flex(format.uint16, format.bin);\n  token[0xc6] = flex(format.uint32, format.bin);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = flex(format.uint8, format.ext);\n  token[0xc8] = flex(format.uint16, format.ext);\n  token[0xc9] = flex(format.uint32, format.ext);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = format.float32;\n  token[0xcb] = format.float64;\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = format.uint8;\n  token[0xcd] = format.uint16;\n  token[0xce] = format.uint32;\n  token[0xcf] = format.uint64;\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = format.int8;\n  token[0xd1] = format.int16;\n  token[0xd2] = format.int32;\n  token[0xd3] = format.int64;\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  token[0xd4] = fix(1, format.ext);\n  token[0xd5] = fix(2, format.ext);\n  token[0xd6] = fix(4, format.ext);\n  token[0xd7] = fix(8, format.ext);\n  token[0xd8] = fix(16, format.ext);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = flex(format.uint8, format.str);\n  token[0xda] = flex(format.uint16, format.str);\n  token[0xdb] = flex(format.uint32, format.str);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = flex(format.uint16, format.array);\n  token[0xdd] = flex(format.uint32, format.array);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = flex(format.uint16, format.map);\n  token[0xdf] = flex(format.uint32, format.map);\n\n  // negative fixint -- 0xe0 - 0xff\n  for (i = 0xe0; i <= 0xff; i++) {\n    token[i] = constant(i - 0x100);\n  }\n\n  return token;\n}\n\nfunction init_useraw(format) {\n  var i;\n  var token = init_token(format).slice();\n\n  // raw 8 -- 0xd9\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  token[0xd9] = token[0xc4];\n  token[0xda] = token[0xc5];\n  token[0xdb] = token[0xc6];\n\n  // fixraw -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.bin);\n  }\n\n  return token;\n}\n\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nfunction flex(lenFunc, decodeFunc) {\n  return function(decoder) {\n    var len = lenFunc(decoder);\n    return decodeFunc(decoder, len);\n  };\n}\n\nfunction fix(len, method) {\n  return function(decoder) {\n    return method(decoder, len);\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-core.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtPacker = __webpack_require__(/*! ./ext-packer */ \"./node_modules/msgpack-lite/lib/ext-packer.js\");\nvar WriteType = __webpack_require__(/*! ./write-type */ \"./node_modules/msgpack-lite/lib/write-type.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtPacker: addExtPacker,\n  getExtPacker: getExtPacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getEncoder(options) {\n  var writeType = WriteType.getWriteType(options);\n  return encode;\n\n  function encode(encoder, value) {\n    var func = writeType[typeof value];\n    if (!func) throw new Error(\"Unsupported type \\\"\" + (typeof value) + \"\\\": \" + value);\n    func(encoder, value);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.encode = getEncoder(options);\n\n  if (options && options.preset) {\n    ExtPacker.setExtPackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtPacker(etype, Class, packer) {\n  packer = CodecBase.filter(packer);\n  var name = Class.name;\n  if (name && name !== \"Object\") {\n    var packers = this.extPackers || (this.extPackers = {});\n    packers[name] = extPacker;\n  } else {\n    // fallback for IE\n    var list = this.extEncoderList || (this.extEncoderList = []);\n    list.unshift([Class, extPacker]);\n  }\n\n  function extPacker(value) {\n    if (packer) value = packer(value);\n    return new ExtBuffer(value, etype);\n  }\n}\n\nfunction getExtPacker(value) {\n  var packers = this.extPackers || (this.extPackers = {});\n  var c = value.constructor;\n  var e = c && c.name && packers[c.name];\n  if (e) return e;\n\n  // fallback for IE\n  var list = this.extEncoderList || (this.extEncoderList = []);\n  var len = list.length;\n  for (var i = 0; i < len; i++) {\n    var pair = list[i];\n    if (c === pair[0]) return pair[1];\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-token.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-token.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar IS_BUFFER_SHIM = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;\nvar Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};\n\nexports.getWriteToken = getWriteToken;\n\nfunction getWriteToken(options) {\n  if (options && options.uint8array) {\n    return init_uint8array();\n  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {\n    return init_safe();\n  } else {\n    return init_token();\n  }\n}\n\nfunction init_uint8array() {\n  var token = init_token();\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);\n\n  return token;\n}\n\n// Node.js and browsers with TypedArray\n\nfunction init_token() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = write1(0xc4);\n  token[0xc5] = write2(0xc5);\n  token[0xc6] = write4(0xc6);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = write1(0xc7);\n  token[0xc8] = write2(0xc8);\n  token[0xc9] = write4(0xc9);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);\n  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = write1(0xcc);\n  token[0xcd] = write2(0xcd);\n  token[0xce] = write4(0xce);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = write1(0xd0);\n  token[0xd1] = write2(0xd1);\n  token[0xd2] = write4(0xd2);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = write1(0xd9);\n  token[0xda] = write2(0xda);\n  token[0xdb] = write4(0xdb);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = write2(0xdc);\n  token[0xdd] = write4(0xdd);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = write2(0xde);\n  token[0xdf] = write4(0xdf);\n\n  return token;\n}\n\n// safe mode: for old browsers and who needs asserts\n\nfunction init_safe() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);\n  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);\n  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);\n  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);\n  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);\n  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);\n  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);\n  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);\n\n  return token;\n}\n\nfunction write1(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(2);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset] = value;\n  };\n}\n\nfunction write2(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(3);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction write4(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(5);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 24;\n    buffer[offset++] = value >>> 16;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction writeN(type, len, method, noAssert) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(len + 1);\n    encoder.buffer[offset++] = type;\n    method.call(encoder.buffer, value, offset, noAssert);\n  };\n}\n\nfunction writeUInt64BE(value, offset) {\n  new Uint64BE(this, offset, value);\n}\n\nfunction writeInt64BE(value, offset) {\n  new Int64BE(this, offset, value);\n}\n\nfunction writeFloatBE(value, offset) {\n  ieee754.write(this, value, offset, false, 23, 4);\n}\n\nfunction writeDoubleBE(value, offset) {\n  ieee754.write(this, value, offset, false, 52, 8);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-type.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-type.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\nvar WriteToken = __webpack_require__(/*! ./write-token */ \"./node_modules/msgpack-lite/lib/write-token.js\");\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = (\"undefined\" !== typeof Uint8Array);\nvar HAS_MAP = (\"undefined\" !== typeof Map);\n\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\n\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": (useraw ? object_raw : object),\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n\n  return writeType;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;\n    }\n    token[type](encoder, ivalue);\n  }\n\n  // uint 64 -- 0xcf\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  }\n\n  // int 64 -- 0xd3\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  }\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n  function str_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer;\n\n      // expected header size\n      var expected = head_size(length);\n\n      // expected start point\n      var start = encoder.offset + expected;\n\n      // write string\n      length = BufferProto.write.call(buffer, value, start);\n\n      // actual header size\n      var actual = head_size(length);\n\n      // move content when needed\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      }\n\n      // write header\n      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;\n      token[type](encoder, length);\n\n      // move cursor\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value);\n\n    // Buffer\n    if (isBuffer(value)) return bin(encoder, value);\n\n    // Array\n    if (IS_ARRAY(value)) return array(encoder, value);\n\n    // int64-buffer objects\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value);\n\n    // ext formats\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value);\n\n    // plain old Objects or Map\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value);\n\n    // others\n    object(encoder, value);\n  }\n\n  // nil -- 0xc0\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  function array(encoder, value) {\n    var length = value.length;\n    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  }\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  }\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    keys.forEach(function(key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n\n    var length = value.size;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    value.forEach(function(val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-type.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-uint8.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// write-unit8.js\n\nvar constant = exports.uint8 = new Array(256);\n\nfor (var i = 0x00; i <= 0xFF; i++) {\n  constant[i] = write0(i);\n}\n\nfunction write0(type) {\n  return function(encoder) {\n    var offset = encoder.reserve(1);\n    encoder.buffer[offset] = type;\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-uint8.js?");

/***/ }),

/***/ "./node_modules/redux-thunk/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/redux-thunk/es/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (thunk);\n\n//# sourceURL=webpack:///./node_modules/redux-thunk/es/index.js?");

/***/ }),

/***/ "./node_modules/redux/es/redux.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/redux.js ***!
  \****************************************/
/*! exports provided: createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createStore\", function() { return createStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combineReducers\", function() { return combineReducers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindActionCreators\", function() { return bindActionCreators; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyMiddleware\", function() { return applyMiddleware; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compose\", function() { return compose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__DO_NOT_USE__ActionTypes\", function() { return ActionTypes; });\n/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ \"./node_modules/symbol-observable/es/index.js\");\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),\n  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;\n\n  var proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[\"default\"]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[\"default\"]] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && 'action \"' + String(actionType) + '\"' || 'an action';\n\n  return 'Given ' + actionDescription + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (true) {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (true) {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (true) {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var store = createStore.apply(undefined, args);\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(undefined, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\nfunction isCrushed() {}\n\nif (\"development\" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning(\"You are currently using minified code outside of NODE_ENV === 'production'. \" + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/redux/es/redux.js?");

/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ \"./node_modules/symbol-observable/es/ponyfill.js\");\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(root);\n/* harmony default export */ __webpack_exports__[\"default\"] = (result);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/symbol-observable/es/index.js?");

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/symbol-observable/es/ponyfill.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./scene.tsx":
/*!*******************!*\
  !*** ./scene.tsx ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tetris; });\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decentraland-api */ \"./node_modules/decentraland-api/lib/index.js\");\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(decentraland_api__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux-thunk */ \"./node_modules/redux-thunk/es/index.js\");\n/* harmony import */ var _src_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/reducers */ \"./src/reducers.ts\");\n\n\n\n\nclass Tetris extends decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"ScriptableScene\"] {\n    constructor(opts, ...other) {\n        super(opts, ...other);\n        this.store = Object(redux__WEBPACK_IMPORTED_MODULE_1__[\"createStore\"])(_src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"reducer\"], Object(redux__WEBPACK_IMPORTED_MODULE_1__[\"applyMiddleware\"])(redux_thunk__WEBPACK_IMPORTED_MODULE_2__[\"default\"]));\n        this.setState(this.store.getState());\n        this.store.dispatch({ restart: true, type: 'restart' });\n    }\n    sceneDidMount() {\n        this.store.subscribe(() => {\n            this.setState(this.store.getState());\n        });\n        this.subscribeTo('click', async (e) => {\n            const turn = this.store.getState().turn;\n            switch (e.elementId) {\n                case 'pass':\n                    this.store.dispatch({ pass: true, color: turn, type: 'pass' });\n                    break;\n                case 'restart':\n                    this.store.dispatch({ restart: true, type: 'restart' });\n                    break;\n                default:\n                    if (e.elementId && e.elementId.startsWith('empty_')) {\n                        this.store.dispatch({ color: turn, type: 'move', position: Object(_src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"getPositionFromString\"])(e.elementId.substr(6)) });\n                    }\n                    break;\n            }\n        });\n    }\n    async render() {\n        return (Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"scene\", null,\n            Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(PassButton, Object.assign({}, this.state)),\n            Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Restart, Object.assign({}, this.state)),\n            Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(BoardF, Object.assign({}, this.state))));\n    }\n}\nfunction PassButton() {\n    return Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"box\", { id: \"pass\", position: { x: 0.5, y: 15, z: 0.5 }, color: '#0000FF' });\n}\nfunction Restart() {\n    return Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"box\", { id: \"restart\", position: { x: 1.5, y: 15, z: 0.5 }, color: '#ff0000' });\n}\nconst WHITE = '#FAFAFA';\nconst BLACK = '#2f2f2f';\nfunction BoardF(state) {\n    return Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"entity\", { position: { x: 1.5, y: 0, z: 1.5 } },\n        Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"material\", { id: \"transparent\", alpha: 0 }),\n        Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"basic-material\", { id: \"backboard\", texture: \"board.jpg\" }),\n        Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"box\", { material: \"#backboard\", position: { x: 8.46, y: 0.01, z: 8.48 }, scale: { x: 19.25, y: 0.001, z: 19.2 } }),\n        Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"entity\", { position: { x: -0.5, y: 0, z: -0.5 } }, state.board && state.board.map((row, rowIndex) => Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"entity\", null, row.map((color, colIndex) => token(rowIndex, colIndex, color))))));\n}\nconst TRANSPARENT = '#FF00FF';\nfunction token(rowIndex, colIndex, color) {\n    const pos = Object(_src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"getPositionAsString\"])({ x: rowIndex, y: colIndex });\n    const id = color + '_' + pos;\n    const colorValue = (color === _src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"white\"]) ? WHITE : (color === _src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"black\"]) ? BLACK : TRANSPARENT;\n    if (color === _src_reducers__WEBPACK_IMPORTED_MODULE_3__[\"empty\"]) {\n        return Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"box\", { position: { x: colIndex, y: 0.1, z: rowIndex }, scale: { x: 1, y: 0.01, z: 1 }, id: id, color: colorValue, material: colorValue === TRANSPARENT ? '#transparent' : '' });\n    }\n    return Object(decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"cylinder\", { segmentsRadial: 16, segmentsHeight: 1, radius: 0.5, position: { x: colIndex, y: 0.1, z: rowIndex }, scale: { x: 1, y: 0.01, z: 1 }, id: id, color: colorValue });\n}\n\n\n//# sourceURL=webpack:///./scene.tsx?");

/***/ }),

/***/ "./src/reducers.ts":
/*!*************************!*\
  !*** ./src/reducers.ts ***!
  \*************************/
/*! exports provided: BOARD_SIZE, empty, black, white, newBoard, INITIAL_STATE, equalPosition, copyBoard, isValidMove, getPositionAsString, getPositionFromString, DELTA, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BOARD_SIZE\", function() { return BOARD_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"black\", function() { return black; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"white\", function() { return white; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newBoard\", function() { return newBoard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INITIAL_STATE\", function() { return INITIAL_STATE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equalPosition\", function() { return equalPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyBoard\", function() { return copyBoard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidMove\", function() { return isValidMove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPositionAsString\", function() { return getPositionAsString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPositionFromString\", function() { return getPositionFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DELTA\", function() { return DELTA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reducer\", function() { return reducer; });\nconst BOARD_SIZE = 19;\nconst empty = 'empty';\nconst black = 'black';\nconst white = 'white';\nfunction newBoard() {\n    return new Array(BOARD_SIZE).fill(0).map(() => new Array(BOARD_SIZE).fill(empty));\n}\nconst INITIAL_STATE = {\n    board: newBoard(),\n    turn: black,\n    scoreBlack: 0,\n    scoreWhite: 0,\n    moves: new Array()\n};\nfunction equalPosition(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\nfunction copyBoard(board) {\n    return new Array(BOARD_SIZE).fill(0).map((_, row) => board[row].slice(0));\n}\nfunction isValidMove(game, action) {\n    if (action.color !== game.turn)\n        return false;\n    if (action.pass && action.position)\n        return false;\n    if (!action.position && !action.pass)\n        return false;\n    if (!action.pass && game.tie && equalPosition(action.position, game.tie))\n        return false;\n    if (!action.pass && game.board[action.position.x][action.position.y] !== empty)\n        return false;\n    return true;\n}\nfunction getPositionAsString(pos) {\n    return `${pos.x},${pos.y}`;\n}\nfunction getPositionFromString(pos) {\n    const values = pos.split(',').map(x => parseInt(x, 10));\n    return { x: values[0], y: values[1] };\n}\nconst DELTA = [\n    { x: 0, y: 1 },\n    { x: 1, y: 0 },\n    { x: -1, y: 0 },\n    { x: 0, y: -1 }\n];\nfunction getNeighbours(pos) {\n    return DELTA\n        .map(delta => ({ x: pos.x + delta.x, y: pos.y + delta.y }))\n        .filter(val => val.x >= 0 && val.x < BOARD_SIZE && val.y >= 0 && val.y < BOARD_SIZE);\n}\nfunction countGroup(board, position) {\n    const queue = [position];\n    const color = board[position.x][position.y];\n    let liberties = 0;\n    const seen = { [getPositionAsString(position)]: true };\n    while (queue.length) {\n        const value = queue.shift();\n        const neighbours = getNeighbours(value);\n        for (let neighbor of neighbours) {\n            if (board[neighbor.x][neighbor.y] === empty)\n                liberties++;\n            if (board[neighbor.x][neighbor.y] === color) {\n                const neighborString = getPositionAsString(neighbor);\n                if (!seen[neighborString]) {\n                    queue.push(neighbor);\n                    seen[neighborString] = true;\n                }\n            }\n        }\n    }\n    return { liberties, group: Object.keys(seen).map(getPositionFromString) };\n}\nfunction takeout(board, position) {\n    const color = board[position.x][position.y];\n    let result = [];\n    for (let neighbor of getNeighbours(position)) {\n        if (board[neighbor.x][neighbor.y] === color)\n            continue;\n        if (board[neighbor.x][neighbor.y] === empty)\n            continue;\n        const group = countGroup(board, neighbor);\n        if (group.liberties === 0) {\n            for (let dead of group.group) {\n                board[dead.x][dead.y] = empty;\n            }\n            result = Array.prototype.concat(result, group.group);\n        }\n    }\n    return result;\n}\nfunction reducer(game, action) {\n    if (!game)\n        return Object.freeze(INITIAL_STATE) && INITIAL_STATE;\n    if (!action)\n        return game;\n    if (action.restart)\n        return INITIAL_STATE;\n    if (game.ended)\n        return game;\n    if (!isValidMove(game, action))\n        return game;\n    const board = copyBoard(game.board);\n    let eaten = 0;\n    let isTie = undefined;\n    let isPass = !!action.pass;\n    let isEnded = game.pass && !!action.pass;\n    let moves = Array.prototype.concat([], game.moves, action);\n    if (!action.pass) {\n        board[action.position.x][action.position.y] = action.color;\n        const deletedBlocks = takeout(board, action.position);\n        if (!countGroup(board, action.position).liberties) {\n            if (!deletedBlocks.length) {\n                return game;\n            }\n        }\n        if (deletedBlocks.length === 1) {\n            const hypothetical = copyBoard(board);\n            hypothetical[deletedBlocks[0].x][deletedBlocks[0].y] = action.color === white ? black : white;\n            hypothetical[action.position.x][action.position.y] = action.color;\n            const deletedHypothetical = takeout(hypothetical, action.position);\n            if (!countGroup(hypothetical, deletedBlocks[0]).liberties && deletedHypothetical.length === 1) {\n                isTie = deletedBlocks[0];\n            }\n        }\n        eaten = deletedBlocks.length;\n    }\n    else {\n        if (!!game.pass) {\n            isEnded = true;\n        }\n    }\n    return {\n        board,\n        turn: game.turn === white ? black : white,\n        tie: isTie,\n        pass: isPass,\n        ended: isEnded,\n        moves: moves,\n        scoreBlack: game.turn === black ? game.scoreBlack + eaten : game.scoreBlack,\n        scoreWhite: game.turn === white ? game.scoreWhite + eaten : game.scoreWhite\n    };\n}\nconst cases = [{\n        caseName: 'First move',\n        actions: [{ color: black, position: { x: 10, y: 10 } }],\n        evaluation: (game) => game.turn === white\n    }, {\n        caseName: 'Pass',\n        actions: [{ color: black, position: { x: 10, y: 10 } }, { color: white, pass: true }],\n        evaluation: (game) => game.turn === black && game.moves.length === 2\n    }, {\n        caseName: 'Invalid position',\n        actions: [{ color: black, position: { x: 10, y: 10 } }, { color: white, position: { x: 10, y: 10 } }],\n        evaluation: (game) => game.turn === white && game.moves.length === 1\n    }, {\n        caseName: 'Capture increases score',\n        actions: [\n            { color: black, position: { x: 0, y: 1 } },\n            { color: white, position: { x: 0, y: 0 } },\n            { color: black, position: { x: 1, y: 0 } },\n        ],\n        evaluation: (game) => game.turn === white && game.scoreBlack === 1\n    }, {\n        caseName: 'Cant play tie',\n        actions: [\n            { color: black, position: { x: 1, y: 0 } },\n            { color: white, position: { x: 1, y: 3 } },\n            { color: black, position: { x: 0, y: 1 } },\n            { color: white, position: { x: 0, y: 2 } },\n            { color: black, position: { x: 2, y: 1 } },\n            { color: white, position: { x: 2, y: 2 } },\n            { color: black, position: { x: 1, y: 2 } },\n            { color: white, position: { x: 1, y: 1 } },\n            { color: black, position: { x: 1, y: 1 } },\n        ],\n        evaluation: (game) => game.turn === black && !!(game.tie) && equalPosition(game.tie, { x: 1, y: 2 })\n    }];\nif (!module.parent) {\n    function testIt(testCase) {\n        let game = INITIAL_STATE;\n        for (let action of testCase.actions) {\n            game = reducer(game, action);\n        }\n        return testCase.evaluation(game);\n    }\n    const sum = (a, b) => a + (b ? 1 : 0);\n    const count = cases.map((testCase, index) => {\n        const result = testIt(testCase);\n        if (result)\n            console.log(` ✅ ${index + 1}: ${testCase.caseName}`);\n        else\n            console.log(` ⛔️ ${index + 1}: ${testCase.caseName}`);\n        return result;\n    }).reduce(sum, 0);\n    console.log(`\\n${count}/${cases.length} tests passed`);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./src/reducers.ts?");

/***/ })

/******/ })));